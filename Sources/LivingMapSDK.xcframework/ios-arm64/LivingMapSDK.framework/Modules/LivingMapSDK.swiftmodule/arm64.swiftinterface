// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5.1 (swiftlang-1300.0.31.4 clang-1300.0.29.6)
// swift-module-flags: -target arm64-apple-ios12.1 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name LivingMapSDK
import Accelerate
import Combine
import CoreBluetooth
import CoreFoundation
import CoreLocation
import CoreML
import CoreMotion
import Dispatch
import Foundation
import Foundation/*.Thread*/
import Foundation/*.TimeInterval*/
@_exported import LivingMapSDK
import MobileCoreServices
import Network
import Swift
import SwiftProtobuf
import SwiftUI
import SystemConfiguration
import UIKit
import WebKit
import _Concurrency
@_hasMissingDesignatedInitializers public class Request {
  public enum State {
    case initialized
    case resumed
    case suspended
    case cancelled
    case finished
    public static func == (a: LivingMapSDK.Request.State, b: LivingMapSDK.Request.State) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let id: Foundation.UUID
  final public let underlyingQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let eventMonitor: LivingMapSDK.EventMonitor?
  final public let interceptor: LivingMapSDK.RequestInterceptor?
  weak public var delegate: LivingMapSDK.RequestDelegate? {
    get
  }
  public var state: LivingMapSDK.Request.State {
    get
  }
  public var isInitialized: Swift.Bool {
    get
  }
  public var isResumed: Swift.Bool {
    get
  }
  public var isSuspended: Swift.Bool {
    get
  }
  public var isCancelled: Swift.Bool {
    get
  }
  public var isFinished: Swift.Bool {
    get
  }
  public typealias ProgressHandler = (Foundation.Progress) -> Swift.Void
  final public let uploadProgress: Foundation.Progress
  final public let downloadProgress: Foundation.Progress
  public var redirectHandler: LivingMapSDK.RedirectHandler? {
    get
  }
  public var cachedResponseHandler: LivingMapSDK.CachedResponseHandler? {
    get
  }
  public var credential: Foundation.URLCredential? {
    get
  }
  public var requests: [Foundation.URLRequest] {
    get
  }
  public var firstRequest: Foundation.URLRequest? {
    get
  }
  public var lastRequest: Foundation.URLRequest? {
    get
  }
  public var request: Foundation.URLRequest? {
    get
  }
  public var performedRequests: [Foundation.URLRequest] {
    get
  }
  public var response: Foundation.HTTPURLResponse? {
    get
  }
  public var tasks: [Foundation.URLSessionTask] {
    get
  }
  public var firstTask: Foundation.URLSessionTask? {
    get
  }
  public var lastTask: Foundation.URLSessionTask? {
    get
  }
  public var task: Foundation.URLSessionTask? {
    get
  }
  public var allMetrics: [Foundation.URLSessionTaskMetrics] {
    get
  }
  public var firstMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var lastMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var retryCount: Swift.Int {
    get
  }
  public var error: LivingMapSDK.AFError? {
    get
  }
  @discardableResult
  public func cancel() -> Self
  @discardableResult
  public func suspend() -> Self
  @discardableResult
  public func resume() -> Self
  @discardableResult
  public func authenticate(username: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence = .forSession) -> Self
  @discardableResult
  public func authenticate(with credential: Foundation.URLCredential) -> Self
  @discardableResult
  public func downloadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping LivingMapSDK.Request.ProgressHandler) -> Self
  @discardableResult
  public func uploadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping LivingMapSDK.Request.ProgressHandler) -> Self
  @discardableResult
  public func redirect(using handler: LivingMapSDK.RedirectHandler) -> Self
  @discardableResult
  public func cacheResponse(using handler: LivingMapSDK.CachedResponseHandler) -> Self
  @discardableResult
  public func cURLDescription(on queue: Dispatch.DispatchQueue, calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func cURLDescription(calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func onURLRequestCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLRequest) -> Swift.Void) -> Self
  @discardableResult
  public func onURLSessionTaskCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLSessionTask) -> Swift.Void) -> Self
  @objc deinit
}
extension LivingMapSDK.Request : Swift.Equatable {
  public static func == (lhs: LivingMapSDK.Request, rhs: LivingMapSDK.Request) -> Swift.Bool
}
extension LivingMapSDK.Request : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Request : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LivingMapSDK.Request {
  public func cURLDescription() -> Swift.String
}
public protocol RequestDelegate : AnyObject {
  var sessionConfiguration: Foundation.URLSessionConfiguration { get }
  var startImmediately: Swift.Bool { get }
  func cleanup(after request: LivingMapSDK.Request)
  func retryResult(for request: LivingMapSDK.Request, dueTo error: LivingMapSDK.AFError, completion: @escaping (LivingMapSDK.RetryResult) -> Swift.Void)
  func retryRequest(_ request: LivingMapSDK.Request, withDelay timeDelay: Foundation.TimeInterval?)
}
@_hasMissingDesignatedInitializers public class DataRequest : LivingMapSDK.Request {
  final public let convertible: LivingMapSDK.URLRequestConvertible
  public var data: Foundation.Data? {
    get
  }
  @discardableResult
  public func validate(_ validation: @escaping LivingMapSDK.DataRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DataStreamRequest : LivingMapSDK.Request {
  public typealias Handler<Success, Failure> = (LivingMapSDK.DataStreamRequest.Stream<Success, Failure>) throws -> Swift.Void where Failure : Swift.Error
  public struct Stream<Success, Failure> where Failure : Swift.Error {
    public let event: LivingMapSDK.DataStreamRequest.Event<Success, Failure>
    public let token: LivingMapSDK.DataStreamRequest.CancellationToken
    public func cancel()
  }
  public enum Event<Success, Failure> where Failure : Swift.Error {
    case stream(Swift.Result<Success, Failure>)
    case complete(LivingMapSDK.DataStreamRequest.Completion)
  }
  public struct Completion {
    public let request: Foundation.URLRequest?
    public let response: Foundation.HTTPURLResponse?
    public let metrics: Foundation.URLSessionTaskMetrics?
    public let error: LivingMapSDK.AFError?
  }
  public struct CancellationToken {
    public func cancel()
  }
  final public let convertible: LivingMapSDK.URLRequestConvertible
  final public let automaticallyCancelOnStreamError: Swift.Bool
  @discardableResult
  final public func validate(_ validation: @escaping LivingMapSDK.DataStreamRequest.Validation) -> Self
  final public func asInputStream(bufferSize: Swift.Int = 1024) -> Foundation.InputStream?
  @objc deinit
}
extension LivingMapSDK.DataStreamRequest.Stream {
  public var result: Swift.Result<Success, Failure>? {
    get
  }
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public var completion: LivingMapSDK.DataStreamRequest.Completion? {
    get
  }
}
@_hasMissingDesignatedInitializers public class DownloadRequest : LivingMapSDK.Request {
  public struct Options : Swift.OptionSet {
    public static var createIntermediateDirectories: LivingMapSDK.DownloadRequest.Options
    public static var removePreviousFile: LivingMapSDK.DownloadRequest.Options
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias ArrayLiteralElement = LivingMapSDK.DownloadRequest.Options
    public typealias Element = LivingMapSDK.DownloadRequest.Options
    public typealias RawValue = Swift.Int
  }
  public typealias Destination = (_ temporaryURL: Foundation.URL, _ response: Foundation.HTTPURLResponse) -> (destinationURL: Foundation.URL, options: LivingMapSDK.DownloadRequest.Options)
  public class func suggestedDownloadDestination(for directory: Foundation.FileManager.SearchPathDirectory = .documentDirectory, in domain: Foundation.FileManager.SearchPathDomainMask = .userDomainMask, options: LivingMapSDK.DownloadRequest.Options = []) -> LivingMapSDK.DownloadRequest.Destination
  public enum Downloadable {
    case request(LivingMapSDK.URLRequestConvertible)
    case resumeData(Foundation.Data)
  }
  public var resumeData: Foundation.Data? {
    get
  }
  public var fileURL: Foundation.URL? {
    get
  }
  final public let downloadable: LivingMapSDK.DownloadRequest.Downloadable
  public func task(forResumeData data: Foundation.Data, using session: Foundation.URLSession) -> Foundation.URLSessionTask
  @discardableResult
  override public func cancel() -> Self
  @discardableResult
  public func cancel(producingResumeData shouldProduceResumeData: Swift.Bool) -> Self
  @discardableResult
  public func cancel(byProducingResumeData completionHandler: @escaping (_ data: Foundation.Data?) -> Swift.Void) -> Self
  @discardableResult
  public func validate(_ validation: @escaping LivingMapSDK.DownloadRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers public class UploadRequest : LivingMapSDK.DataRequest {
  public enum Uploadable {
    case data(Foundation.Data)
    case file(Foundation.URL, shouldRemove: Swift.Bool)
    case stream(Foundation.InputStream)
  }
  final public let upload: LivingMapSDK.UploadableConvertible
  final public let fileManager: Foundation.FileManager
  public var uploadable: LivingMapSDK.UploadRequest.Uploadable?
  public func cleanup()
  @objc deinit
}
public protocol UploadableConvertible {
  func createUploadable() throws -> LivingMapSDK.UploadRequest.Uploadable
}
extension LivingMapSDK.UploadRequest.Uploadable : LivingMapSDK.UploadableConvertible {
  public func createUploadable() throws -> LivingMapSDK.UploadRequest.Uploadable
}
public protocol UploadConvertible : LivingMapSDK.URLRequestConvertible, LivingMapSDK.UploadableConvertible {
}
public enum AFError : Swift.Error {
  public enum MultipartEncodingFailureReason {
    case bodyPartURLInvalid(url: Foundation.URL)
    case bodyPartFilenameInvalid(in: Foundation.URL)
    case bodyPartFileNotReachable(at: Foundation.URL)
    case bodyPartFileNotReachableWithError(atURL: Foundation.URL, error: Swift.Error)
    case bodyPartFileIsDirectory(at: Foundation.URL)
    case bodyPartFileSizeNotAvailable(at: Foundation.URL)
    case bodyPartFileSizeQueryFailedWithError(forURL: Foundation.URL, error: Swift.Error)
    case bodyPartInputStreamCreationFailed(for: Foundation.URL)
    case outputStreamCreationFailed(for: Foundation.URL)
    case outputStreamFileAlreadyExists(at: Foundation.URL)
    case outputStreamURLInvalid(url: Foundation.URL)
    case outputStreamWriteFailed(error: Swift.Error)
    case inputStreamReadFailed(error: Swift.Error)
  }
  public struct UnexpectedInputStreamLength : Swift.Error {
    public var bytesExpected: Swift.UInt64
    public var bytesRead: Swift.UInt64
  }
  public enum ParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: Swift.Error)
    case customEncodingFailed(error: Swift.Error)
  }
  public enum ParameterEncoderFailureReason {
    public enum RequiredComponent {
      case url
      case httpMethod(rawValue: Swift.String)
    }
    case missingRequiredComponent(LivingMapSDK.AFError.ParameterEncoderFailureReason.RequiredComponent)
    case encoderFailed(error: Swift.Error)
  }
  public enum ResponseValidationFailureReason {
    case dataFileNil
    case dataFileReadFailed(at: Foundation.URL)
    case missingContentType(acceptableContentTypes: [Swift.String])
    case unacceptableContentType(acceptableContentTypes: [Swift.String], responseContentType: Swift.String)
    case unacceptableStatusCode(code: Swift.Int)
    case customValidationFailed(error: Swift.Error)
  }
  public enum ResponseSerializationFailureReason {
    case inputDataNilOrZeroLength
    case inputFileNil
    case inputFileReadFailed(at: Foundation.URL)
    case stringSerializationFailed(encoding: Swift.String.Encoding)
    case jsonSerializationFailed(error: Swift.Error)
    case decodingFailed(error: Swift.Error)
    case customSerializationFailed(error: Swift.Error)
    case invalidEmptyResponse(type: Swift.String)
  }
  public enum ServerTrustFailureReason {
    public struct Output {
      public let host: Swift.String
      public let trust: Security.SecTrust
      public let status: Darwin.OSStatus
      public let result: Security.SecTrustResultType
    }
    case noRequiredEvaluator(host: Swift.String)
    case noCertificatesFound
    case noPublicKeysFound
    case policyApplicationFailed(trust: Security.SecTrust, policy: Security.SecPolicy, status: Darwin.OSStatus)
    case settingAnchorCertificatesFailed(status: Darwin.OSStatus, certificates: [Security.SecCertificate])
    case revocationPolicyCreationFailed
    case trustEvaluationFailed(error: Swift.Error?)
    case defaultEvaluationFailed(output: LivingMapSDK.AFError.ServerTrustFailureReason.Output)
    case hostValidationFailed(output: LivingMapSDK.AFError.ServerTrustFailureReason.Output)
    case revocationCheckFailed(output: LivingMapSDK.AFError.ServerTrustFailureReason.Output, options: LivingMapSDK.RevocationTrustEvaluator.Options)
    case certificatePinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedCertificates: [Security.SecCertificate], serverCertificates: [Security.SecCertificate])
    case publicKeyPinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedKeys: [Security.SecKey], serverKeys: [Security.SecKey])
    case customEvaluationFailed(error: Swift.Error)
  }
  public enum URLRequestValidationFailureReason {
    case bodyDataInGETRequest(Foundation.Data)
  }
  case createUploadableFailed(error: Swift.Error)
  case createURLRequestFailed(error: Swift.Error)
  case downloadedFileMoveFailed(error: Swift.Error, source: Foundation.URL, destination: Foundation.URL)
  case explicitlyCancelled
  case invalidURL(url: LivingMapSDK.URLConvertible)
  case multipartEncodingFailed(reason: LivingMapSDK.AFError.MultipartEncodingFailureReason)
  case parameterEncodingFailed(reason: LivingMapSDK.AFError.ParameterEncodingFailureReason)
  case parameterEncoderFailed(reason: LivingMapSDK.AFError.ParameterEncoderFailureReason)
  case requestAdaptationFailed(error: Swift.Error)
  case requestRetryFailed(retryError: Swift.Error, originalError: Swift.Error)
  case responseValidationFailed(reason: LivingMapSDK.AFError.ResponseValidationFailureReason)
  case responseSerializationFailed(reason: LivingMapSDK.AFError.ResponseSerializationFailureReason)
  case serverTrustEvaluationFailed(reason: LivingMapSDK.AFError.ServerTrustFailureReason)
  case sessionDeinitialized
  case sessionInvalidated(error: Swift.Error?)
  case sessionTaskFailed(error: Swift.Error)
  case urlRequestValidationFailed(reason: LivingMapSDK.AFError.URLRequestValidationFailureReason)
}
extension Swift.Error {
  public var asAFError: LivingMapSDK.AFError? {
    get
  }
  public func asAFError(orFailWith message: @autoclosure () -> Swift.String, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> LivingMapSDK.AFError
}
extension LivingMapSDK.AFError {
  public var isSessionDeinitializedError: Swift.Bool {
    get
  }
  public var isSessionInvalidatedError: Swift.Bool {
    get
  }
  public var isExplicitlyCancelledError: Swift.Bool {
    get
  }
  public var isInvalidURLError: Swift.Bool {
    get
  }
  public var isParameterEncodingError: Swift.Bool {
    get
  }
  public var isParameterEncoderError: Swift.Bool {
    get
  }
  public var isMultipartEncodingError: Swift.Bool {
    get
  }
  public var isRequestAdaptationError: Swift.Bool {
    get
  }
  public var isResponseValidationError: Swift.Bool {
    get
  }
  public var isResponseSerializationError: Swift.Bool {
    get
  }
  public var isServerTrustEvaluationError: Swift.Bool {
    get
  }
  public var isRequestRetryError: Swift.Bool {
    get
  }
  public var isCreateUploadableError: Swift.Bool {
    get
  }
  public var isCreateURLRequestError: Swift.Bool {
    get
  }
  public var isDownloadedFileMoveError: Swift.Bool {
    get
  }
  public var isSessionTaskError: Swift.Bool {
    get
  }
}
extension LivingMapSDK.AFError {
  public var urlConvertible: LivingMapSDK.URLConvertible? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var underlyingError: Swift.Error? {
    get
  }
  public var acceptableContentTypes: [Swift.String]? {
    get
  }
  public var responseContentType: Swift.String? {
    get
  }
  public var responseCode: Swift.Int? {
    get
  }
  public var failedStringEncoding: Swift.String.Encoding? {
    get
  }
  public var sourceURL: Foundation.URL? {
    get
  }
  public var destinationURL: Foundation.URL? {
    get
  }
  public var downloadResumeData: Foundation.Data? {
    get
  }
}
extension LivingMapSDK.AFError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public struct ManifestCallbacks {
  public let onManifestFailure: ((LivingMapSDK.LivingMapError) throws -> Swift.Void)?
  public let onCacheCompletion: ((LivingMapSDK.CacheManifest) -> Swift.Void)?
  public let onManifestRetrieval: ((LivingMapSDK.CacheManifest) -> Swift.Void)?
  public let cacheProgressUpdate: ((LivingMapSDK.CacheProgress) -> Swift.Void)?
  public init(onManifestRetrieval: ((LivingMapSDK.CacheManifest) -> Swift.Void)? = nil, onManifestFailure: ((LivingMapSDK.LivingMapError) throws -> Swift.Void)? = nil, onCacheCompletion: ((LivingMapSDK.CacheManifest) -> Swift.Void)? = nil, cacheProgressUpdate: ((LivingMapSDK.CacheProgress) -> Swift.Void)? = nil)
}
@_hasMissingDesignatedInitializers public class LivingMapErrorHandler {
  public static func logError(error: Foundation.NSError)
  @objc deinit
}
public typealias AFDataResponse<Success> = LivingMapSDK.DataResponse<Success, LivingMapSDK.AFError>
public typealias AFDownloadResponse<Success> = LivingMapSDK.DownloadResponse<Success, LivingMapSDK.AFError>
public struct DataResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension LivingMapSDK.DataResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension LivingMapSDK.DataResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> LivingMapSDK.DataResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> LivingMapSDK.DataResponse<NewSuccess, Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> LivingMapSDK.DataResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> LivingMapSDK.DataResponse<Success, Swift.Error> where NewFailure : Swift.Error
}
public struct DownloadResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let fileURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, resumeData: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension LivingMapSDK.DownloadResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension LivingMapSDK.DownloadResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> LivingMapSDK.DownloadResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> LivingMapSDK.DownloadResponse<NewSuccess, Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> LivingMapSDK.DownloadResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> LivingMapSDK.DownloadResponse<Success, Swift.Error> where NewFailure : Swift.Error
}
@_hasMissingDesignatedInitializers public class LMLocation : Swift.Codable, Foundation.NSCopying {
  public var x: Swift.Double
  public var y: Swift.Double
  public var floor: Swift.Int32
  public var heading: Swift.Double
  public var accuracy: Swift.Double
  @objc public var timestamp: Swift.Double
  public var coordRefSystem: LivingMapSDK.LMLocation.CoordinateReferenceSystem
  public var appIsInForeground: Swift.Bool?
  public var locationSource: LivingMapSDK.LMLocation.LocationSource?
  public var gyroHeading: Swift.Double?
  public var deviceId: Swift.String?
  public var journeyId: Swift.Int?
  public init(x: Swift.Double, y: Swift.Double, floor: Swift.Int32 = -1, heading: Swift.Double = -1, accuracy: Swift.Double = 10, timestamp: Swift.Double, coordRefSystem: LivingMapSDK.LMLocation.CoordinateReferenceSystem = LMLocation.CoordinateReferenceSystem.UNDEFINED, locationSource: LivingMapSDK.LMLocation.LocationSource? = nil)
  public func toString() -> Swift.String
  @objc public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
extension LivingMapSDK.LMLocation {
  public enum CoordinateReferenceSystem : Swift.Int32, Swift.Codable {
    case UNDEFINED
    case EPSG_00000
    case EPSG_4326
    public init?(rawValue: Swift.Int32)
    public typealias RawValue = Swift.Int32
    public var rawValue: Swift.Int32 {
      get
    }
  }
  public enum LocationSource : Swift.String, Swift.Codable {
    case beacon
    case indoorCoreLocation
    case outdoorCoreLocation
    case commonPositioningLibrary
    case pedestrianDeadReckoning
    case floorChange
    case userDefinedLocation
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum LocationError : Swift.Error {
    case invalidCRSConversion
    public static func == (a: LivingMapSDK.LMLocation.LocationError, b: LivingMapSDK.LMLocation.LocationError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public struct RequestAdapterState {
  public let requestID: Foundation.UUID
  public let session: LivingMapSDK.Session
}
public protocol RequestAdapter {
  func adapt(_ urlRequest: Foundation.URLRequest, for session: LivingMapSDK.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  func adapt(_ urlRequest: Foundation.URLRequest, using state: LivingMapSDK.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
}
extension LivingMapSDK.RequestAdapter {
  public func adapt(_ urlRequest: Foundation.URLRequest, using state: LivingMapSDK.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
}
public enum RetryResult {
  case retry
  case retryWithDelay(Foundation.TimeInterval)
  case doNotRetry
  case doNotRetryWithError(Swift.Error)
}
public protocol RequestRetrier {
  func retry(_ request: LivingMapSDK.Request, for session: LivingMapSDK.Session, dueTo error: Swift.Error, completion: @escaping (LivingMapSDK.RetryResult) -> Swift.Void)
}
public protocol RequestInterceptor : LivingMapSDK.RequestAdapter, LivingMapSDK.RequestRetrier {
}
extension LivingMapSDK.RequestInterceptor {
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: LivingMapSDK.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  public func retry(_ request: LivingMapSDK.Request, for session: LivingMapSDK.Session, dueTo error: Swift.Error, completion: @escaping (LivingMapSDK.RetryResult) -> Swift.Void)
}
public typealias AdaptHandler = (Foundation.URLRequest, LivingMapSDK.Session, _ completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void) -> Swift.Void
public typealias RetryHandler = (LivingMapSDK.Request, LivingMapSDK.Session, Swift.Error, _ completion: @escaping (LivingMapSDK.RetryResult) -> Swift.Void) -> Swift.Void
open class Adapter : LivingMapSDK.RequestInterceptor {
  public init(_ adaptHandler: @escaping LivingMapSDK.AdaptHandler)
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: LivingMapSDK.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  open func adapt(_ urlRequest: Foundation.URLRequest, using state: LivingMapSDK.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  @objc deinit
}
extension LivingMapSDK.RequestAdapter where Self == LivingMapSDK.Adapter {
  public static func adapter(using closure: @escaping LivingMapSDK.AdaptHandler) -> LivingMapSDK.Adapter
}
open class Retrier : LivingMapSDK.RequestInterceptor {
  public init(_ retryHandler: @escaping LivingMapSDK.RetryHandler)
  open func retry(_ request: LivingMapSDK.Request, for session: LivingMapSDK.Session, dueTo error: Swift.Error, completion: @escaping (LivingMapSDK.RetryResult) -> Swift.Void)
  @objc deinit
}
extension LivingMapSDK.RequestRetrier where Self == LivingMapSDK.Retrier {
  public static func retrier(using closure: @escaping LivingMapSDK.RetryHandler) -> LivingMapSDK.Retrier
}
open class Interceptor : LivingMapSDK.RequestInterceptor {
  final public let adapters: [LivingMapSDK.RequestAdapter]
  final public let retriers: [LivingMapSDK.RequestRetrier]
  public init(adaptHandler: @escaping LivingMapSDK.AdaptHandler, retryHandler: @escaping LivingMapSDK.RetryHandler)
  public init(adapter: LivingMapSDK.RequestAdapter, retrier: LivingMapSDK.RequestRetrier)
  public init(adapters: [LivingMapSDK.RequestAdapter] = [], retriers: [LivingMapSDK.RequestRetrier] = [], interceptors: [LivingMapSDK.RequestInterceptor] = [])
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: LivingMapSDK.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  open func adapt(_ urlRequest: Foundation.URLRequest, using state: LivingMapSDK.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  open func retry(_ request: LivingMapSDK.Request, for session: LivingMapSDK.Session, dueTo error: Swift.Error, completion: @escaping (LivingMapSDK.RetryResult) -> Swift.Void)
  @objc deinit
}
extension LivingMapSDK.RequestInterceptor where Self == LivingMapSDK.Interceptor {
  public static func interceptor(adapter: @escaping LivingMapSDK.AdaptHandler, retrier: @escaping LivingMapSDK.RetryHandler) -> LivingMapSDK.Interceptor
  public static func interceptor(adapter: LivingMapSDK.RequestAdapter, retrier: LivingMapSDK.RequestRetrier) -> LivingMapSDK.Interceptor
  public static func interceptor(adapters: [LivingMapSDK.RequestAdapter] = [], retriers: [LivingMapSDK.RequestRetrier] = [], interceptors: [LivingMapSDK.RequestInterceptor] = []) -> LivingMapSDK.Interceptor
}
public struct FileDownloadCallbacks {
}
public protocol EventMonitor {
  var queue: Dispatch.DispatchQueue { get }
  func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  func request(_ request: LivingMapSDK.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: LivingMapSDK.Request, didFailToCreateURLRequestWithError error: LivingMapSDK.AFError)
  func request(_ request: LivingMapSDK.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  func request(_ request: LivingMapSDK.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: LivingMapSDK.AFError)
  func request(_ request: LivingMapSDK.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: LivingMapSDK.Request, didCreateTask task: Foundation.URLSessionTask)
  func request(_ request: LivingMapSDK.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  func request(_ request: LivingMapSDK.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: LivingMapSDK.AFError)
  func request(_ request: LivingMapSDK.Request, didCompleteTask task: Foundation.URLSessionTask, with error: LivingMapSDK.AFError?)
  func requestIsRetrying(_ request: LivingMapSDK.Request)
  func requestDidFinish(_ request: LivingMapSDK.Request)
  func requestDidResume(_ request: LivingMapSDK.Request)
  func request(_ request: LivingMapSDK.Request, didResumeTask task: Foundation.URLSessionTask)
  func requestDidSuspend(_ request: LivingMapSDK.Request)
  func request(_ request: LivingMapSDK.Request, didSuspendTask task: Foundation.URLSessionTask)
  func requestDidCancel(_ request: LivingMapSDK.Request)
  func request(_ request: LivingMapSDK.Request, didCancelTask task: Foundation.URLSessionTask)
  func request(_ request: LivingMapSDK.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: LivingMapSDK.Request.ValidationResult)
  func request(_ request: LivingMapSDK.DataRequest, didParseResponse response: LivingMapSDK.DataResponse<Foundation.Data?, LivingMapSDK.AFError>)
  func request<Value>(_ request: LivingMapSDK.DataRequest, didParseResponse response: LivingMapSDK.DataResponse<Value, LivingMapSDK.AFError>)
  func request(_ request: LivingMapSDK.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: LivingMapSDK.Request.ValidationResult)
  func request<Value>(_ request: LivingMapSDK.DataStreamRequest, didParseStream result: Swift.Result<Value, LivingMapSDK.AFError>)
  func request(_ request: LivingMapSDK.UploadRequest, didCreateUploadable uploadable: LivingMapSDK.UploadRequest.Uploadable)
  func request(_ request: LivingMapSDK.UploadRequest, didFailToCreateUploadableWithError error: LivingMapSDK.AFError)
  func request(_ request: LivingMapSDK.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  func request(_ request: LivingMapSDK.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, LivingMapSDK.AFError>)
  func request(_ request: LivingMapSDK.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  func request(_ request: LivingMapSDK.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: LivingMapSDK.Request.ValidationResult)
  func request(_ request: LivingMapSDK.DownloadRequest, didParseResponse response: LivingMapSDK.DownloadResponse<Foundation.URL?, LivingMapSDK.AFError>)
  func request<Value>(_ request: LivingMapSDK.DownloadRequest, didParseResponse response: LivingMapSDK.DownloadResponse<Value, LivingMapSDK.AFError>)
}
extension LivingMapSDK.EventMonitor {
  public var queue: Dispatch.DispatchQueue {
    get
  }
  public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  public func request(_ request: LivingMapSDK.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: LivingMapSDK.Request, didFailToCreateURLRequestWithError error: LivingMapSDK.AFError)
  public func request(_ request: LivingMapSDK.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  public func request(_ request: LivingMapSDK.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: LivingMapSDK.AFError)
  public func request(_ request: LivingMapSDK.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: LivingMapSDK.Request, didCreateTask task: Foundation.URLSessionTask)
  public func request(_ request: LivingMapSDK.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  public func request(_ request: LivingMapSDK.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: LivingMapSDK.AFError)
  public func request(_ request: LivingMapSDK.Request, didCompleteTask task: Foundation.URLSessionTask, with error: LivingMapSDK.AFError?)
  public func requestIsRetrying(_ request: LivingMapSDK.Request)
  public func requestDidFinish(_ request: LivingMapSDK.Request)
  public func requestDidResume(_ request: LivingMapSDK.Request)
  public func request(_ request: LivingMapSDK.Request, didResumeTask task: Foundation.URLSessionTask)
  public func requestDidSuspend(_ request: LivingMapSDK.Request)
  public func request(_ request: LivingMapSDK.Request, didSuspendTask task: Foundation.URLSessionTask)
  public func requestDidCancel(_ request: LivingMapSDK.Request)
  public func request(_ request: LivingMapSDK.Request, didCancelTask task: Foundation.URLSessionTask)
  public func request(_ request: LivingMapSDK.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: LivingMapSDK.Request.ValidationResult)
  public func request(_ request: LivingMapSDK.DataRequest, didParseResponse response: LivingMapSDK.DataResponse<Foundation.Data?, LivingMapSDK.AFError>)
  public func request<Value>(_ request: LivingMapSDK.DataRequest, didParseResponse response: LivingMapSDK.DataResponse<Value, LivingMapSDK.AFError>)
  public func request(_ request: LivingMapSDK.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: LivingMapSDK.Request.ValidationResult)
  public func request<Value>(_ request: LivingMapSDK.DataStreamRequest, didParseStream result: Swift.Result<Value, LivingMapSDK.AFError>)
  public func request(_ request: LivingMapSDK.UploadRequest, didCreateUploadable uploadable: LivingMapSDK.UploadRequest.Uploadable)
  public func request(_ request: LivingMapSDK.UploadRequest, didFailToCreateUploadableWithError error: LivingMapSDK.AFError)
  public func request(_ request: LivingMapSDK.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  public func request(_ request: LivingMapSDK.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, LivingMapSDK.AFError>)
  public func request(_ request: LivingMapSDK.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  public func request(_ request: LivingMapSDK.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: LivingMapSDK.Request.ValidationResult)
  public func request(_ request: LivingMapSDK.DownloadRequest, didParseResponse response: LivingMapSDK.DownloadResponse<Foundation.URL?, LivingMapSDK.AFError>)
  public func request<Value>(_ request: LivingMapSDK.DownloadRequest, didParseResponse response: LivingMapSDK.DownloadResponse<Value, LivingMapSDK.AFError>)
}
@_hasMissingDesignatedInitializers final public class CompositeEventMonitor : LivingMapSDK.EventMonitor {
  final public let queue: Dispatch.DispatchQueue
  final public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  final public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  final public func request(_ request: LivingMapSDK.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: LivingMapSDK.Request, didFailToCreateURLRequestWithError error: LivingMapSDK.AFError)
  final public func request(_ request: LivingMapSDK.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  final public func request(_ request: LivingMapSDK.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: LivingMapSDK.AFError)
  final public func request(_ request: LivingMapSDK.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: LivingMapSDK.Request, didCreateTask task: Foundation.URLSessionTask)
  final public func request(_ request: LivingMapSDK.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  final public func request(_ request: LivingMapSDK.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: LivingMapSDK.AFError)
  final public func request(_ request: LivingMapSDK.Request, didCompleteTask task: Foundation.URLSessionTask, with error: LivingMapSDK.AFError?)
  final public func requestIsRetrying(_ request: LivingMapSDK.Request)
  final public func requestDidFinish(_ request: LivingMapSDK.Request)
  final public func requestDidResume(_ request: LivingMapSDK.Request)
  final public func request(_ request: LivingMapSDK.Request, didResumeTask task: Foundation.URLSessionTask)
  final public func requestDidSuspend(_ request: LivingMapSDK.Request)
  final public func request(_ request: LivingMapSDK.Request, didSuspendTask task: Foundation.URLSessionTask)
  final public func requestDidCancel(_ request: LivingMapSDK.Request)
  final public func request(_ request: LivingMapSDK.Request, didCancelTask task: Foundation.URLSessionTask)
  final public func request(_ request: LivingMapSDK.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: LivingMapSDK.Request.ValidationResult)
  final public func request(_ request: LivingMapSDK.DataRequest, didParseResponse response: LivingMapSDK.DataResponse<Foundation.Data?, LivingMapSDK.AFError>)
  final public func request<Value>(_ request: LivingMapSDK.DataRequest, didParseResponse response: LivingMapSDK.DataResponse<Value, LivingMapSDK.AFError>)
  final public func request(_ request: LivingMapSDK.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: LivingMapSDK.Request.ValidationResult)
  final public func request<Value>(_ request: LivingMapSDK.DataStreamRequest, didParseStream result: Swift.Result<Value, LivingMapSDK.AFError>)
  final public func request(_ request: LivingMapSDK.UploadRequest, didCreateUploadable uploadable: LivingMapSDK.UploadRequest.Uploadable)
  final public func request(_ request: LivingMapSDK.UploadRequest, didFailToCreateUploadableWithError error: LivingMapSDK.AFError)
  final public func request(_ request: LivingMapSDK.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  final public func request(_ request: LivingMapSDK.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, LivingMapSDK.AFError>)
  final public func request(_ request: LivingMapSDK.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  final public func request(_ request: LivingMapSDK.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: LivingMapSDK.Request.ValidationResult)
  final public func request(_ request: LivingMapSDK.DownloadRequest, didParseResponse response: LivingMapSDK.DownloadResponse<Foundation.URL?, LivingMapSDK.AFError>)
  final public func request<Value>(_ request: LivingMapSDK.DownloadRequest, didParseResponse response: LivingMapSDK.DownloadResponse<Value, LivingMapSDK.AFError>)
  @objc deinit
}
open class ClosureEventMonitor : LivingMapSDK.EventMonitor {
  open var sessionDidBecomeInvalidWithError: ((Foundation.URLSession, Swift.Error?) -> Swift.Void)?
  open var taskDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge) -> Swift.Void)?
  open var taskDidSendBodyData: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var taskNeedNewBodyStream: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var taskWillPerformHTTPRedirection: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest) -> Swift.Void)?
  open var taskDidFinishCollectingMetrics: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var taskDidComplete: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Error?) -> Swift.Void)?
  open var taskIsWaitingForConnectivity: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var dataTaskDidReceiveData: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.Data) -> Swift.Void)?
  open var dataTaskWillCacheResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Swift.Void)?
  open var downloadTaskDidFinishDownloadingToURL: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Foundation.URL) -> Swift.Void)?
  open var downloadTaskDidWriteData: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var downloadTaskDidResumeAtOffset: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var requestDidCreateInitialURLRequest: ((LivingMapSDK.Request, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToCreateURLRequestWithError: ((LivingMapSDK.Request, LivingMapSDK.AFError) -> Swift.Void)?
  open var requestDidAdaptInitialRequestToAdaptedRequest: ((LivingMapSDK.Request, Foundation.URLRequest, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToAdaptURLRequestWithError: ((LivingMapSDK.Request, Foundation.URLRequest, LivingMapSDK.AFError) -> Swift.Void)?
  open var requestDidCreateURLRequest: ((LivingMapSDK.Request, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidCreateTask: ((LivingMapSDK.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidGatherMetrics: ((LivingMapSDK.Request, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var requestDidFailTaskEarlyWithError: ((LivingMapSDK.Request, Foundation.URLSessionTask, LivingMapSDK.AFError) -> Swift.Void)?
  open var requestDidCompleteTaskWithError: ((LivingMapSDK.Request, Foundation.URLSessionTask, LivingMapSDK.AFError?) -> Swift.Void)?
  open var requestIsRetrying: ((LivingMapSDK.Request) -> Swift.Void)?
  open var requestDidFinish: ((LivingMapSDK.Request) -> Swift.Void)?
  open var requestDidResume: ((LivingMapSDK.Request) -> Swift.Void)?
  open var requestDidResumeTask: ((LivingMapSDK.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidSuspend: ((LivingMapSDK.Request) -> Swift.Void)?
  open var requestDidSuspendTask: ((LivingMapSDK.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidCancel: ((LivingMapSDK.Request) -> Swift.Void)?
  open var requestDidCancelTask: ((LivingMapSDK.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidValidateRequestResponseDataWithResult: ((LivingMapSDK.DataRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?, LivingMapSDK.Request.ValidationResult) -> Swift.Void)?
  open var requestDidParseResponse: ((LivingMapSDK.DataRequest, LivingMapSDK.DataResponse<Foundation.Data?, LivingMapSDK.AFError>) -> Swift.Void)?
  open var requestDidValidateRequestResponseWithResult: ((LivingMapSDK.DataStreamRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, LivingMapSDK.Request.ValidationResult) -> Swift.Void)?
  open var requestDidCreateUploadable: ((LivingMapSDK.UploadRequest, LivingMapSDK.UploadRequest.Uploadable) -> Swift.Void)?
  open var requestDidFailToCreateUploadableWithError: ((LivingMapSDK.UploadRequest, LivingMapSDK.AFError) -> Swift.Void)?
  open var requestDidProvideInputStream: ((LivingMapSDK.UploadRequest, Foundation.InputStream) -> Swift.Void)?
  open var requestDidFinishDownloadingUsingTaskWithResult: ((LivingMapSDK.DownloadRequest, Foundation.URLSessionTask, Swift.Result<Foundation.URL, LivingMapSDK.AFError>) -> Swift.Void)?
  open var requestDidCreateDestinationURL: ((LivingMapSDK.DownloadRequest, Foundation.URL) -> Swift.Void)?
  open var requestDidValidateRequestResponseFileURLWithResult: ((LivingMapSDK.DownloadRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.URL?, LivingMapSDK.Request.ValidationResult) -> Swift.Void)?
  open var requestDidParseDownloadResponse: ((LivingMapSDK.DownloadRequest, LivingMapSDK.DownloadResponse<Foundation.URL?, LivingMapSDK.AFError>) -> Swift.Void)?
  final public let queue: Dispatch.DispatchQueue
  public init(queue: Dispatch.DispatchQueue = .main)
  open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  open func request(_ request: LivingMapSDK.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: LivingMapSDK.Request, didFailToCreateURLRequestWithError error: LivingMapSDK.AFError)
  open func request(_ request: LivingMapSDK.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  open func request(_ request: LivingMapSDK.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: LivingMapSDK.AFError)
  open func request(_ request: LivingMapSDK.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: LivingMapSDK.Request, didCreateTask task: Foundation.URLSessionTask)
  open func request(_ request: LivingMapSDK.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  open func request(_ request: LivingMapSDK.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: LivingMapSDK.AFError)
  open func request(_ request: LivingMapSDK.Request, didCompleteTask task: Foundation.URLSessionTask, with error: LivingMapSDK.AFError?)
  open func requestIsRetrying(_ request: LivingMapSDK.Request)
  open func requestDidFinish(_ request: LivingMapSDK.Request)
  open func requestDidResume(_ request: LivingMapSDK.Request)
  public func request(_ request: LivingMapSDK.Request, didResumeTask task: Foundation.URLSessionTask)
  open func requestDidSuspend(_ request: LivingMapSDK.Request)
  public func request(_ request: LivingMapSDK.Request, didSuspendTask task: Foundation.URLSessionTask)
  open func requestDidCancel(_ request: LivingMapSDK.Request)
  public func request(_ request: LivingMapSDK.Request, didCancelTask task: Foundation.URLSessionTask)
  open func request(_ request: LivingMapSDK.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: LivingMapSDK.Request.ValidationResult)
  open func request(_ request: LivingMapSDK.DataRequest, didParseResponse response: LivingMapSDK.DataResponse<Foundation.Data?, LivingMapSDK.AFError>)
  public func request(_ request: LivingMapSDK.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: LivingMapSDK.Request.ValidationResult)
  open func request(_ request: LivingMapSDK.UploadRequest, didCreateUploadable uploadable: LivingMapSDK.UploadRequest.Uploadable)
  open func request(_ request: LivingMapSDK.UploadRequest, didFailToCreateUploadableWithError error: LivingMapSDK.AFError)
  open func request(_ request: LivingMapSDK.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  open func request(_ request: LivingMapSDK.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, LivingMapSDK.AFError>)
  open func request(_ request: LivingMapSDK.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  open func request(_ request: LivingMapSDK.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: LivingMapSDK.Request.ValidationResult)
  open func request(_ request: LivingMapSDK.DownloadRequest, didParseResponse response: LivingMapSDK.DownloadResponse<Foundation.URL?, LivingMapSDK.AFError>)
  @objc deinit
}
public enum PMKError : Swift.Error {
  case invalidCallingConvention
  case returnedSelf
  case badInput
  case cancelled
  @available(*, deprecated, message: "See: `compactMap`")
  case flatMap(Any, Any.Type)
  case compactMap(Any, Any.Type)
  case emptySequence
  case noWinner
}
extension LivingMapSDK.PMKError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension LivingMapSDK.PMKError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public protocol CancellableError : Swift.Error {
  var isCancelled: Swift.Bool { get }
}
extension Swift.Error {
  public var isCancelled: Swift.Bool {
    get
  }
}
public enum CatchPolicy {
  case allErrors
  case allErrorsExceptCancellation
  public static func == (a: LivingMapSDK.CatchPolicy, b: LivingMapSDK.CatchPolicy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct HTTPHeaders {
  public init()
  public init(_ headers: [LivingMapSDK.HTTPHeader])
  public init(_ dictionary: [Swift.String : Swift.String])
  public mutating func add(name: Swift.String, value: Swift.String)
  public mutating func add(_ header: LivingMapSDK.HTTPHeader)
  public mutating func update(name: Swift.String, value: Swift.String)
  public mutating func update(_ header: LivingMapSDK.HTTPHeader)
  public mutating func remove(name: Swift.String)
  public mutating func sort()
  public func sorted() -> LivingMapSDK.HTTPHeaders
  public func value(for name: Swift.String) -> Swift.String?
  public subscript(name: Swift.String) -> Swift.String? {
    get
    set(newValue)
  }
  public var dictionary: [Swift.String : Swift.String] {
    get
  }
}
extension LivingMapSDK.HTTPHeaders : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Swift.String)...)
  public typealias Key = Swift.String
  public typealias Value = Swift.String
}
extension LivingMapSDK.HTTPHeaders : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: LivingMapSDK.HTTPHeader...)
  public typealias ArrayLiteralElement = LivingMapSDK.HTTPHeader
}
extension LivingMapSDK.HTTPHeaders : Swift.Sequence {
  public func makeIterator() -> Swift.IndexingIterator<[LivingMapSDK.HTTPHeader]>
}
extension LivingMapSDK.HTTPHeaders : Swift.Collection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(position: Swift.Int) -> LivingMapSDK.HTTPHeader {
    get
  }
  public func index(after i: Swift.Int) -> Swift.Int
  public typealias Element = LivingMapSDK.HTTPHeader
  public typealias Index = Swift.Int
  public typealias Indices = Swift.DefaultIndices<LivingMapSDK.HTTPHeaders>
  public typealias Iterator = Swift.IndexingIterator<[LivingMapSDK.HTTPHeader]>
  public typealias SubSequence = Swift.Slice<LivingMapSDK.HTTPHeaders>
}
extension LivingMapSDK.HTTPHeaders : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct HTTPHeader : Swift.Hashable {
  public let name: Swift.String
  public let value: Swift.String
  public init(name: Swift.String, value: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LivingMapSDK.HTTPHeader, b: LivingMapSDK.HTTPHeader) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.HTTPHeader : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LivingMapSDK.HTTPHeader {
  public static func accept(_ value: Swift.String) -> LivingMapSDK.HTTPHeader
  public static func acceptCharset(_ value: Swift.String) -> LivingMapSDK.HTTPHeader
  public static func acceptLanguage(_ value: Swift.String) -> LivingMapSDK.HTTPHeader
  public static func acceptEncoding(_ value: Swift.String) -> LivingMapSDK.HTTPHeader
  public static func authorization(username: Swift.String, password: Swift.String) -> LivingMapSDK.HTTPHeader
  public static func authorization(bearerToken: Swift.String) -> LivingMapSDK.HTTPHeader
  public static func authorization(_ value: Swift.String) -> LivingMapSDK.HTTPHeader
  public static func contentDisposition(_ value: Swift.String) -> LivingMapSDK.HTTPHeader
  public static func contentType(_ value: Swift.String) -> LivingMapSDK.HTTPHeader
  public static func userAgent(_ value: Swift.String) -> LivingMapSDK.HTTPHeader
}
extension LivingMapSDK.HTTPHeaders {
  public static var `default`: LivingMapSDK.HTTPHeaders
}
extension LivingMapSDK.HTTPHeader {
  public static var defaultAcceptEncoding: LivingMapSDK.HTTPHeader
  public static var defaultAcceptLanguage: LivingMapSDK.HTTPHeader
  public static var defaultUserAgent: LivingMapSDK.HTTPHeader
}
extension Foundation.URLRequest {
  public var headers: LivingMapSDK.HTTPHeaders {
    get
    set(newValue)
  }
}
extension Foundation.HTTPURLResponse {
  public var headers: LivingMapSDK.HTTPHeaders {
    get
  }
}
extension Foundation.URLSessionConfiguration {
  public var headers: LivingMapSDK.HTTPHeaders {
    get
    set(newValue)
  }
}
public class MapNotification {
  public enum NotificationType : Swift.String {
    case INFO
    case DEBUG
    case WARNING
    case ERROR
    case SUCCESS
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Icon : Swift.String {
    case FLIGHT_INFORMATION
    case NO_INTERNET
    case PASS
    case WARNING
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public init(livingMapSDKManager: LivingMapSDK.LivingMapSDKManager, type: LivingMapSDK.MapNotification.NotificationType, text: Swift.String, icon: LivingMapSDK.MapNotification.Icon, colour: Swift.String?, textColour: Swift.String?)
  public func show()
  public func hide()
  public class Builder {
    public init()
    public func type(_ type: LivingMapSDK.MapNotification.NotificationType) -> LivingMapSDK.MapNotification.Builder
    public func text(_ text: Swift.String) -> LivingMapSDK.MapNotification.Builder
    public func icon(_ icon: LivingMapSDK.MapNotification.Icon) -> LivingMapSDK.MapNotification.Builder
    public func colour(_ colour: Swift.String) -> LivingMapSDK.MapNotification.Builder
    public func textColour(_ textColour: Swift.String) -> LivingMapSDK.MapNotification.Builder
    public func build(livingMapSDKManager: LivingMapSDK.LivingMapSDKManager) -> LivingMapSDK.MapNotification
    @objc deinit
  }
  @objc deinit
}
public func hang<T>(_ promise: LivingMapSDK.Promise<T>) throws -> T
public class AFSession {
  public var sessionWithAuth: LivingMapSDK.Session!
  public var sessionNoAuth: LivingMapSDK.Session!
  public init()
  public func createAFSession(credentials: LivingMapSDK.AuthenticationParameters, httpOriginValue: Swift.String) -> LivingMapSDK.Session
  public func generateRequest(url: Foundation.URL, method: Swift.String, contentType: Swift.String?, body: Foundation.Data?) -> Foundation.URLRequest
  @objc deinit
}
public class RoutingRequestMetadataOptions : Swift.Codable {
  public init(destinationAreaName: Swift.String?, destinationName: Swift.String?)
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public struct LMLivePositioningConfig : Swift.Codable {
  public var project: Swift.String
  public var environment: Swift.String
  public var positioningSystem: LivingMapSDK.PositioningSystem
  public var headingSystem: LivingMapSDK.HeadingSystem
  public var floorEstimationSystem: LivingMapSDK.FloorEstimationSystem
  public var diagnosticLoggingEnabled: Swift.Bool
  public var simulationFilePath: Foundation.URL?
  public var showMultipleLocations: Swift.Bool
  public var sensorUpdateFrequencies: LivingMapSDK.LMSensorUpdateFrequencies
  public var backgroundGathering: Swift.Bool
  public var lmLocationConfig: LivingMapSDK.LMLocationConfig
  public var cplLocationConfig: LivingMapSDK.CPLLocationConfig
  public var activityClassificationConfig: LivingMapSDK.LMActivityClassificationConfig
  public var stepConfig: LivingMapSDK.LMStepConfig
  public var calibrationConfig: LivingMapSDK.LMCalibrationConfig
  public var stepLength: Swift.Double
  public var gatewayAccuracy: Swift.Double
  public init(project: Swift.String, environment: Swift.String, positioningSystem: LivingMapSDK.PositioningSystem, headingSystem: LivingMapSDK.HeadingSystem = HeadingSystem.CoreLocationHeading, floorEstimationSystem: LivingMapSDK.FloorEstimationSystem = FloorEstimationSystem.CPLFloorEstimator, diagnosticLoggingEnabled: Swift.Bool = false, simulationFilePath: Foundation.URL? = nil, showMultipleLocations: Swift.Bool = false, sensorUpdateFrequencies: LivingMapSDK.LMSensorUpdateFrequencies = LMSensorUpdateFrequencies(), backgroundGathering: Swift.Bool = false, lmLocationConfig: LivingMapSDK.LMLocationConfig, cplLocationConfig: LivingMapSDK.CPLLocationConfig, activityClassificationConfig: LivingMapSDK.LMActivityClassificationConfig, stepConfig: LivingMapSDK.LMStepConfig = LMStepConfig(), calibrationConfig: LivingMapSDK.LMCalibrationConfig = LMCalibrationConfig(), stepLength: Swift.Double = 0.78, gatewayAccuracy: Swift.Double = 5.0)
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public enum PositioningSystem : Swift.String, Swift.Codable {
  case LMLocation
  case CoreLocation
  case LMCPLLocation
  case CoreCPLLocation
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum HeadingSystem : Swift.String, Swift.Codable {
  case CoreMotionHeading
  case CoreLocationHeading
  case CommonPositioningLibraryHeading
  case RegressionLinesHeading
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum FloorEstimationSystem : Swift.String, Swift.Codable {
  case CPLFloorEstimator
  case SDKFloorEstimator
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol URLConvertible {
  func asURL() throws -> Foundation.URL
}
extension Swift.String : LivingMapSDK.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URL : LivingMapSDK.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URLComponents : LivingMapSDK.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
public protocol URLRequestConvertible {
  func asURLRequest() throws -> Foundation.URLRequest
}
extension LivingMapSDK.URLRequestConvertible {
  public var urlRequest: Foundation.URLRequest? {
    get
  }
}
extension Foundation.URLRequest : LivingMapSDK.URLRequestConvertible {
  public func asURLRequest() throws -> Foundation.URLRequest
}
extension Foundation.URLRequest {
  public init(url: LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod, headers: LivingMapSDK.HTTPHeaders? = nil) throws
}
public enum LogEvent {
  case waitOnMainThread
  case pendingPromiseDeallocated
  case pendingGuaranteeDeallocated
  case cauterized(Swift.Error)
}
public struct LMLocationConfig : Swift.Codable {
  public var runtimeSignalUidMatchRatio: Swift.Float
  public var surveySignalUidMatchRatio: Swift.Float
  public init(runtimeSignalUidMatchRatio: Swift.Float = 0.15, surveySignalUidMatchRatio: Swift.Float = 0.15)
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class DebugInfo {
  public func setheading(_ heading: Swift.Double)
  public func setMeticsData(_ offset: Swift.Double, _ depletion: Swift.Double)
  public func setWalkingSpeedStatus(_ status: Swift.Bool)
  public func setPressureStatus(_ status: Swift.String)
  public func setAltitude(_ altitude: Swift.Double)
  public func setPressure(_ pressure: Swift.Double)
  public func setStepAttributes(_ step: LivingMapSDK.LMStep)
  public func setLocationAttributes(_ location: LivingMapSDK.LMLocation)
  public func getDebugInfoAsString() -> Swift.String
  @objc deinit
}
extension Foundation.URLRequest {
  public var method: LivingMapSDK.HTTPMethod? {
    get
    set(newValue)
  }
  public func validate() throws
}
public struct Checksums : Swift.Codable, Swift.Equatable {
  public static func == (lhs: LivingMapSDK.Checksums, rhs: LivingMapSDK.Checksums) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public typealias CustomEventAPICallback = (Foundation.NSDictionary?) -> Swift.Void
public protocol LivingMapMappingEvents : LivingMapSDK.LivingMapPositioningEvents {
  func mapReady()
  func mapClosed()
  func destinationReached()
}
extension UIKit.UIAlertController {
  @_Concurrency.MainActor(unsafe) public func show()
}
extension LivingMapSDK.CPLMetrics : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
public struct KalmanFilter<Type> : LivingMapSDK.KalmanFilterType where Type : LivingMapSDK.KalmanInput {
  public let stateEstimatePrior: Type
  public let errorCovariancePrior: Type
  public init(stateEstimatePrior: Type, errorCovariancePrior: Type)
  public func predict(stateTransitionModel: Type, controlInputModel: Type, controlVector: Type, covarianceOfProcessNoise: Type) -> LivingMapSDK.KalmanFilter<Type>
  public func update(measurement: Type, observationModel: Type, covarienceOfObservationNoise: Type) -> LivingMapSDK.KalmanFilter<Type>
  public typealias Input = Type
}
extension Foundation.URLSessionConfiguration : LivingMapSDK.AlamofireExtended {
  public typealias ExtendedType = Foundation.URLSessionConfiguration
}
extension LivingMapSDK.AlamofireExtension where ExtendedType : Foundation.URLSessionConfiguration {
  public static var `default`: Foundation.URLSessionConfiguration {
    get
  }
  public static var ephemeral: Foundation.URLSessionConfiguration {
    get
  }
}
public protocol LivingMapInterface : LivingMapSDK.LivingMapPositioningEvents {
  func pressureUpdated(pressure: Swift.String)
  func headingUpdated(heading: Swift.Double)
  func stepInfoUpdated(_ step: LivingMapSDK.LMStep)
}
extension LivingMapSDK.Request {
  public static var didResumeNotification: Foundation.Notification.Name
  public static var didSuspendNotification: Foundation.Notification.Name
  public static var didCancelNotification: Foundation.Notification.Name
  public static var didFinishNotification: Foundation.Notification.Name
  public static var didResumeTaskNotification: Foundation.Notification.Name
  public static var didSuspendTaskNotification: Foundation.Notification.Name
  public static var didCancelTaskNotification: Foundation.Notification.Name
  public static var didCompleteTaskNotification: Foundation.Notification.Name
}
extension Foundation.Notification {
  public var request: LivingMapSDK.Request? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class AlamofireNotifications : LivingMapSDK.EventMonitor {
  final public func requestDidResume(_ request: LivingMapSDK.Request)
  final public func requestDidSuspend(_ request: LivingMapSDK.Request)
  final public func requestDidCancel(_ request: LivingMapSDK.Request)
  final public func requestDidFinish(_ request: LivingMapSDK.Request)
  final public func request(_ request: LivingMapSDK.Request, didResumeTask task: Foundation.URLSessionTask)
  final public func request(_ request: LivingMapSDK.Request, didSuspendTask task: Foundation.URLSessionTask)
  final public func request(_ request: LivingMapSDK.Request, didCancelTask task: Foundation.URLSessionTask)
  final public func request(_ request: LivingMapSDK.Request, didCompleteTask task: Foundation.URLSessionTask, with error: LivingMapSDK.AFError?)
  @objc deinit
}
public typealias AFResult<Success> = Swift.Result<Success, LivingMapSDK.AFError>
public enum Model : Swift.String {
  case simulator
  case iPhone5
  case iPhone5S
  case iPhone6
  case iPhone6Plus
  case iPhone6S
  case iPhone6SPlus
  case iPhoneSE
  case iPhone7
  case iPhone7Plus
  case iPhone8
  case iPhone8Plus
  case iPhoneX
  case unrecognized
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor(unsafe) public var type: LivingMapSDK.Model {
    get
  }
}
public enum RoutingError : Swift.Error {
  case invalidFromOrToRouteLocation
  case deviceIsOffline
  public static func == (a: LivingMapSDK.RoutingError, b: LivingMapSDK.RoutingError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
open class RoutingController {
  public init(sdkManager: LivingMapSDK.LivingMapSDKManager)
  public func routingConnectivityStatus(connectivityStatus: LivingMapSDK.LivingMapConstants.ConnectivityStatus) -> Self
  public func from(location: LivingMapSDK.RouteLocation) -> Self
  public func to(location: LivingMapSDK.RouteLocation) -> Self
  public func via(location: LivingMapSDK.RouteLocation) -> Self
  public func route(options: LivingMapSDK.RoutingRequestMetadataOptions, callback: LivingMapSDK.CustomEventAPICallback? = nil) throws
  @objc deinit
}
public protocol OfflineCacheCallback {
  func onProgressUpdate(progress: Swift.Int)
  func onCachePrepareCompletion()
  func onCachePrepareFailure(error: LivingMapSDK.LivingMapError)
}
public struct LMStepConfig : Swift.Codable {
  public var readingsHistoryLength: Swift.Int
  public var deviationLowerThreshold: Swift.Double
  public var deviationUpperThreshold: Swift.Double
  public var standardDeviations: Swift.Double
  public var maxStepTimeInterval: Swift.Double
  public var minStepTimeInterval: Swift.Double
  public var stepTimeIntervalHistorySize: Swift.Int
  public var maxNumConsecutiveInjectedSteps: Swift.Int
  public var stoppedWalkingThreshold: Swift.Double
  public let intialStepCountToDrop: Swift.Int
  public init(readingsHistoryLength: Swift.Int = 50, deviationLowerThreshold: Swift.Double = 0.07, deviationUpperThreshold: Swift.Double = 0.50, standardDeviations: Swift.Double = 0.8, minStepTimeInterval: Swift.Double = 0.4, maxStepTimeInterval: Swift.Double = 2, stepTimeIntervalHistorySize: Swift.Int = 20, maxNumConsecutiveInjectedSteps: Swift.Int = 2, stoppedWalkingThreshold: Swift.Double = 3.0, intialStepCountToDrop: Swift.Int = 3)
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers final public class Resolver<T> {
  @objc deinit
}
extension LivingMapSDK.Resolver {
  final public func fulfill(_ value: T)
  final public func reject(_ error: Swift.Error)
  final public func resolve(_ result: LivingMapSDK.Result<T>)
  final public func resolve(_ obj: T?, _ error: Swift.Error?)
  final public func resolve(_ obj: T, _ error: Swift.Error?)
  final public func resolve(_ error: Swift.Error?, _ obj: T?)
}
extension LivingMapSDK.Resolver where T == Swift.Void {
  final public func resolve(_ error: Swift.Error?)
  final public func fulfill_()
}
extension LivingMapSDK.Resolver {
  final public func resolve<E>(_ result: Swift.Result<T, E>) where E : Swift.Error
}
public enum Result<T> {
  case fulfilled(T)
  case rejected(Swift.Error)
}
extension LivingMapSDK.Result {
  public var isFulfilled: Swift.Bool {
    get
  }
}
extension LivingMapSDK.Request {
  public typealias ValidationResult = Swift.Result<Swift.Void, Swift.Error>
}
extension LivingMapSDK.DataRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?) -> LivingMapSDK.DataRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension LivingMapSDK.DataStreamRequest {
  public typealias Validation = (_ request: Foundation.URLRequest?, _ response: Foundation.HTTPURLResponse) -> LivingMapSDK.DataStreamRequest.ValidationResult
  @discardableResult
  final public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  final public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  final public func validate() -> Self
}
extension LivingMapSDK.DownloadRequest {
  public typealias Validation = (_ request: Foundation.URLRequest?, _ response: Foundation.HTTPURLResponse, _ fileURL: Foundation.URL?) -> LivingMapSDK.DownloadRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
@_hasMissingDesignatedInitializers public class LivePositioningManager {
  public func startUpdating()
  public func stopUpdating()
  public func add(LivingMapInterface interface: LivingMapSDK.LivingMapInterface)
  public func add(LocationSubscription listener: LivingMapSDK.LivingMapLocationListener)
  public func add(debugModeListener listener: LivingMapSDK.DebugModeListener)
  public func remove(LivingMapInterface interface: LivingMapSDK.LivingMapInterface)
  public func remove(LocationSubscription listener: LivingMapSDK.LivingMapLocationListener)
  public func remove(debugModeListener listener: LivingMapSDK.DebugModeListener)
  public func set(location newLocation: LivingMapSDK.LMLocation) -> Swift.Bool
  @objc deinit
}
extension LivingMapSDK.LivePositioningManager {
  public func onLocationUpdate(associatedLocations: [LivingMapSDK.LMLocation])
}
public enum LMLogLevel : Swift.Int, Swift.CaseIterable {
  case debug
  case info
  case event
  case warning
  case error
  case exception
  case none
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [LivingMapSDK.LMLogLevel]
  public typealias RawValue = Swift.Int
  public static var allCases: [LivingMapSDK.LMLogLevel] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
public protocol LMLogConfigurationProtocol {
  var logLevel: LivingMapSDK.LMLogLevel { get }
  var filter: ((Swift.String) -> (Swift.Bool))? { get }
  var display: [LivingMapSDK.LMLogLevel : LivingMapSDK.LMLogLevelDisplay] { get }
}
public enum LMLogLevelDisplay {
  case all(console: Swift.Bool? = true, timestamp: Swift.Bool? = true, filename: Swift.Bool? = true, function: Swift.Bool? = true, line: Swift.Bool? = true)
  case debug(console: Swift.Bool? = true, timestamp: Swift.Bool? = true, filename: Swift.Bool? = true, function: Swift.Bool? = true, line: Swift.Bool? = true)
  case info(console: Swift.Bool? = true, timestamp: Swift.Bool? = true, filename: Swift.Bool? = false, function: Swift.Bool? = false, line: Swift.Bool? = false)
  case event(console: Swift.Bool? = true, timestamp: Swift.Bool? = true, filename: Swift.Bool? = true, function: Swift.Bool? = true, line: Swift.Bool? = true)
  case warning(console: Swift.Bool? = true, timestamp: Swift.Bool? = true, filename: Swift.Bool? = true, function: Swift.Bool? = true, line: Swift.Bool? = true)
  case error(console: Swift.Bool? = true, timestamp: Swift.Bool? = true, filename: Swift.Bool? = true, function: Swift.Bool? = true, line: Swift.Bool? = true)
  case exception(console: Swift.Bool? = true, timestamp: Swift.Bool? = true, filename: Swift.Bool? = true, function: Swift.Bool? = true, line: Swift.Bool? = true)
}
public struct LMLogConfig : LivingMapSDK.LMLogConfigurationProtocol {
  public var logLevel: LivingMapSDK.LMLogLevel
  public var filter: ((Swift.String) -> (Swift.Bool))?
  public var display: [LivingMapSDK.LMLogLevel : LivingMapSDK.LMLogLevelDisplay]
  public init(logLevel: LivingMapSDK.LMLogLevel = .none, filter: ((Swift.String) -> (Swift.Bool))? = nil, display: LivingMapSDK.LMLogLevelDisplay...)
}
@_hasMissingDesignatedInitializers public class log {
  public static func Debug(_ message: Any..., force: Swift.Bool = false, callingFunctionName: Swift.String = #function, _ lineNumber: Swift.UInt = #line, _ fileName: Swift.String = #file)
  public static func Info(_ message: Any..., force: Swift.Bool = false, callingFunctionName: Swift.String = #function, _ lineNumber: Swift.UInt = #line, _ fileName: Swift.String = #file)
  public static func Event(_ message: Any..., force: Swift.Bool = false, callingFunctionName: Swift.String = #function, _ lineNumber: Swift.UInt = #line, _ fileName: Swift.String = #file)
  public static func Warning(_ message: Any..., force: Swift.Bool = false, callingFunctionName: Swift.String = #function, _ lineNumber: Swift.UInt = #line, _ fileName: Swift.String = #file)
  public static func Error(_ message: Any..., force: Swift.Bool = false, callingFunctionName: Swift.String = #function, _ lineNumber: Swift.UInt = #line, _ fileName: Swift.String = #file)
  public static func Exception(_ message: Any..., force: Swift.Bool = false, callingFunctionName: Swift.String = #function, _ lineNumber: Swift.UInt = #line, _ fileName: Swift.String = #file)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class LMLogger {
  public static var shared: LivingMapSDK.LMLogger
  public var configuration: LivingMapSDK.LMLogConfigurationProtocol
  @objc deinit
}
public struct CPLLocationConfig : Swift.Codable {
  public var lowerBoundWaitingToUploadData: Swift.Double
  public var timeIntervalBufferSensorData: Swift.Double
  public var syncTimeInterval: Swift.Double
  public var injectLikelihood: Swift.Int
  public var assistingLocationMaxAge: Swift.Double
  public var cplRunConfigFilePath: Swift.String
  public init(lowerBoundWaitingToUploadData: Swift.Double = 0.3, timeIntervalBufferSensorData: Swift.Double = 1.0, syncTimeInterval: Swift.Double = 0.02, injectLikelihood: Swift.Int = 20, assistingLocationMaxAge: Swift.Double = 10.0, cplRunConfigFilePath: Swift.String)
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers final public class Promise<T> : LivingMapSDK.Thenable, LivingMapSDK.CatchMixin {
  public static func value(_ value: T) -> LivingMapSDK.Promise<T>
  public init(error: Swift.Error)
  public init<U>(_ bridge: U) where T == U.T, U : LivingMapSDK.Thenable
  public init(resolver body: (LivingMapSDK.Resolver<T>) throws -> Swift.Void)
  final public class func pending() -> (promise: LivingMapSDK.Promise<T>, resolver: LivingMapSDK.Resolver<T>)
  final public func pipe(to: @escaping (LivingMapSDK.Result<T>) -> Swift.Void)
  final public var result: LivingMapSDK.Result<T>? {
    get
  }
  @objc deinit
}
extension LivingMapSDK.Promise {
  final public func wait() throws -> T
}
extension LivingMapSDK.Promise where T == Swift.Void {
  public convenience init()
  public static var value: LivingMapSDK.Promise<Swift.Void> {
    get
  }
}
extension Dispatch.DispatchQueue {
  @available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *)
  final public func async<T>(_: LivingMapSDK.PMKNamespacer, group: Dispatch.DispatchGroup? = nil, qos: Dispatch.DispatchQoS = .default, flags: Dispatch.DispatchWorkItemFlags = [], execute body: @escaping () throws -> T) -> LivingMapSDK.Promise<T>
}
public enum PMKNamespacer {
  case promise
  public static func == (a: LivingMapSDK.PMKNamespacer, b: LivingMapSDK.PMKNamespacer) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
open class MultipartFormData {
  public static var encodingMemoryThreshold: Swift.UInt64
  open var contentType: Swift.String {
    get
    set(value)
  }
  public var contentLength: Swift.UInt64 {
    get
  }
  final public let boundary: Swift.String
  public init(fileManager: Foundation.FileManager = .default, boundary: Swift.String? = nil)
  public func append(_ data: Foundation.Data, withName name: Swift.String, fileName: Swift.String? = nil, mimeType: Swift.String? = nil)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, headers: LivingMapSDK.HTTPHeaders)
  public func encode() throws -> Foundation.Data
  public func writeEncodedData(to fileURL: Foundation.URL) throws
  @objc deinit
}
public func after(seconds: Foundation.TimeInterval) -> LivingMapSDK.Guarantee<Swift.Void>
public func after(_ interval: Dispatch.DispatchTimeInterval) -> LivingMapSDK.Guarantee<Swift.Void>
public enum MapView : Swift.String {
  case ROUTING
  case MAP
  case NAVIGATION
  case DOWNLOADING_MAP
  case MAP_DOWNLOAD_FAILED
  case NO_INTERNET_CONNECTION
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum CacheProgress : Swift.String {
  case GETTING_CACHE_MANIFEST
  case GETTING_CACHE_CHECKSUMS
  case GETTING_CACHE_PACKS
  case DECOMPRESSING_CACHE_PACKS
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public class LivingMapSDKMCacheManager {
  final public let monitor: LivingMapSDK.ConnectivityMonitor
  public init(authenticationParameters: LivingMapSDK.AuthenticationParameters, monitor: LivingMapSDK.ConnectivityMonitor? = nil)
  public func initialiseCache(manifestURL: Swift.String, key: [Swift.String : Swift.String], manifestCallbacks: LivingMapSDK.ManifestCallbacks)
  public func retrieveCacheManifest(manifestURL: Swift.String, key: [Swift.String : Swift.String], manifestCallback: LivingMapSDK.ManifestCallbacks)
  public func getCachedManifests() -> [LivingMapSDK.CacheManifest]
  @discardableResult
  public class func clearOfflineAssets(subDirectory: Swift.String? = nil) -> Swift.Bool
  @discardableResult
  public func clearOfflineAssets(subDirectory: Swift.String? = nil) -> Swift.Bool
  public func retrieveManifestFromCache(key: [Swift.String : Swift.String]) throws -> LivingMapSDK.CacheManifest?
  public func deleteManifestFromCache(key: [Swift.String : Swift.String], subDirectory: Swift.String) throws
  public func updateLocalCacheManifest(cacheManifest: LivingMapSDK.CacheManifest) throws
  @objc deinit
}
extension LivingMapSDK.Promise : Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
}
extension LivingMapSDK.Promise : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
public protocol RedirectHandler {
  func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct Redirector {
  public enum Behavior {
    case follow
    case doNotFollow
    case modify((Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?)
  }
  public static var follow: LivingMapSDK.Redirector
  public static var doNotFollow: LivingMapSDK.Redirector
  public let behavior: LivingMapSDK.Redirector.Behavior
  public init(behavior: LivingMapSDK.Redirector.Behavior)
}
extension LivingMapSDK.Redirector : LivingMapSDK.RedirectHandler {
  public func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
extension LivingMapSDK.RedirectHandler where Self == LivingMapSDK.Redirector {
  public static var follow: LivingMapSDK.Redirector {
    get
  }
  public static var doNotFollow: LivingMapSDK.Redirector {
    get
  }
  public static func modify(using closure: @escaping (Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?) -> LivingMapSDK.Redirector
}
public func download(fileURL: Foundation.URL, fallbackRequest: Foundation.URLRequest, handler: @escaping ((Foundation.HTTPURLResponse?, Foundation.Data?) -> Swift.Void)) -> LivingMapSDK.Request?
public func download(request: Foundation.URLRequest, handler: @escaping ((Foundation.HTTPURLResponse?, Foundation.Data?) -> Swift.Void)) -> LivingMapSDK.Request?
@_hasMissingDesignatedInitializers open class LivingMapConstants {
  public static var HTTP_PROTOCOL: Swift.String
  public static var URL_SCHEME: Swift.String
  public static var HTTP_ORIGIN_KEY: Swift.String
  public static var HTTP_ORIGIN_VALUE_TEMPLATE: Swift.String
  public static var URL_SCHEME_FORMATTED: Swift.String
  public static var SLASH: Swift.String
  public static var SCREEN_MODE: Swift.String
  public static var MOBILESDK: Swift.String
  public static var DISABLE_WEBVIEW_GEOLOCATION: Swift.String
  public static var URL_VIEW_VALUE: Swift.String
  @_hasMissingDesignatedInitializers open class MapStyles {
    public static var DEFAULT: Swift.String
    public static var AUTISM: Swift.String
    public static var DYSLEXIA: Swift.String
    public static var HIGH_CONTRAST: Swift.String
    public static var HIGH_CONTRAST_1_25x: Swift.String
    public static var HIGH_CONTRAST_1_5x: Swift.String
    @objc deinit
  }
  public static var OFFLINE_STORAGE_DIRNAME: Swift.String
  public static var OFFLINE_MAPURL_SCHEME: Swift.String
  public static var CACHE_ENDPOINT: Swift.String
  public static var FLOOR_HEIGHTS_FILE: Swift.String
  public static var FLOOR_MAPPING_FILE: Swift.String
  public static var GATEWAY_POINTS_FILE: Swift.String
  public static var POSITIONING_ASSETS_ROOT_DIRECTORY: Swift.String
  public static var GRIDS_CACHE_DIRECTORY: Swift.String
  public static var JSON_ASSETS_CACHE_DIRECTORY: Swift.String
  public static var MAG_FILE: Swift.String
  public static var BEACON_FILE: Swift.String
  public enum ConnectivityStatus : Swift.String {
    case ONLINE
    case OFFLINE
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public static var EXTRAS_POSITIONING_AVAILABLE_KEY: Swift.String
  public static var KEYCLOAK_URL: Swift.String
  public static var KEYCLOAK_LOGIN: Swift.String
  @objc deinit
}
public protocol ParameterEncoder {
  func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
}
open class JSONParameterEncoder : LivingMapSDK.ParameterEncoder {
  public static var `default`: LivingMapSDK.JSONParameterEncoder {
    get
  }
  public static var prettyPrinted: LivingMapSDK.JSONParameterEncoder {
    get
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var sortedKeys: LivingMapSDK.JSONParameterEncoder {
    get
  }
  final public let encoder: Foundation.JSONEncoder
  public init(encoder: Foundation.JSONEncoder = JSONEncoder())
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  @objc deinit
}
extension LivingMapSDK.ParameterEncoder where Self == LivingMapSDK.JSONParameterEncoder {
  public static var json: LivingMapSDK.JSONParameterEncoder {
    get
  }
  public static func json(encoder: Foundation.JSONEncoder = JSONEncoder()) -> LivingMapSDK.JSONParameterEncoder
}
open class URLEncodedFormParameterEncoder : LivingMapSDK.ParameterEncoder {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: LivingMapSDK.URLEncodedFormParameterEncoder.Destination, b: LivingMapSDK.URLEncodedFormParameterEncoder.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: LivingMapSDK.URLEncodedFormParameterEncoder {
    get
  }
  final public let encoder: LivingMapSDK.URLEncodedFormEncoder
  final public let destination: LivingMapSDK.URLEncodedFormParameterEncoder.Destination
  public init(encoder: LivingMapSDK.URLEncodedFormEncoder = URLEncodedFormEncoder(), destination: LivingMapSDK.URLEncodedFormParameterEncoder.Destination = .methodDependent)
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  @objc deinit
}
extension LivingMapSDK.ParameterEncoder where Self == LivingMapSDK.URLEncodedFormParameterEncoder {
  public static var urlEncodedForm: LivingMapSDK.URLEncodedFormParameterEncoder {
    get
  }
  public static func urlEncodedForm(encoder: LivingMapSDK.URLEncodedFormEncoder = URLEncodedFormEncoder(), destination: LivingMapSDK.URLEncodedFormParameterEncoder.Destination = .methodDependent) -> LivingMapSDK.URLEncodedFormParameterEncoder
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DataResponsePublisher<Value> : Combine.Publisher {
  public typealias Output = LivingMapSDK.DataResponse<Value, LivingMapSDK.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: LivingMapSDK.DataRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : LivingMapSDK.ResponseSerializer
  public init<Serializer>(_ request: LivingMapSDK.DataRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : LivingMapSDK.DataResponseSerializerProtocol
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, LivingMapSDK.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, LivingMapSDK.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == LivingMapSDK.DataResponsePublisher<Value>.Failure, S.Input == LivingMapSDK.DataResponsePublisher<Value>.Output
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
extension LivingMapSDK.DataResponsePublisher where Value == Foundation.Data? {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init(_ request: LivingMapSDK.DataRequest, queue: Dispatch.DispatchQueue)
}
extension LivingMapSDK.DataRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> LivingMapSDK.DataResponsePublisher<T> where Serializer : LivingMapSDK.ResponseSerializer, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishData(queue: Dispatch.DispatchQueue = .main, preprocessor: LivingMapSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> LivingMapSDK.DataResponsePublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishString(queue: Dispatch.DispatchQueue = .main, preprocessor: LivingMapSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> LivingMapSDK.DataResponsePublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  @available(*, deprecated, message: "Renamed publishDecodable(type:queue:preprocessor:decoder:emptyResponseCodes:emptyRequestMethods).")
  @_disfavoredOverload public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: LivingMapSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: LivingMapSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyResponseMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> LivingMapSDK.DataResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: LivingMapSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: LivingMapSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> LivingMapSDK.DataResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishUnserialized(queue: Dispatch.DispatchQueue = .main) -> LivingMapSDK.DataResponsePublisher<Foundation.Data?>
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DataStreamPublisher<Value> : Combine.Publisher {
  public typealias Output = LivingMapSDK.DataStreamRequest.Stream<Value, LivingMapSDK.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: LivingMapSDK.DataStreamRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : LivingMapSDK.DataStreamSerializer
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, LivingMapSDK.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, LivingMapSDK.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == LivingMapSDK.DataStreamPublisher<Value>.Failure, S.Input == LivingMapSDK.DataStreamPublisher<Value>.Output
}
extension LivingMapSDK.DataStreamRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> LivingMapSDK.DataStreamPublisher<Serializer.SerializedObject> where Serializer : LivingMapSDK.DataStreamSerializer
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishData(queue: Dispatch.DispatchQueue = .main) -> LivingMapSDK.DataStreamPublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishString(queue: Dispatch.DispatchQueue = .main) -> LivingMapSDK.DataStreamPublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, decoder: LivingMapSDK.DataDecoder = JSONDecoder(), preprocessor: LivingMapSDK.DataPreprocessor = PassthroughPreprocessor()) -> LivingMapSDK.DataStreamPublisher<T> where T : Swift.Decodable
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DownloadResponsePublisher<Value> : Combine.Publisher {
  public typealias Output = LivingMapSDK.DownloadResponse<Value, LivingMapSDK.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: LivingMapSDK.DownloadRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : LivingMapSDK.ResponseSerializer
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init<Serializer>(_ request: LivingMapSDK.DownloadRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : LivingMapSDK.DownloadResponseSerializerProtocol
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, LivingMapSDK.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, LivingMapSDK.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == LivingMapSDK.DownloadResponsePublisher<Value>.Failure, S.Input == LivingMapSDK.DownloadResponsePublisher<Value>.Output
}
extension LivingMapSDK.DownloadRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> LivingMapSDK.DownloadResponsePublisher<T> where Serializer : LivingMapSDK.ResponseSerializer, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> LivingMapSDK.DownloadResponsePublisher<T> where Serializer : LivingMapSDK.DownloadResponseSerializerProtocol, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishURL(queue: Dispatch.DispatchQueue = .main) -> LivingMapSDK.DownloadResponsePublisher<Foundation.URL>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishData(queue: Dispatch.DispatchQueue = .main, preprocessor: LivingMapSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> LivingMapSDK.DownloadResponsePublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishString(queue: Dispatch.DispatchQueue = .main, preprocessor: LivingMapSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> LivingMapSDK.DownloadResponsePublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  @available(*, deprecated, message: "Renamed publishDecodable(type:queue:preprocessor:decoder:emptyResponseCodes:emptyRequestMethods).")
  @_disfavoredOverload public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: LivingMapSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: LivingMapSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyResponseMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> LivingMapSDK.DownloadResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: LivingMapSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: LivingMapSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> LivingMapSDK.DownloadResponsePublisher<T> where T : Swift.Decodable
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
extension LivingMapSDK.DownloadResponsePublisher where Value == Foundation.URL? {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init(_ request: LivingMapSDK.DownloadRequest, queue: Dispatch.DispatchQueue)
}
extension LivingMapSDK.DownloadRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishUnserialized(on queue: Dispatch.DispatchQueue = .main) -> LivingMapSDK.DownloadResponsePublisher<Foundation.URL?>
}
public protocol Thenable : AnyObject {
  associatedtype T
  func pipe(to: @escaping (LivingMapSDK.Result<Self.T>) -> Swift.Void)
  var result: LivingMapSDK.Result<Self.T>? { get }
}
extension LivingMapSDK.Thenable {
  public func then<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (Self.T) throws -> U) -> LivingMapSDK.Promise<U.T> where U : LivingMapSDK.Thenable
  public func map<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (Self.T) throws -> U) -> LivingMapSDK.Promise<U>
  public func compactMap<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (Self.T) throws -> U?) -> LivingMapSDK.Promise<U>
  public func done(on: Dispatch.DispatchQueue? = conf.Q.return, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (Self.T) throws -> Swift.Void) -> LivingMapSDK.Promise<Swift.Void>
  public func get(on: Dispatch.DispatchQueue? = conf.Q.return, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (Self.T) throws -> Swift.Void) -> LivingMapSDK.Promise<Self.T>
  public func tap(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (LivingMapSDK.Result<Self.T>) -> Swift.Void) -> LivingMapSDK.Promise<Self.T>
  public func asVoid() -> LivingMapSDK.Promise<Swift.Void>
}
extension LivingMapSDK.Thenable {
  public var error: Swift.Error? {
    get
  }
  public var isPending: Swift.Bool {
    get
  }
  public var isResolved: Swift.Bool {
    get
  }
  public var isFulfilled: Swift.Bool {
    get
  }
  public var isRejected: Swift.Bool {
    get
  }
  public var value: Self.T? {
    get
  }
}
extension LivingMapSDK.Thenable where Self.T : Swift.Sequence {
  public func mapValues<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (Self.T.Iterator.Element) throws -> U) -> LivingMapSDK.Promise<[U]>
  public func flatMapValues<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (Self.T.Iterator.Element) throws -> U) -> LivingMapSDK.Promise<[U.Iterator.Element]> where U : Swift.Sequence
  public func compactMapValues<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (Self.T.Iterator.Element) throws -> U?) -> LivingMapSDK.Promise<[U]>
  public func thenMap<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (Self.T.Iterator.Element) throws -> U) -> LivingMapSDK.Promise<[U.T]> where U : LivingMapSDK.Thenable
  public func thenFlatMap<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (Self.T.Iterator.Element) throws -> U) -> LivingMapSDK.Promise<[U.T.Iterator.Element]> where U : LivingMapSDK.Thenable, U.T : Swift.Sequence
  public func filterValues(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ isIncluded: @escaping (Self.T.Iterator.Element) -> Swift.Bool) -> LivingMapSDK.Promise<[Self.T.Iterator.Element]>
}
extension LivingMapSDK.Thenable where Self.T : Swift.Collection {
  public var firstValue: LivingMapSDK.Promise<Self.T.Element> {
    get
  }
  public func firstValue(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, where test: @escaping (Self.T.Iterator.Element) -> Swift.Bool) -> LivingMapSDK.Promise<Self.T.Iterator.Element>
  public var lastValue: LivingMapSDK.Promise<Self.T.Element> {
    get
  }
}
extension LivingMapSDK.Thenable where Self.T : Swift.Sequence, Self.T.Element : Swift.Comparable {
  public func sortedValues(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil) -> LivingMapSDK.Promise<[Self.T.Iterator.Element]>
}
public typealias Parameters = [Swift.String : Any]
public protocol ParameterEncoding {
  func encode(_ urlRequest: LivingMapSDK.URLRequestConvertible, with parameters: LivingMapSDK.Parameters?) throws -> Foundation.URLRequest
}
public struct URLEncoding : LivingMapSDK.ParameterEncoding {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: LivingMapSDK.URLEncoding.Destination, b: LivingMapSDK.URLEncoding.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    case indexInBrackets
    public static func == (a: LivingMapSDK.URLEncoding.ArrayEncoding, b: LivingMapSDK.URLEncoding.ArrayEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: LivingMapSDK.URLEncoding.BoolEncoding, b: LivingMapSDK.URLEncoding.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: LivingMapSDK.URLEncoding {
    get
  }
  public static var queryString: LivingMapSDK.URLEncoding {
    get
  }
  public static var httpBody: LivingMapSDK.URLEncoding {
    get
  }
  public let destination: LivingMapSDK.URLEncoding.Destination
  public let arrayEncoding: LivingMapSDK.URLEncoding.ArrayEncoding
  public let boolEncoding: LivingMapSDK.URLEncoding.BoolEncoding
  public init(destination: LivingMapSDK.URLEncoding.Destination = .methodDependent, arrayEncoding: LivingMapSDK.URLEncoding.ArrayEncoding = .brackets, boolEncoding: LivingMapSDK.URLEncoding.BoolEncoding = .numeric)
  public func encode(_ urlRequest: LivingMapSDK.URLRequestConvertible, with parameters: LivingMapSDK.Parameters?) throws -> Foundation.URLRequest
  public func queryComponents(fromKey key: Swift.String, value: Any) -> [(Swift.String, Swift.String)]
  public func escape(_ string: Swift.String) -> Swift.String
}
public struct JSONEncoding : LivingMapSDK.ParameterEncoding {
  public static var `default`: LivingMapSDK.JSONEncoding {
    get
  }
  public static var prettyPrinted: LivingMapSDK.JSONEncoding {
    get
  }
  public let options: Foundation.JSONSerialization.WritingOptions
  public init(options: Foundation.JSONSerialization.WritingOptions = [])
  public func encode(_ urlRequest: LivingMapSDK.URLRequestConvertible, with parameters: LivingMapSDK.Parameters?) throws -> Foundation.URLRequest
  public func encode(_ urlRequest: LivingMapSDK.URLRequestConvertible, withJSONObject jsonObject: Any? = nil) throws -> Foundation.URLRequest
}
@objc @_inheritsConvenienceInitializers open class ConnectivityMonitor : ObjectiveC.NSObject {
  public func startMonitoring(livingMapEvents: LivingMapSDK.LivingMapPositioningEvents? = nil)
  open func isReachable() -> Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
public func firstly<U>(execute body: () throws -> U) -> LivingMapSDK.Promise<U.T> where U : LivingMapSDK.Thenable
public func firstly<T>(execute body: () -> LivingMapSDK.Guarantee<T>) -> LivingMapSDK.Guarantee<T>
public struct AlamofireExtension<ExtendedType> {
  public var type: ExtendedType {
    get
  }
  public init(_ type: ExtendedType)
}
public protocol AlamofireExtended {
  associatedtype ExtendedType
  static var af: LivingMapSDK.AlamofireExtension<Self.ExtendedType>.Type { get set }
  var af: LivingMapSDK.AlamofireExtension<Self.ExtendedType> { get set }
}
extension LivingMapSDK.AlamofireExtended {
  public static var af: LivingMapSDK.AlamofireExtension<Self>.Type {
    get
    set(newValue)
  }
  public var af: LivingMapSDK.AlamofireExtension<Self> {
    get
    set(newValue)
  }
}
public protocol LivingMapPositioningEvents : LivingMapSDK.LivingMapLocationListener {
  func customEvent(eventId: Swift.String, eventParameters: Foundation.NSArray)
  func errorReceived(error: LivingMapSDK.LivingMapError)
  func onConnectivityStatusChanged(connectivityStatus: LivingMapSDK.LivingMapConstants.ConnectivityStatus)
  func onLowCalibrationStatus(calibrationAlert: UIKit.UIAlertController)
}
open class Session {
  public static var `default`: LivingMapSDK.Session
  final public let session: Foundation.URLSession
  final public let delegate: LivingMapSDK.SessionDelegate
  final public let rootQueue: Dispatch.DispatchQueue
  final public let startRequestsImmediately: Swift.Bool
  final public let requestQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let interceptor: LivingMapSDK.RequestInterceptor?
  final public let serverTrustManager: LivingMapSDK.ServerTrustManager?
  final public let redirectHandler: LivingMapSDK.RedirectHandler?
  final public let cachedResponseHandler: LivingMapSDK.CachedResponseHandler?
  final public let eventMonitor: LivingMapSDK.CompositeEventMonitor
  final public let defaultEventMonitors: [LivingMapSDK.EventMonitor]
  public init(session: Foundation.URLSession, delegate: LivingMapSDK.SessionDelegate, rootQueue: Dispatch.DispatchQueue, startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: LivingMapSDK.RequestInterceptor? = nil, serverTrustManager: LivingMapSDK.ServerTrustManager? = nil, redirectHandler: LivingMapSDK.RedirectHandler? = nil, cachedResponseHandler: LivingMapSDK.CachedResponseHandler? = nil, eventMonitors: [LivingMapSDK.EventMonitor] = [])
  public convenience init(configuration: Foundation.URLSessionConfiguration = URLSessionConfiguration.af.default, delegate: LivingMapSDK.SessionDelegate = SessionDelegate(), rootQueue: Dispatch.DispatchQueue = DispatchQueue(label: "org.alamofire.session.rootQueue"), startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: LivingMapSDK.RequestInterceptor? = nil, serverTrustManager: LivingMapSDK.ServerTrustManager? = nil, redirectHandler: LivingMapSDK.RedirectHandler? = nil, cachedResponseHandler: LivingMapSDK.CachedResponseHandler? = nil, eventMonitors: [LivingMapSDK.EventMonitor] = [])
  @objc deinit
  public func withAllRequests(perform action: @escaping (Swift.Set<LivingMapSDK.Request>) -> Swift.Void)
  public func cancelAllRequests(completingOnQueue queue: Dispatch.DispatchQueue = .main, completion: (() -> Swift.Void)? = nil)
  public typealias RequestModifier = (inout Foundation.URLRequest) throws -> Swift.Void
  open func request(_ convertible: LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod = .get, parameters: LivingMapSDK.Parameters? = nil, encoding: LivingMapSDK.ParameterEncoding = URLEncoding.default, headers: LivingMapSDK.HTTPHeaders? = nil, interceptor: LivingMapSDK.RequestInterceptor? = nil, requestModifier: LivingMapSDK.Session.RequestModifier? = nil) -> LivingMapSDK.DataRequest
  open func request<Parameters>(_ convertible: LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod = .get, parameters: Parameters? = nil, encoder: LivingMapSDK.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: LivingMapSDK.HTTPHeaders? = nil, interceptor: LivingMapSDK.RequestInterceptor? = nil, requestModifier: LivingMapSDK.Session.RequestModifier? = nil) -> LivingMapSDK.DataRequest where Parameters : Swift.Encodable
  open func request(_ convertible: LivingMapSDK.URLRequestConvertible, interceptor: LivingMapSDK.RequestInterceptor? = nil) -> LivingMapSDK.DataRequest
  open func streamRequest<Parameters>(_ convertible: LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod = .get, parameters: Parameters? = nil, encoder: LivingMapSDK.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: LivingMapSDK.HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: LivingMapSDK.RequestInterceptor? = nil, requestModifier: LivingMapSDK.Session.RequestModifier? = nil) -> LivingMapSDK.DataStreamRequest where Parameters : Swift.Encodable
  open func streamRequest(_ convertible: LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod = .get, headers: LivingMapSDK.HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: LivingMapSDK.RequestInterceptor? = nil, requestModifier: LivingMapSDK.Session.RequestModifier? = nil) -> LivingMapSDK.DataStreamRequest
  open func streamRequest(_ convertible: LivingMapSDK.URLRequestConvertible, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: LivingMapSDK.RequestInterceptor? = nil) -> LivingMapSDK.DataStreamRequest
  open func download(_ convertible: LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod = .get, parameters: LivingMapSDK.Parameters? = nil, encoding: LivingMapSDK.ParameterEncoding = URLEncoding.default, headers: LivingMapSDK.HTTPHeaders? = nil, interceptor: LivingMapSDK.RequestInterceptor? = nil, requestModifier: LivingMapSDK.Session.RequestModifier? = nil, to destination: LivingMapSDK.DownloadRequest.Destination? = nil) -> LivingMapSDK.DownloadRequest
  open func download<Parameters>(_ convertible: LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod = .get, parameters: Parameters? = nil, encoder: LivingMapSDK.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: LivingMapSDK.HTTPHeaders? = nil, interceptor: LivingMapSDK.RequestInterceptor? = nil, requestModifier: LivingMapSDK.Session.RequestModifier? = nil, to destination: LivingMapSDK.DownloadRequest.Destination? = nil) -> LivingMapSDK.DownloadRequest where Parameters : Swift.Encodable
  open func download(_ convertible: LivingMapSDK.URLRequestConvertible, interceptor: LivingMapSDK.RequestInterceptor? = nil, to destination: LivingMapSDK.DownloadRequest.Destination? = nil) -> LivingMapSDK.DownloadRequest
  open func download(resumingWith data: Foundation.Data, interceptor: LivingMapSDK.RequestInterceptor? = nil, to destination: LivingMapSDK.DownloadRequest.Destination? = nil) -> LivingMapSDK.DownloadRequest
  open func upload(_ data: Foundation.Data, to convertible: LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod = .post, headers: LivingMapSDK.HTTPHeaders? = nil, interceptor: LivingMapSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: LivingMapSDK.Session.RequestModifier? = nil) -> LivingMapSDK.UploadRequest
  open func upload(_ data: Foundation.Data, with convertible: LivingMapSDK.URLRequestConvertible, interceptor: LivingMapSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> LivingMapSDK.UploadRequest
  open func upload(_ fileURL: Foundation.URL, to convertible: LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod = .post, headers: LivingMapSDK.HTTPHeaders? = nil, interceptor: LivingMapSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: LivingMapSDK.Session.RequestModifier? = nil) -> LivingMapSDK.UploadRequest
  open func upload(_ fileURL: Foundation.URL, with convertible: LivingMapSDK.URLRequestConvertible, interceptor: LivingMapSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> LivingMapSDK.UploadRequest
  open func upload(_ stream: Foundation.InputStream, to convertible: LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod = .post, headers: LivingMapSDK.HTTPHeaders? = nil, interceptor: LivingMapSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: LivingMapSDK.Session.RequestModifier? = nil) -> LivingMapSDK.UploadRequest
  open func upload(_ stream: Foundation.InputStream, with convertible: LivingMapSDK.URLRequestConvertible, interceptor: LivingMapSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> LivingMapSDK.UploadRequest
  open func upload(multipartFormData: @escaping (LivingMapSDK.MultipartFormData) -> Swift.Void, to url: LivingMapSDK.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, method: LivingMapSDK.HTTPMethod = .post, headers: LivingMapSDK.HTTPHeaders? = nil, interceptor: LivingMapSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: LivingMapSDK.Session.RequestModifier? = nil) -> LivingMapSDK.UploadRequest
  open func upload(multipartFormData: @escaping (LivingMapSDK.MultipartFormData) -> Swift.Void, with request: LivingMapSDK.URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, interceptor: LivingMapSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> LivingMapSDK.UploadRequest
  open func upload(multipartFormData: LivingMapSDK.MultipartFormData, to url: LivingMapSDK.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, method: LivingMapSDK.HTTPMethod = .post, headers: LivingMapSDK.HTTPHeaders? = nil, interceptor: LivingMapSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: LivingMapSDK.Session.RequestModifier? = nil) -> LivingMapSDK.UploadRequest
  open func upload(multipartFormData: LivingMapSDK.MultipartFormData, with request: LivingMapSDK.URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, interceptor: LivingMapSDK.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> LivingMapSDK.UploadRequest
}
extension LivingMapSDK.Session : LivingMapSDK.RequestDelegate {
  public var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
  }
  public var startImmediately: Swift.Bool {
    get
  }
  public func cleanup(after request: LivingMapSDK.Request)
  public func retryResult(for request: LivingMapSDK.Request, dueTo error: LivingMapSDK.AFError, completion: @escaping (LivingMapSDK.RetryResult) -> Swift.Void)
  public func retryRequest(_ request: LivingMapSDK.Request, withDelay timeDelay: Foundation.TimeInterval?)
}
public typealias StringMap = [Swift.String : Swift.String]
public typealias StringAnyMap = [Swift.String : LivingMapSDK.AnyCodable]
public struct CacheManifest {
  public var environment: Swift.String
  public var project: Swift.String
  public var urls: LivingMapSDK.Urls
  public var extras: LivingMapSDK.StringAnyMap?
  public var mapPackChecksums: LivingMapSDK.Checksums?
  public var gridPackChecksums: LivingMapSDK.Checksums?
  public var key: LivingMapSDK.StringMap?
  public var manifestUrl: Swift.String?
  public var outOfDate: Swift.Bool?
}
extension LivingMapSDK.CacheManifest : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension LivingMapSDK.CacheManifest : Swift.Equatable {
  public static func == (lhs: LivingMapSDK.CacheManifest, rhs: LivingMapSDK.CacheManifest) -> Swift.Bool
}
extension LivingMapSDK.CacheManifest {
  public init(_ json: Swift.String, using encoding: Swift.String.Encoding = .utf8) throws
  public init(fromURL url: Foundation.URL) throws
  public mutating func parseMappings()
  public func jsonData() throws -> Foundation.Data
  public func jsonString(encoding: Swift.String.Encoding = .utf8) throws -> Swift.String?
  public func getExtras() -> LivingMapSDK.StringAnyMap?
  public func positioningAvailable() -> Swift.Bool
  public func getExtraValue(value: Swift.String) -> Any?
}
public struct Urls : Swift.Codable, Swift.Equatable {
  public var map: Swift.String
  public static func == (a: LivingMapSDK.Urls, b: LivingMapSDK.Urls) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public func newJSONDecoder() -> Foundation.JSONDecoder
public func newJSONEncoder() -> Foundation.JSONEncoder
public class LivingMapSDKManager {
  public var mapVC: LivingMapSDK.LMWebViewController?
  public init()
  @discardableResult
  public func createMapComponent(mapConfig: LivingMapSDK.LivingMapConfig, cacheManifest: LivingMapSDK.CacheManifest) -> WebKit.WKWebView?
  public func initPositioningSystem(livePositioningConfig: LivingMapSDK.LMLivePositioningConfig, mapConfig: LivingMapSDK.LivingMapConfig, eventHandler: LivingMapSDK.LivingMapPositioningEvents, cacheManifest: LivingMapSDK.CacheManifest)
  public func deinitPositioningSystem()
  public func deinitMapComponent()
  public func startScanning()
  public func stopScanning()
  public func addLivingMapInterface(interface: LivingMapSDK.LivingMapInterface)
  public func removeLivingMapInterface(interface: LivingMapSDK.LivingMapInterface)
  public func requestLocationSubscription(listener: LivingMapSDK.LivingMapLocationListener)
  public func removeLocationSubscription(listener: LivingMapSDK.LivingMapLocationListener)
  public func add(debugModeListener listener: LivingMapSDK.DebugModeListener)
  public func remove(debugModeListener listener: LivingMapSDK.DebugModeListener)
  public func set(location newLocation: LivingMapSDK.LMLocation) -> Swift.Bool
  public func setDebugLayoutDisplay(showDebugLayout: Swift.Bool)
  public func isDebugging() -> Swift.Bool
  public func sendCommandToFrontEnd(command: Swift.String, completionHandler: @escaping (Any?, Swift.Error?) -> Swift.Void)
  public func sendCommandToFrontEnd(command: Swift.String, returnCallback: @escaping (Any?, Swift.Error?) -> Swift.Void, eventKeyCallbackListener: Swift.String, asyncCallback: @escaping (Foundation.NSArray) -> Swift.Void)
  public static func getVersion() -> Swift.String
  @objc deinit
}
extension LivingMapSDK.LivingMapSDKManager {
  public func fireCustomEvent(eventId: Swift.String, eventParameters: Foundation.NSArray)
  public func onMapReady()
  public func destinationReached()
}
public struct HTTPMethod : Swift.RawRepresentable, Swift.Equatable, Swift.Hashable {
  public static var connect: LivingMapSDK.HTTPMethod
  public static var delete: LivingMapSDK.HTTPMethod
  public static var get: LivingMapSDK.HTTPMethod
  public static var head: LivingMapSDK.HTTPMethod
  public static var options: LivingMapSDK.HTTPMethod
  public static var patch: LivingMapSDK.HTTPMethod
  public static var post: LivingMapSDK.HTTPMethod
  public static var put: LivingMapSDK.HTTPMethod
  public static var trace: LivingMapSDK.HTTPMethod
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
public protocol LivingMapLocationListener : AnyObject {
  func locationReceived(location: LivingMapSDK.LMLocation)
}
public protocol DebugModeListener : AnyObject {
  func locationReceived(associatedLocations: [LivingMapSDK.LMLocation])
  func onCPLMetricsUpdate(offset: Swift.Double, depletion: Swift.Double)
  func onAltitudeUpdate(altitude: Swift.Double, pressure: Swift.Double)
}
@frozen public struct AnyDecodable : Swift.Decodable {
  public let value: Any
  public init<T>(_ value: T?)
}
@usableFromInline
internal protocol _AnyDecodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
extension LivingMapSDK.AnyDecodable : LivingMapSDK._AnyDecodable {
}
extension LivingMapSDK._AnyDecodable {
  public init(from decoder: Swift.Decoder) throws
}
extension LivingMapSDK.AnyDecodable : Swift.Equatable {
  public static func == (lhs: LivingMapSDK.AnyDecodable, rhs: LivingMapSDK.AnyDecodable) -> Swift.Bool
}
extension LivingMapSDK.AnyDecodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LivingMapSDK.AnyDecodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Guarantee<T> : LivingMapSDK.Thenable {
  public static func value(_ value: T) -> LivingMapSDK.Guarantee<T>
  public init(resolver body: (@escaping (T) -> Swift.Void) -> Swift.Void)
  final public func pipe(to: @escaping (LivingMapSDK.Result<T>) -> Swift.Void)
  final public var result: LivingMapSDK.Result<T>? {
    get
  }
  final public class func pending() -> (guarantee: LivingMapSDK.Guarantee<T>, resolve: (T) -> Swift.Void)
  @objc deinit
}
extension LivingMapSDK.Guarantee {
  @discardableResult
  final public func done(on: Dispatch.DispatchQueue? = conf.Q.return, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (T) -> Swift.Void) -> LivingMapSDK.Guarantee<Swift.Void>
  final public func get(on: Dispatch.DispatchQueue? = conf.Q.return, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (T) -> Swift.Void) -> LivingMapSDK.Guarantee<T>
  final public func map<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (T) -> U) -> LivingMapSDK.Guarantee<U>
  @discardableResult
  final public func then<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (T) -> LivingMapSDK.Guarantee<U>) -> LivingMapSDK.Guarantee<U>
  final public func asVoid() -> LivingMapSDK.Guarantee<Swift.Void>
  final public func wait() -> T
}
extension LivingMapSDK.Guarantee where T : Swift.Sequence {
  final public func mapValues<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (T.Iterator.Element) -> U) -> LivingMapSDK.Guarantee<[U]>
  final public func flatMapValues<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (T.Iterator.Element) -> U) -> LivingMapSDK.Guarantee<[U.Iterator.Element]> where U : Swift.Sequence
  final public func compactMapValues<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (T.Iterator.Element) -> U?) -> LivingMapSDK.Guarantee<[U]>
  final public func thenMap<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (T.Iterator.Element) -> LivingMapSDK.Guarantee<U>) -> LivingMapSDK.Guarantee<[U]>
  final public func thenFlatMap<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (T.Iterator.Element) -> U) -> LivingMapSDK.Guarantee<[U.T.Iterator.Element]> where U : LivingMapSDK.Thenable, U.T : Swift.Sequence
  final public func filterValues(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ isIncluded: @escaping (T.Iterator.Element) -> Swift.Bool) -> LivingMapSDK.Guarantee<[T.Iterator.Element]>
  final public func sortedValues(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ areInIncreasingOrder: @escaping (T.Iterator.Element, T.Iterator.Element) -> Swift.Bool) -> LivingMapSDK.Guarantee<[T.Iterator.Element]>
}
extension LivingMapSDK.Guarantee where T : Swift.Sequence, T.Element : Swift.Comparable {
  final public func sortedValues(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil) -> LivingMapSDK.Guarantee<[T.Iterator.Element]>
}
extension LivingMapSDK.Guarantee where T == Swift.Void {
  public convenience init()
  public static var value: LivingMapSDK.Guarantee<Swift.Void> {
    get
  }
}
extension Dispatch.DispatchQueue {
  @available(macOS 10.10, iOS 2.0, tvOS 10.0, watchOS 2.0, *)
  final public func async<T>(_: LivingMapSDK.PMKNamespacer, group: Dispatch.DispatchGroup? = nil, qos: Dispatch.DispatchQoS = .default, flags: Dispatch.DispatchWorkItemFlags = [], execute body: @escaping () -> T) -> LivingMapSDK.Guarantee<T>
}
final public class URLEncodedFormEncoder {
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    case indexInBrackets
    public static func == (a: LivingMapSDK.URLEncodedFormEncoder.ArrayEncoding, b: LivingMapSDK.URLEncodedFormEncoder.ArrayEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: LivingMapSDK.URLEncodedFormEncoder.BoolEncoding, b: LivingMapSDK.URLEncodedFormEncoder.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum DataEncoding {
    case deferredToData
    case base64
    case custom((Foundation.Data) throws -> Swift.String)
  }
  public enum DateEncoding {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    case iso8601
    case formatted(Foundation.DateFormatter)
    case custom((Foundation.Date) throws -> Swift.String)
  }
  public enum KeyEncoding {
    case useDefaultKeys
    case convertToSnakeCase
    case convertToKebabCase
    case capitalized
    case uppercased
    case lowercased
    case custom((Swift.String) -> Swift.String)
  }
  public enum SpaceEncoding {
    case percentEscaped
    case plusReplaced
    public static func == (a: LivingMapSDK.URLEncodedFormEncoder.SpaceEncoding, b: LivingMapSDK.URLEncodedFormEncoder.SpaceEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Error : Swift.Error {
    case invalidRootObject(Swift.String)
  }
  final public let alphabetizeKeyValuePairs: Swift.Bool
  final public let arrayEncoding: LivingMapSDK.URLEncodedFormEncoder.ArrayEncoding
  final public let boolEncoding: LivingMapSDK.URLEncodedFormEncoder.BoolEncoding
  final public let dataEncoding: LivingMapSDK.URLEncodedFormEncoder.DataEncoding
  final public let dateEncoding: LivingMapSDK.URLEncodedFormEncoder.DateEncoding
  final public let keyEncoding: LivingMapSDK.URLEncodedFormEncoder.KeyEncoding
  final public let spaceEncoding: LivingMapSDK.URLEncodedFormEncoder.SpaceEncoding
  final public var allowedCharacters: Foundation.CharacterSet
  public init(alphabetizeKeyValuePairs: Swift.Bool = true, arrayEncoding: LivingMapSDK.URLEncodedFormEncoder.ArrayEncoding = .brackets, boolEncoding: LivingMapSDK.URLEncodedFormEncoder.BoolEncoding = .numeric, dataEncoding: LivingMapSDK.URLEncodedFormEncoder.DataEncoding = .base64, dateEncoding: LivingMapSDK.URLEncodedFormEncoder.DateEncoding = .deferredToDate, keyEncoding: LivingMapSDK.URLEncodedFormEncoder.KeyEncoding = .useDefaultKeys, spaceEncoding: LivingMapSDK.URLEncodedFormEncoder.SpaceEncoding = .percentEscaped, allowedCharacters: Foundation.CharacterSet = .afURLQueryAllowed)
  final public func encode(_ value: Swift.Encodable) throws -> Swift.String
  final public func encode(_ value: Swift.Encodable) throws -> Foundation.Data
  @objc deinit
}
extension Foundation.CharacterSet {
  public static var afURLQueryAllowed: Foundation.CharacterSet
}
public protocol KalmanInput {
  var transposed: Self { get }
  var inversed: Self { get }
  var additionToUnit: Self { get }
  static func + (lhs: Self, rhs: Self) -> Self
  static func - (lhs: Self, rhs: Self) -> Self
  static func * (lhs: Self, rhs: Self) -> Self
}
public protocol KalmanFilterType {
  associatedtype Input : LivingMapSDK.KalmanInput
  var stateEstimatePrior: Self.Input { get }
  var errorCovariancePrior: Self.Input { get }
  func predict(stateTransitionModel: Self.Input, controlInputModel: Self.Input, controlVector: Self.Input, covarianceOfProcessNoise: Self.Input) -> Self
  func update(measurement: Self.Input, observationModel: Self.Input, covarienceOfObservationNoise: Self.Input) -> Self
}
public class Coordinate : Swift.Codable {
  public init(lat: Swift.Double, lon: Swift.Double, floorId: Swift.Int)
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public class RouteLocation : Swift.Codable {
  public init(coordinate: LivingMapSDK.Coordinate?, gid: Swift.Int? = nil, type: Swift.String? = nil)
  public init(name: Swift.String)
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public class AuthenticationParameters : Swift.Codable {
  final public let environment: Swift.String
  final public let clientId: Swift.String
  final public let clientSecret: Swift.String
  public init(environment: Swift.String = "prod", clientId: Swift.String, clientSecret: Swift.String)
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
@frozen public struct AnyEncodable : Swift.Encodable {
  public let value: Any
  public init<T>(_ value: T?)
}
@usableFromInline
internal protocol _AnyEncodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
extension LivingMapSDK.AnyEncodable : LivingMapSDK._AnyEncodable {
}
extension LivingMapSDK._AnyEncodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension LivingMapSDK.AnyEncodable : Swift.Equatable {
  public static func == (lhs: LivingMapSDK.AnyEncodable, rhs: LivingMapSDK.AnyEncodable) -> Swift.Bool
}
extension LivingMapSDK.AnyEncodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LivingMapSDK.AnyEncodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension LivingMapSDK.AnyEncodable : Swift.ExpressibleByNilLiteral {
}
extension LivingMapSDK.AnyEncodable : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
}
extension LivingMapSDK.AnyEncodable : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
}
extension LivingMapSDK.AnyEncodable : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
}
extension LivingMapSDK.AnyEncodable : Swift.ExpressibleByStringLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension LivingMapSDK.AnyEncodable : Swift.ExpressibleByStringInterpolation {
  public typealias StringInterpolation = Swift.DefaultStringInterpolation
}
extension LivingMapSDK.AnyEncodable : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Any
}
extension LivingMapSDK.AnyEncodable : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.AnyHashable
  public typealias Value = Any
}
extension LivingMapSDK._AnyEncodable {
  public init(nilLiteral _: ())
  public init(booleanLiteral value: Swift.Bool)
  public init(integerLiteral value: Swift.Int)
  public init(floatLiteral value: Swift.Double)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.String)
  public init(arrayLiteral elements: Any...)
  public init(dictionaryLiteral elements: (Swift.AnyHashable, Any)...)
}
public protocol AuthenticationCredential {
  var requiresRefresh: Swift.Bool { get }
}
public protocol Authenticator : AnyObject {
  associatedtype Credential : LivingMapSDK.AuthenticationCredential
  func apply(_ credential: Self.Credential, to urlRequest: inout Foundation.URLRequest)
  func refresh(_ credential: Self.Credential, for session: LivingMapSDK.Session, completion: @escaping (Swift.Result<Self.Credential, Swift.Error>) -> Swift.Void)
  func didRequest(_ urlRequest: Foundation.URLRequest, with response: Foundation.HTTPURLResponse, failDueToAuthenticationError error: Swift.Error) -> Swift.Bool
  func isRequest(_ urlRequest: Foundation.URLRequest, authenticatedWith credential: Self.Credential) -> Swift.Bool
}
public enum AuthenticationError : Swift.Error {
  case missingCredential
  case excessiveRefresh
  public static func == (a: LivingMapSDK.AuthenticationError, b: LivingMapSDK.AuthenticationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class AuthenticationInterceptor<AuthenticatorType> : LivingMapSDK.RequestInterceptor where AuthenticatorType : LivingMapSDK.Authenticator {
  public typealias Credential = AuthenticatorType.Credential
  public struct RefreshWindow {
    public let interval: Foundation.TimeInterval
    public let maximumAttempts: Swift.Int
    public init(interval: Foundation.TimeInterval = 30.0, maximumAttempts: Swift.Int = 5)
  }
  public var credential: LivingMapSDK.AuthenticationInterceptor<AuthenticatorType>.Credential? {
    get
    set(newValue)
  }
  public init(authenticator: AuthenticatorType, credential: LivingMapSDK.AuthenticationInterceptor<AuthenticatorType>.Credential? = nil, refreshWindow: LivingMapSDK.AuthenticationInterceptor<AuthenticatorType>.RefreshWindow? = RefreshWindow())
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: LivingMapSDK.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  public func retry(_ request: LivingMapSDK.Request, for session: LivingMapSDK.Session, dueTo error: Swift.Error, completion: @escaping (LivingMapSDK.RetryResult) -> Swift.Void)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class LMStep : Swift.Codable {
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public struct LMCalibrationConfig : Swift.Codable {
  public var magneticFieldUpperThreshold: Swift.Double
  public var magneticFieldLowerThreshold: Swift.Double
  public var calibrationPromptTimeThreshold: Swift.Double
  public var magReadingsCheckThreshold: Swift.Double
  public init(magneticFieldUpperThreshould: Swift.Double = 80.0, magneticFieldLowerThreshould: Swift.Double = 25.0, calibrationIntervaleThreshould: Swift.Double = 10.0, magReadingsCheckThreshold: Swift.Double = 1.0)
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct CacheCommunicationCallbacks {
}
public class CacheCommunication {
  public init(credentials: LivingMapSDK.AuthenticationParameters, httpOriginValue: Swift.String, endpoint: Foundation.URL)
  public func getPack(typeAndProject: Swift.String, callbacks: LivingMapSDK.CacheCommunicationCallbacks)
  public func getChecksums(path: Swift.String, callbacks: LivingMapSDK.CacheCommunicationCallbacks)
  public func getManifest(path: Swift.String, callbacks: LivingMapSDK.CacheCommunicationCallbacks)
  @objc deinit
}
public protocol CachedResponseHandler {
  func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
public struct ResponseCacher {
  public enum Behavior {
    case cache
    case doNotCache
    case modify((Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)
  }
  public static var cache: LivingMapSDK.ResponseCacher
  public static var doNotCache: LivingMapSDK.ResponseCacher
  public let behavior: LivingMapSDK.ResponseCacher.Behavior
  public init(behavior: LivingMapSDK.ResponseCacher.Behavior)
}
extension LivingMapSDK.ResponseCacher : LivingMapSDK.CachedResponseHandler {
  public func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension LivingMapSDK.CachedResponseHandler where Self == LivingMapSDK.ResponseCacher {
  public static var cache: LivingMapSDK.ResponseCacher {
    get
  }
  public static var doNotCache: LivingMapSDK.ResponseCacher {
    get
  }
  public static func modify(using closure: @escaping ((Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)) -> LivingMapSDK.ResponseCacher
}
@available(*, deprecated, message: "See `init(resolver:)`")
public func wrap<T>(_ body: (@escaping (T?, Swift.Error?) -> Swift.Void) throws -> Swift.Void) -> LivingMapSDK.Promise<T>
@available(*, deprecated, message: "See `init(resolver:)`")
public func wrap<T>(_ body: (@escaping (T, Swift.Error?) -> Swift.Void) throws -> Swift.Void) -> LivingMapSDK.Promise<T>
@available(*, deprecated, message: "See `init(resolver:)`")
public func wrap<T>(_ body: (@escaping (Swift.Error?, T?) -> Swift.Void) throws -> Swift.Void) -> LivingMapSDK.Promise<T>
@available(*, deprecated, message: "See `init(resolver:)`")
public func wrap(_ body: (@escaping (Swift.Error?) -> Swift.Void) throws -> Swift.Void) -> LivingMapSDK.Promise<Swift.Void>
@available(*, deprecated, message: "See `init(resolver:)`")
public func wrap<T>(_ body: (@escaping (T) -> Swift.Void) throws -> Swift.Void) -> LivingMapSDK.Promise<T>
extension LivingMapSDK.Promise {
  @available(*, deprecated, message: "See `ensure`")
  final public func always(on q: Dispatch.DispatchQueue = .main, execute body: @escaping () -> Swift.Void) -> LivingMapSDK.Promise<T>
}
extension LivingMapSDK.Thenable where Self.T : Swift.Sequence {
  @available(*, deprecated, message: "See: `filterValues`")
  public func filter(on: Dispatch.DispatchQueue? = conf.Q.map, test: @escaping (Self.T.Iterator.Element) -> Swift.Bool) -> LivingMapSDK.Promise<[Self.T.Iterator.Element]>
}
extension LivingMapSDK.Thenable where Self.T : Swift.Collection {
  @available(*, deprecated, message: "See: `firstValue`")
  public var first: LivingMapSDK.Promise<Self.T.Element> {
    get
  }
  @available(*, deprecated, message: "See: `lastValue`")
  public var last: LivingMapSDK.Promise<Self.T.Element> {
    get
  }
}
extension LivingMapSDK.Thenable where Self.T : Swift.Sequence, Self.T.Element : Swift.Comparable {
  @available(*, deprecated, message: "See: `sortedValues`")
  public func sorted(on: Dispatch.DispatchQueue? = conf.Q.map) -> LivingMapSDK.Promise<[Self.T.Iterator.Element]>
}
public var AF: LivingMapSDK.Session
public struct MimeType {
  public var value: Swift.String {
    get
  }
  public init(path: Swift.String)
  public init(path: Foundation.NSString)
  public init(url: Foundation.URL)
}
public struct LMSensorUpdateFrequencies : Swift.Codable {
  public var foreground: LivingMapSDK.LMSensorUpdateFrequencies.SensorValues
  public var background: LivingMapSDK.LMSensorUpdateFrequencies.SensorValues
  public init(foreground: LivingMapSDK.LMSensorUpdateFrequencies.SensorValues = SensorValues(), background: LivingMapSDK.LMSensorUpdateFrequencies.SensorValues = SensorValues())
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension LivingMapSDK.LMSensorUpdateFrequencies {
  public struct SensorValues : Swift.Codable {
    public var accelerometer: Foundation.TimeInterval
    public var gyro: Foundation.TimeInterval
    public var mag: Foundation.TimeInterval
    public var device: Foundation.TimeInterval
    public var altimeter: Foundation.TimeInterval
    public var locationAccuracy: CoreLocation.CLLocationAccuracy
    public var distanceFilter: CoreLocation.CLLocationDistance
    public init(accelerometer: Foundation.TimeInterval = 0.1, gyro: Foundation.TimeInterval = 0.1, mag: Foundation.TimeInterval = 0.1, device: Foundation.TimeInterval = 0.1, altimeter: Foundation.TimeInterval = 0.1, locationAccuracy: CoreLocation.CLLocationAccuracy = kCLLocationAccuracyBest, distanceFilter: CoreLocation.CLLocationDistance = kCLDistanceFilterNone)
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
  }
}
open class LivingMapConfig {
  final public let mapUrl: Swift.String
  final public let project: Swift.String
  final public let backendUrl: Swift.String
  final public let debugMode: Swift.Bool
  final public let authenticationParameters: LivingMapSDK.AuthenticationParameters
  public var routingMode: Swift.Bool
  public var viewController: UIKit.UIViewController
  public var mapSize: CoreGraphics.CGRect
  public var token: Swift.String
  public var mapView: LivingMapSDK.MapView
  public init(mapUrl: Swift.String, project: Swift.String, authenticationParameters: LivingMapSDK.AuthenticationParameters, debugMode: Swift.Bool, routingMode: Swift.Bool, mapView: LivingMapSDK.MapView)
  public class Builder {
    public init()
    public func mapView(_ mapView: LivingMapSDK.MapView) -> LivingMapSDK.LivingMapConfig.Builder
    public func mapUrl(_ mapUrl: Swift.String) -> LivingMapSDK.LivingMapConfig.Builder
    public func project(_ project: Swift.String) -> LivingMapSDK.LivingMapConfig.Builder
    public func authenticationParameters(_ authenticationParameters: LivingMapSDK.AuthenticationParameters) -> LivingMapSDK.LivingMapConfig.Builder
    public func viewController(_ viewController: UIKit.UIViewController) -> LivingMapSDK.LivingMapConfig.Builder
    public func debugMode(_ debugMode: Swift.Bool) -> LivingMapSDK.LivingMapConfig.Builder
    public func routingMode(_ routingMode: Swift.Bool) -> LivingMapSDK.LivingMapConfig.Builder
    public func build() throws -> LivingMapSDK.LivingMapConfig
    @objc deinit
  }
  @objc deinit
}
public enum LivingMapErrorSeverity : Swift.String {
  case fatalError
  case error
  case warning
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public class LivingMapError : Swift.Error {
  final public let severity: LivingMapSDK.LivingMapErrorSeverity
  final public let errorCode: LivingMapSDK.LivingMapErrorCode
  final public let errorMessage: Swift.String
  public init(severity: LivingMapSDK.LivingMapErrorSeverity, errorCode: LivingMapSDK.LivingMapErrorCode, errorMessage: Swift.String)
  @objc deinit
}
@frozen public struct AnyCodable : Swift.Codable {
  public let value: Any
  public init<T>(_ value: T?)
}
extension LivingMapSDK.AnyCodable : LivingMapSDK._AnyEncodable, LivingMapSDK._AnyDecodable {
}
extension LivingMapSDK.AnyCodable : Swift.Equatable {
  public static func == (lhs: LivingMapSDK.AnyCodable, rhs: LivingMapSDK.AnyCodable) -> Swift.Bool
}
extension LivingMapSDK.AnyCodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LivingMapSDK.AnyCodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension LivingMapSDK.AnyCodable : Swift.ExpressibleByNilLiteral {
}
extension LivingMapSDK.AnyCodable : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
}
extension LivingMapSDK.AnyCodable : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
}
extension LivingMapSDK.AnyCodable : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
}
extension LivingMapSDK.AnyCodable : Swift.ExpressibleByStringLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension LivingMapSDK.AnyCodable : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Any
}
extension LivingMapSDK.AnyCodable : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.AnyHashable
  public typealias Value = Any
}
public enum LivingMapErrorCode : Swift.Int {
  case CannotConvertLivingMapLocationToJSON
  case NetworkUnreachable
  case CachingFailure
  case ConfigurationError
  case BluetoothIsOff
  case UnknownConnectivityStatus
  case CouldNotLoadWebView
  case UnrecognisedEventSentToSDK
  case EddystoneBeaconError
  case ErrorRunningJSCommand
  case MapHasNotFinishedLoading
  case ErrorWritingToLog
  case ErrorPreparingSimulatorCommandList
  case RequestForFloorHeightGridDataFailed
  case RequestForGatewayGridDataFailed
  case RequestForBeaconGridDataFailed
  case RequestForMagGridDataFailed
  case UnknownErrorRequestingGridData
  case failedToCreateMLMultiArray
  case failedToStartCalssificationModel
  case failedToPrediteActivity
  case failedToCreateMLModelInput
  case ErrorDownloadingCacheManifest
  case ErrorParsingCacheManifest
  case ErrorDownloadingPack
  case MapPackIsNotAValidZipFile
  case FailedToCreateUnzipDirectory
  case ErrorUnzippingMapPack
  case DeviceIsOffline
  case ErrorDownloadingGridFile
  case ErrorDownloadingChecksums
  case KeyCannotBeNull
  case GeneralFileDownloadError
  case ChecksumsDoNotMatch
  case NoSensorData
  case LiveReportingRegistrationError
  case NoViewControllerInConfig
  case RoutingErrorNoDepartureGate
  case RoutingErrorNoResponse
  case ErrorRegisteringForFlightData
  case InvalidFlightData
  case RoutingGeneralError
  case FATAL_ERROR_EXIT_CALLBACK
  case InvalidConnectionStatus
  case UnableToSetInitialLocation
  case PollingResponse
  case MapUrls
  case NoMapUrlsReturned
  case PollResponseParse
  case RoutingErrorInResponse
  case AviationAcceleratorAlreadRunning
  case InitializationError
  case GridFileError
  case NoGridFoundError
  case DataAlreadyUploadedError
  case DataNotUploadedError
  case PositioningError
  case NoSynchronizationError
  case NoHeadingEstimatorError
  case HeadingEstimationError
  case NoFloorEstimatorError
  case FloorEstimationError
  case NonRecoverableError
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct LMActivityClassificationConfig : Swift.Codable {
  public var predictionWindowSize: Swift.Int
  public var stateInLength: Swift.Int
  public var travelatorsFloorsID: [Swift.Int32]
  public init(predictionWindowSize: Swift.Int = 10, stateInLength: Swift.Int = 400, stoppedWalkingThreshold: Swift.Double = 2.0, travelatorsFloorsID: [Swift.Int32])
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct Matrix : Swift.Equatable {
  public let rows: Swift.Int, columns: Swift.Int
  public var grid: [Swift.Double]
  public init(rows: Swift.Int, columns: Swift.Int)
  public init(grid: [Swift.Double], rows: Swift.Int, columns: Swift.Int)
  public init(vector: [Swift.Double])
  public init(vectorOf size: Swift.Int)
  public init(squareOfSize size: Swift.Int)
  public init(identityOfSize size: Swift.Int)
  public init(_ array2d: [[Swift.Double]])
  public func indexIsValid(forRow row: Swift.Int, column: Swift.Int) -> Swift.Bool
  public subscript(row: Swift.Int, column: Swift.Int) -> Swift.Double {
    get
    set(newValue)
  }
}
public func == (lhs: LivingMapSDK.Matrix, rhs: LivingMapSDK.Matrix) -> Swift.Bool
extension LivingMapSDK.Matrix : LivingMapSDK.KalmanInput {
  public var transposed: LivingMapSDK.Matrix {
    get
  }
  public var additionToUnit: LivingMapSDK.Matrix {
    get
  }
  public var inversed: LivingMapSDK.Matrix {
    get
  }
  public var determinant: Swift.Double {
    get
  }
  public func additionalMatrix(row: Swift.Int, column: Swift.Int) -> LivingMapSDK.Matrix
}
public func + (lhs: LivingMapSDK.Matrix, rhs: LivingMapSDK.Matrix) -> LivingMapSDK.Matrix
public func - (lhs: LivingMapSDK.Matrix, rhs: LivingMapSDK.Matrix) -> LivingMapSDK.Matrix
public func * (lhs: LivingMapSDK.Matrix, rhs: LivingMapSDK.Matrix) -> LivingMapSDK.Matrix
public func * (lhs: LivingMapSDK.Matrix, rhs: Swift.Double) -> LivingMapSDK.Matrix
public func * (lhs: Swift.Double, rhs: LivingMapSDK.Matrix) -> LivingMapSDK.Matrix
extension LivingMapSDK.Matrix : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public func when<U>(fulfilled thenables: [U]) -> LivingMapSDK.Promise<[U.T]> where U : LivingMapSDK.Thenable
public func when<U>(fulfilled promises: U...) -> LivingMapSDK.Promise<Swift.Void> where U : LivingMapSDK.Thenable, U.T == Swift.Void
public func when<U>(fulfilled promises: [U]) -> LivingMapSDK.Promise<Swift.Void> where U : LivingMapSDK.Thenable, U.T == Swift.Void
public func when<U, V>(fulfilled pu: U, _ pv: V) -> LivingMapSDK.Promise<(U.T, V.T)> where U : LivingMapSDK.Thenable, V : LivingMapSDK.Thenable
public func when<U, V, W>(fulfilled pu: U, _ pv: V, _ pw: W) -> LivingMapSDK.Promise<(U.T, V.T, W.T)> where U : LivingMapSDK.Thenable, V : LivingMapSDK.Thenable, W : LivingMapSDK.Thenable
public func when<U, V, W, X>(fulfilled pu: U, _ pv: V, _ pw: W, _ px: X) -> LivingMapSDK.Promise<(U.T, V.T, W.T, X.T)> where U : LivingMapSDK.Thenable, V : LivingMapSDK.Thenable, W : LivingMapSDK.Thenable, X : LivingMapSDK.Thenable
public func when<U, V, W, X, Y>(fulfilled pu: U, _ pv: V, _ pw: W, _ px: X, _ py: Y) -> LivingMapSDK.Promise<(U.T, V.T, W.T, X.T, Y.T)> where U : LivingMapSDK.Thenable, V : LivingMapSDK.Thenable, W : LivingMapSDK.Thenable, X : LivingMapSDK.Thenable, Y : LivingMapSDK.Thenable
public func when<It>(fulfilled promiseIterator: It, concurrently: Swift.Int) -> LivingMapSDK.Promise<[It.Element.T]> where It : Swift.IteratorProtocol, It.Element : LivingMapSDK.Thenable
public func when<T>(resolved promises: LivingMapSDK.Promise<T>...) -> LivingMapSDK.Guarantee<[LivingMapSDK.Result<T>]>
public func when<T>(resolved promises: [LivingMapSDK.Promise<T>]) -> LivingMapSDK.Guarantee<[LivingMapSDK.Result<T>]>
public func when<It>(resolved promiseIterator: It, concurrently: Swift.Int) -> LivingMapSDK.Guarantee<[LivingMapSDK.Result<It.Element.T>]> where It : Swift.IteratorProtocol, It.Element : LivingMapSDK.Thenable
public func when(_ guarantees: LivingMapSDK.Guarantee<Swift.Void>...) -> LivingMapSDK.Guarantee<Swift.Void>
public func when(guarantees: [LivingMapSDK.Guarantee<Swift.Void>]) -> LivingMapSDK.Guarantee<Swift.Void>
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class LMWebViewController : UIKit.UIViewController, WebKit.WKUIDelegate, LivingMapSDK.LivingMapInterface, LivingMapSDK.DebugModeListener {
  @_Concurrency.MainActor(unsafe) public var mapUrl: Swift.String?
  @_Concurrency.MainActor(unsafe) public var mapQueryParams: [Foundation.URLQueryItem]?
  @_Concurrency.MainActor(unsafe) public var eventHandler: LivingMapSDK.LivingMapMappingEvents?
  @_Concurrency.MainActor(unsafe) public func setSDKManager(sdkManager: LivingMapSDK.LivingMapSDKManager)
  @_Concurrency.MainActor(unsafe) public func connectivityStatusChanged(connectivityStatus: LivingMapSDK.LivingMapConstants.ConnectivityStatus)
  @_Concurrency.MainActor(unsafe) public func changeView(mapView: LivingMapSDK.MapView)
  @_Concurrency.MainActor(unsafe) public func setGroupedView(deviceId: Swift.String, groupId: Swift.Int, username: Swift.String, password: Swift.String)
  @_Concurrency.MainActor(unsafe) public func setUngroupedView()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor(unsafe) public func getWebView() -> WebKit.WKWebView?
  @_Concurrency.MainActor(unsafe) public func isMapReady() -> Swift.Bool
  @_Concurrency.MainActor(unsafe) public func setMapStyle(mapStyle: Swift.String)
  @_Concurrency.MainActor(unsafe) public func sendCommandToFrontEnd(command: Swift.String, completionHandler: @escaping (Any?, Swift.Error?) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func sendCommandToFrontEnd(command: Swift.String, returnCallback: @escaping (Any?, Swift.Error?) -> Swift.Void, eventKeyCallbackListener: Swift.String, asyncCallback: @escaping (Foundation.NSArray) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func onLowCalibrationStatus(calibrationAlert: UIKit.UIAlertController)
  @_Concurrency.MainActor(unsafe) public func onAltitudeUpdate(altitude: Swift.Double, pressure: Swift.Double)
  @_Concurrency.MainActor(unsafe) public func stepInfoUpdated(_ step: LivingMapSDK.LMStep)
  @_Concurrency.MainActor(unsafe) public func pressureUpdated(pressure: Swift.String)
  @_Concurrency.MainActor(unsafe) public func headingUpdated(heading: Swift.Double)
  @_Concurrency.MainActor(unsafe) public func locationReceived(location: LivingMapSDK.LMLocation)
  @_Concurrency.MainActor(unsafe) public func locationReceived(associatedLocations: [LivingMapSDK.LMLocation])
  @_Concurrency.MainActor(unsafe) public func onCPLMetricsUpdate(offset: Swift.Double, depletion: Swift.Double)
  @_Concurrency.MainActor(unsafe) public func errorReceived(error: LivingMapSDK.LivingMapError)
  @_Concurrency.MainActor(unsafe) public func setEventHandler(eventHandler: LivingMapSDK.LivingMapMappingEvents)
  @_Concurrency.MainActor(unsafe) public func customEvent(eventId: Swift.String, eventParameters: Foundation.NSArray)
  @_Concurrency.MainActor(unsafe) public func onConnectivityStatusChanged(connectivityStatus: LivingMapSDK.LivingMapConstants.ConnectivityStatus)
  @_Concurrency.MainActor(unsafe) public func destinationReached()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
open class ServerTrustManager {
  final public let allHostsMustBeEvaluated: Swift.Bool
  final public let evaluators: [Swift.String : LivingMapSDK.ServerTrustEvaluating]
  public init(allHostsMustBeEvaluated: Swift.Bool = true, evaluators: [Swift.String : LivingMapSDK.ServerTrustEvaluating])
  open func serverTrustEvaluator(forHost host: Swift.String) throws -> LivingMapSDK.ServerTrustEvaluating?
  @objc deinit
}
public protocol ServerTrustEvaluating {
  func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
final public class DefaultTrustEvaluator : LivingMapSDK.ServerTrustEvaluating {
  public init(validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class RevocationTrustEvaluator : LivingMapSDK.ServerTrustEvaluating {
  public struct Options : Swift.OptionSet {
    public static var crl: LivingMapSDK.RevocationTrustEvaluator.Options
    public static var networkAccessDisabled: LivingMapSDK.RevocationTrustEvaluator.Options
    public static var ocsp: LivingMapSDK.RevocationTrustEvaluator.Options
    public static var preferCRL: LivingMapSDK.RevocationTrustEvaluator.Options
    public static var requirePositiveResponse: LivingMapSDK.RevocationTrustEvaluator.Options
    public static var any: LivingMapSDK.RevocationTrustEvaluator.Options
    public let rawValue: CoreFoundation.CFOptionFlags
    public init(rawValue: CoreFoundation.CFOptionFlags)
    public typealias ArrayLiteralElement = LivingMapSDK.RevocationTrustEvaluator.Options
    public typealias Element = LivingMapSDK.RevocationTrustEvaluator.Options
    public typealias RawValue = CoreFoundation.CFOptionFlags
  }
  public init(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: LivingMapSDK.RevocationTrustEvaluator.Options = .any)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension LivingMapSDK.ServerTrustEvaluating where Self == LivingMapSDK.RevocationTrustEvaluator {
  public static var revocationChecking: LivingMapSDK.RevocationTrustEvaluator {
    get
  }
  public static func revocationChecking(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: LivingMapSDK.RevocationTrustEvaluator.Options = .any) -> LivingMapSDK.RevocationTrustEvaluator
}
final public class PinnedCertificatesTrustEvaluator : LivingMapSDK.ServerTrustEvaluating {
  public init(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension LivingMapSDK.ServerTrustEvaluating where Self == LivingMapSDK.PinnedCertificatesTrustEvaluator {
  public static var pinnedCertificates: LivingMapSDK.PinnedCertificatesTrustEvaluator {
    get
  }
  public static func pinnedCertificates(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true) -> LivingMapSDK.PinnedCertificatesTrustEvaluator
}
final public class PublicKeysTrustEvaluator : LivingMapSDK.ServerTrustEvaluating {
  public init(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension LivingMapSDK.ServerTrustEvaluating where Self == LivingMapSDK.PublicKeysTrustEvaluator {
  public static var publicKeys: LivingMapSDK.PublicKeysTrustEvaluator {
    get
  }
  public static func publicKeys(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true) -> LivingMapSDK.PublicKeysTrustEvaluator
}
final public class CompositeTrustEvaluator : LivingMapSDK.ServerTrustEvaluating {
  public init(evaluators: [LivingMapSDK.ServerTrustEvaluating])
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension LivingMapSDK.ServerTrustEvaluating where Self == LivingMapSDK.CompositeTrustEvaluator {
  public static func composite(evaluators: [LivingMapSDK.ServerTrustEvaluating]) -> LivingMapSDK.CompositeTrustEvaluator
}
@available(*, deprecated, renamed: "DisabledTrustEvaluator", message: "DisabledEvaluator has been renamed DisabledTrustEvaluator.")
public typealias DisabledEvaluator = LivingMapSDK.DisabledTrustEvaluator
final public class DisabledTrustEvaluator : LivingMapSDK.ServerTrustEvaluating {
  public init()
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension Swift.Array where Element == LivingMapSDK.ServerTrustEvaluating {
  public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
extension Foundation.Bundle : LivingMapSDK.AlamofireExtended {
  public typealias ExtendedType = Foundation.Bundle
}
extension LivingMapSDK.AlamofireExtension where ExtendedType : Foundation.Bundle {
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
  public func paths(forResourcesOfTypes types: [Swift.String]) -> [Swift.String]
}
extension Security.SecTrust : LivingMapSDK.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrust
}
extension LivingMapSDK.AlamofireExtension where ExtendedType == Security.SecTrust {
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate(afterApplying policy: Security.SecPolicy) throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate(afterApplying:)")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate(afterApplying:)")
  public func validate(policy: Security.SecPolicy, errorProducer: (_ status: Darwin.OSStatus, _ result: Security.SecTrustResultType) -> Swift.Error) throws
  public func apply(policy: Security.SecPolicy) throws -> Security.SecTrust
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate() throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate()")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate()")
  public func validate(errorProducer: (_ status: Darwin.OSStatus, _ result: Security.SecTrustResultType) -> Swift.Error) throws
  public func setAnchorCertificates(_ certificates: [Security.SecCertificate]) throws
  public var publicKeys: [Security.SecKey] {
    get
  }
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var certificateData: [Foundation.Data] {
    get
  }
  public func performDefaultValidation(forHost host: Swift.String) throws
  public func performValidation(forHost host: Swift.String) throws
}
extension Security.SecPolicy : LivingMapSDK.AlamofireExtended {
  public typealias ExtendedType = Security.SecPolicy
}
extension LivingMapSDK.AlamofireExtension where ExtendedType == Security.SecPolicy {
  public static var `default`: Security.SecPolicy
  public static func hostname(_ hostname: Swift.String) -> Security.SecPolicy
  public static func revocation(options: LivingMapSDK.RevocationTrustEvaluator.Options) throws -> Security.SecPolicy
}
extension Swift.Array : LivingMapSDK.AlamofireExtended {
  public typealias ExtendedType = Swift.Array<Element>
}
extension LivingMapSDK.AlamofireExtension where ExtendedType == [Security.SecCertificate] {
  public var data: [Foundation.Data] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
}
extension Security.SecCertificate : LivingMapSDK.AlamofireExtended {
  public typealias ExtendedType = Security.SecCertificate
}
extension LivingMapSDK.AlamofireExtension where ExtendedType == Security.SecCertificate {
  public var publicKey: Security.SecKey? {
    get
  }
}
extension Swift.Int32 : LivingMapSDK.AlamofireExtended {
  public typealias ExtendedType = Swift.Int32
}
extension LivingMapSDK.AlamofireExtension where ExtendedType == Darwin.OSStatus {
  public var isSuccess: Swift.Bool {
    get
  }
}
extension Security.SecTrustResultType : LivingMapSDK.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrustResultType
}
extension LivingMapSDK.AlamofireExtension where ExtendedType == Security.SecTrustResultType {
  public var isSuccess: Swift.Bool {
    get
  }
}
public class LMAuthenticator {
  public var securityUrl: Swift.String
  public init(sessionNoAuth: LivingMapSDK.Session)
  @objc deinit
}
public protocol CatchMixin : LivingMapSDK.Thenable {
}
extension LivingMapSDK.CatchMixin {
  @discardableResult
  public func `catch`(on: Dispatch.DispatchQueue? = conf.Q.return, flags: Dispatch.DispatchWorkItemFlags? = nil, policy: LivingMapSDK.CatchPolicy = conf.catchPolicy, _ body: @escaping (Swift.Error) -> Swift.Void) -> LivingMapSDK.PMKFinalizer
}
@_hasMissingDesignatedInitializers public class PMKFinalizer {
  public func finally(on: Dispatch.DispatchQueue? = conf.Q.return, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping () -> Swift.Void)
  @objc deinit
}
extension LivingMapSDK.CatchMixin {
  public func recover<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, policy: LivingMapSDK.CatchPolicy = conf.catchPolicy, _ body: @escaping (Swift.Error) throws -> U) -> LivingMapSDK.Promise<Self.T> where U : LivingMapSDK.Thenable, Self.T == U.T
  @discardableResult
  public func recover(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (Swift.Error) -> LivingMapSDK.Guarantee<Self.T>) -> LivingMapSDK.Guarantee<Self.T>
  public func ensure(on: Dispatch.DispatchQueue? = conf.Q.return, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping () -> Swift.Void) -> LivingMapSDK.Promise<Self.T>
  public func ensureThen(on: Dispatch.DispatchQueue? = conf.Q.return, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping () -> LivingMapSDK.Guarantee<Swift.Void>) -> LivingMapSDK.Promise<Self.T>
  @discardableResult
  public func cauterize() -> LivingMapSDK.PMKFinalizer
}
extension LivingMapSDK.CatchMixin where Self.T == Swift.Void {
  @discardableResult
  public func recover(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (Swift.Error) -> Swift.Void) -> LivingMapSDK.Guarantee<Swift.Void>
  public func recover(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, policy: LivingMapSDK.CatchPolicy = conf.catchPolicy, _ body: @escaping (Swift.Error) throws -> Swift.Void) -> LivingMapSDK.Promise<Swift.Void>
}
@_hasMissingDesignatedInitializers open class NetworkReachabilityManager {
  public enum NetworkReachabilityStatus {
    case unknown
    case notReachable
    case reachable(LivingMapSDK.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType)
    public enum ConnectionType {
      case ethernetOrWiFi
      case cellular
      public static func == (a: LivingMapSDK.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType, b: LivingMapSDK.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
  }
  public typealias Listener = (LivingMapSDK.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Void
  public static var `default`: LivingMapSDK.NetworkReachabilityManager?
  open var isReachable: Swift.Bool {
    get
  }
  open var isReachableOnCellular: Swift.Bool {
    get
  }
  open var isReachableOnEthernetOrWiFi: Swift.Bool {
    get
  }
  final public let reachabilityQueue: Dispatch.DispatchQueue
  open var flags: SystemConfiguration.SCNetworkReachabilityFlags? {
    get
  }
  open var status: LivingMapSDK.NetworkReachabilityManager.NetworkReachabilityStatus {
    get
  }
  public convenience init?(host: Swift.String)
  public convenience init?()
  @objc deinit
  @discardableResult
  open func startListening(onQueue queue: Dispatch.DispatchQueue = .main, onUpdatePerforming listener: @escaping LivingMapSDK.NetworkReachabilityManager.Listener) -> Swift.Bool
  open func stopListening()
}
extension LivingMapSDK.NetworkReachabilityManager.NetworkReachabilityStatus : Swift.Equatable {
  public static func == (a: LivingMapSDK.NetworkReachabilityManager.NetworkReachabilityStatus, b: LivingMapSDK.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Bool
}
public protocol DataResponseSerializerProtocol {
  associatedtype SerializedObject
  func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Self.SerializedObject
}
public protocol DownloadResponseSerializerProtocol {
  associatedtype SerializedObject
  func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Self.SerializedObject
}
public protocol ResponseSerializer : LivingMapSDK.DataResponseSerializerProtocol, LivingMapSDK.DownloadResponseSerializerProtocol {
  var dataPreprocessor: LivingMapSDK.DataPreprocessor { get }
  var emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> { get }
  var emptyResponseCodes: Swift.Set<Swift.Int> { get }
}
public protocol DataPreprocessor {
  func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct PassthroughPreprocessor : LivingMapSDK.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct GoogleXSSIPreprocessor : LivingMapSDK.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
extension LivingMapSDK.DataPreprocessor where Self == LivingMapSDK.PassthroughPreprocessor {
  public static var passthrough: LivingMapSDK.PassthroughPreprocessor {
    get
  }
}
extension LivingMapSDK.DataPreprocessor where Self == LivingMapSDK.GoogleXSSIPreprocessor {
  public static var googleXSSI: LivingMapSDK.GoogleXSSIPreprocessor {
    get
  }
}
extension LivingMapSDK.ResponseSerializer {
  public static var defaultDataPreprocessor: LivingMapSDK.DataPreprocessor {
    get
  }
  public static var defaultEmptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> {
    get
  }
  public static var defaultEmptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public var dataPreprocessor: LivingMapSDK.DataPreprocessor {
    get
  }
  public var emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> {
    get
  }
  public var emptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public func requestAllowsEmptyResponseData(_ request: Foundation.URLRequest?) -> Swift.Bool?
  public func responseAllowsEmptyResponseData(_ response: Foundation.HTTPURLResponse?) -> Swift.Bool?
  public func emptyResponseAllowed(forRequest request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?) -> Swift.Bool
}
extension LivingMapSDK.DownloadResponseSerializerProtocol where Self : LivingMapSDK.DataResponseSerializerProtocol {
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Self.SerializedObject
}
extension LivingMapSDK.DataRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (LivingMapSDK.AFDataResponse<Foundation.Data?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (LivingMapSDK.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : LivingMapSDK.DataResponseSerializerProtocol
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (LivingMapSDK.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : LivingMapSDK.ResponseSerializer
}
extension LivingMapSDK.DownloadRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (LivingMapSDK.AFDownloadResponse<Foundation.URL?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (LivingMapSDK.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : LivingMapSDK.DownloadResponseSerializerProtocol
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (LivingMapSDK.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : LivingMapSDK.ResponseSerializer
}
public struct URLResponseSerializer : LivingMapSDK.DownloadResponseSerializerProtocol {
  public init()
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Foundation.URL
  public typealias SerializedObject = Foundation.URL
}
extension LivingMapSDK.DownloadResponseSerializerProtocol where Self == LivingMapSDK.URLResponseSerializer {
  public static var url: LivingMapSDK.URLResponseSerializer {
    get
  }
}
extension LivingMapSDK.DownloadRequest {
  @discardableResult
  public func responseURL(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (LivingMapSDK.AFDownloadResponse<Foundation.URL>) -> Swift.Void) -> Self
}
final public class DataResponseSerializer : LivingMapSDK.ResponseSerializer {
  final public let dataPreprocessor: LivingMapSDK.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod>
  public init(dataPreprocessor: LivingMapSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
  @objc deinit
}
extension LivingMapSDK.ResponseSerializer where Self == LivingMapSDK.DataResponseSerializer {
  public static var data: LivingMapSDK.DataResponseSerializer {
    get
  }
  public static func data(dataPreprocessor: LivingMapSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> LivingMapSDK.DataResponseSerializer
}
extension LivingMapSDK.DataRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: LivingMapSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (LivingMapSDK.AFDataResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension LivingMapSDK.DownloadRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: LivingMapSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (LivingMapSDK.AFDownloadResponse<Foundation.Data>) -> Swift.Void) -> Self
}
final public class StringResponseSerializer : LivingMapSDK.ResponseSerializer {
  final public let dataPreprocessor: LivingMapSDK.DataPreprocessor
  final public let encoding: Swift.String.Encoding?
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod>
  public init(dataPreprocessor: LivingMapSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Swift.String
  public typealias SerializedObject = Swift.String
  @objc deinit
}
extension LivingMapSDK.ResponseSerializer where Self == LivingMapSDK.StringResponseSerializer {
  public static var string: LivingMapSDK.StringResponseSerializer {
    get
  }
  public static func string(dataPreprocessor: LivingMapSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> LivingMapSDK.StringResponseSerializer
}
extension LivingMapSDK.DataRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: LivingMapSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (LivingMapSDK.AFDataResponse<Swift.String>) -> Swift.Void) -> Self
}
extension LivingMapSDK.DownloadRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: LivingMapSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (LivingMapSDK.AFDownloadResponse<Swift.String>) -> Swift.Void) -> Self
}
@available(*, deprecated, message: "JSONResponseSerializer deprecated and will be removed in Alamofire 6. Use DecodableResponseSerializer instead.")
final public class JSONResponseSerializer : LivingMapSDK.ResponseSerializer {
  final public let dataPreprocessor: LivingMapSDK.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod>
  final public let options: Foundation.JSONSerialization.ReadingOptions
  public init(dataPreprocessor: LivingMapSDK.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Any
  public typealias SerializedObject = Any
  @objc deinit
}
extension LivingMapSDK.DataRequest {
  @available(*, deprecated, message: "responseJSON deprecated and will be removed in Alamofire 6. Use responseDecodable instead.")
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: LivingMapSDK.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (LivingMapSDK.AFDataResponse<Any>) -> Swift.Void) -> Self
}
extension LivingMapSDK.DownloadRequest {
  @available(*, deprecated, message: "responseJSON deprecated and will be removed in Alamofire 6. Use responseDecodable instead.")
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: LivingMapSDK.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (LivingMapSDK.AFDownloadResponse<Any>) -> Swift.Void) -> Self
}
public protocol EmptyResponse {
  static func emptyValue() -> Self
}
public struct Empty : Swift.Codable {
  public static var value: LivingMapSDK.Empty
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension LivingMapSDK.Empty : LivingMapSDK.EmptyResponse {
  public static func emptyValue() -> LivingMapSDK.Empty
}
public protocol DataDecoder {
  func decode<D>(_ type: D.Type, from data: Foundation.Data) throws -> D where D : Swift.Decodable
}
extension Foundation.JSONDecoder : LivingMapSDK.DataDecoder {
}
extension Foundation.PropertyListDecoder : LivingMapSDK.DataDecoder {
}
final public class DecodableResponseSerializer<T> : LivingMapSDK.ResponseSerializer where T : Swift.Decodable {
  final public let dataPreprocessor: LivingMapSDK.DataPreprocessor
  final public let decoder: LivingMapSDK.DataDecoder
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod>
  public init(dataPreprocessor: LivingMapSDK.DataPreprocessor = DecodableResponseSerializer.defaultDataPreprocessor, decoder: LivingMapSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DecodableResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> T
  public typealias SerializedObject = T
  @objc deinit
}
extension LivingMapSDK.ResponseSerializer {
  public static func decodable<T>(of type: T.Type, dataPreprocessor: LivingMapSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: LivingMapSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> LivingMapSDK.DecodableResponseSerializer<T> where Self == LivingMapSDK.DecodableResponseSerializer<T>, T : Swift.Decodable
}
extension LivingMapSDK.DataRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: LivingMapSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: LivingMapSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (LivingMapSDK.AFDataResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
extension LivingMapSDK.DownloadRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: LivingMapSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: LivingMapSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (LivingMapSDK.AFDownloadResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
public protocol DataStreamSerializer {
  associatedtype SerializedObject
  func serialize(_ data: Foundation.Data) throws -> Self.SerializedObject
}
public struct DecodableStreamSerializer<T> : LivingMapSDK.DataStreamSerializer where T : Swift.Decodable {
  public let decoder: LivingMapSDK.DataDecoder
  public let dataPreprocessor: LivingMapSDK.DataPreprocessor
  public init(decoder: LivingMapSDK.DataDecoder = JSONDecoder(), dataPreprocessor: LivingMapSDK.DataPreprocessor = PassthroughPreprocessor())
  public func serialize(_ data: Foundation.Data) throws -> T
  public typealias SerializedObject = T
}
public struct PassthroughStreamSerializer : LivingMapSDK.DataStreamSerializer {
  public func serialize(_ data: Foundation.Data) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
}
public struct StringStreamSerializer : LivingMapSDK.DataStreamSerializer {
  public func serialize(_ data: Foundation.Data) throws -> Swift.String
  public typealias SerializedObject = Swift.String
}
extension LivingMapSDK.DataStreamSerializer {
  public static func decodable<T>(of type: T.Type, decoder: LivingMapSDK.DataDecoder = JSONDecoder(), dataPreprocessor: LivingMapSDK.DataPreprocessor = PassthroughPreprocessor()) -> Self where Self == LivingMapSDK.DecodableStreamSerializer<T>, T : Swift.Decodable
}
extension LivingMapSDK.DataStreamSerializer where Self == LivingMapSDK.PassthroughStreamSerializer {
  public static var passthrough: LivingMapSDK.PassthroughStreamSerializer {
    get
  }
}
extension LivingMapSDK.DataStreamSerializer where Self == LivingMapSDK.StringStreamSerializer {
  public static var string: LivingMapSDK.StringStreamSerializer {
    get
  }
}
extension LivingMapSDK.DataStreamRequest {
  @discardableResult
  final public func responseStream(on queue: Dispatch.DispatchQueue = .main, stream: @escaping LivingMapSDK.DataStreamRequest.Handler<Foundation.Data, Swift.Never>) -> Self
  @discardableResult
  final public func responseStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main, stream: @escaping LivingMapSDK.DataStreamRequest.Handler<Serializer.SerializedObject, LivingMapSDK.AFError>) -> Self where Serializer : LivingMapSDK.DataStreamSerializer
  @discardableResult
  final public func responseStreamString(on queue: Dispatch.DispatchQueue = .main, stream: @escaping LivingMapSDK.DataStreamRequest.Handler<Swift.String, Swift.Never>) -> Self
  @discardableResult
  final public func responseStreamDecodable<T>(of type: T.Type = T.self, on queue: Dispatch.DispatchQueue = .main, using decoder: LivingMapSDK.DataDecoder = JSONDecoder(), preprocessor: LivingMapSDK.DataPreprocessor = PassthroughPreprocessor(), stream: @escaping LivingMapSDK.DataStreamRequest.Handler<T, LivingMapSDK.AFError>) -> Self where T : Swift.Decodable
}
public struct PMKConfiguration {
  public var Q: (map: Dispatch.DispatchQueue?, return: Dispatch.DispatchQueue?)
  public var catchPolicy: LivingMapSDK.CatchPolicy
  public var logHandler: (_ event: LivingMapSDK.LogEvent) -> Swift.Void
}
public var conf: LivingMapSDK.PMKConfiguration
open class RetryPolicy : LivingMapSDK.RequestInterceptor {
  public static var defaultRetryLimit: Swift.UInt
  public static var defaultExponentialBackoffBase: Swift.UInt
  public static var defaultExponentialBackoffScale: Swift.Double
  public static var defaultRetryableHTTPMethods: Swift.Set<LivingMapSDK.HTTPMethod>
  public static var defaultRetryableHTTPStatusCodes: Swift.Set<Swift.Int>
  public static var defaultRetryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  final public let retryLimit: Swift.UInt
  final public let exponentialBackoffBase: Swift.UInt
  final public let exponentialBackoffScale: Swift.Double
  final public let retryableHTTPMethods: Swift.Set<LivingMapSDK.HTTPMethod>
  final public let retryableHTTPStatusCodes: Swift.Set<Swift.Int>
  final public let retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<LivingMapSDK.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = RetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes)
  open func retry(_ request: LivingMapSDK.Request, for session: LivingMapSDK.Session, dueTo error: Swift.Error, completion: @escaping (LivingMapSDK.RetryResult) -> Swift.Void)
  open func shouldRetry(request: LivingMapSDK.Request, dueTo error: Swift.Error) -> Swift.Bool
  @objc deinit
}
extension LivingMapSDK.RequestInterceptor where Self == LivingMapSDK.RetryPolicy {
  public static var retryPolicy: LivingMapSDK.RetryPolicy {
    get
  }
  public static func retryPolicy(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<LivingMapSDK.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = RetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes) -> LivingMapSDK.RetryPolicy
}
open class ConnectionLostRetryPolicy : LivingMapSDK.RetryPolicy {
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<LivingMapSDK.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods)
  @objc deinit
}
extension LivingMapSDK.RequestInterceptor where Self == LivingMapSDK.ConnectionLostRetryPolicy {
  public static var connectionLostRetryPolicy: LivingMapSDK.ConnectionLostRetryPolicy {
    get
  }
  public static func connectionLostRetryPolicy(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<LivingMapSDK.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods) -> LivingMapSDK.ConnectionLostRetryPolicy
}
@objc open class SessionDelegate : ObjectiveC.NSObject {
  public init(fileManager: Foundation.FileManager = .default)
  @objc deinit
}
extension LivingMapSDK.SessionDelegate : Foundation.URLSessionDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
}
extension LivingMapSDK.SessionDelegate : Foundation.URLSessionTaskDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, needNewBodyStream completionHandler: @escaping (Foundation.InputStream?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
}
extension LivingMapSDK.SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension LivingMapSDK.SessionDelegate : Foundation.URLSessionDownloadDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
}
public func race<U>(_ thenables: U...) -> LivingMapSDK.Promise<U.T> where U : LivingMapSDK.Thenable
public func race<U>(_ thenables: [U]) -> LivingMapSDK.Promise<U.T> where U : LivingMapSDK.Thenable
public func race<T>(_ guarantees: LivingMapSDK.Guarantee<T>...) -> LivingMapSDK.Guarantee<T>
public func race<U>(fulfilled thenables: [U]) -> LivingMapSDK.Promise<U.T> where U : LivingMapSDK.Thenable

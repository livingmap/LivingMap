// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.8.1 (swiftlang-5.8.0.124.5 clang-1403.0.22.11.100)
// swift-module-flags: -target x86_64-apple-ios13.1-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name LivingMapSDK
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Accelerate
import Combine
import CoreBluetooth
import CoreFoundation
import CoreLocation
import CoreMotion
import Dispatch
import Foundation
import Foundation/*.Thread*/
import Foundation/*.TimeInterval*/
@_exported import LivingMapSDK
import MobileCoreServices
import Network
import Swift
import SystemConfiguration
import UIKit
import WebKit
import _Concurrency
import _StringProcessing
@_hasMissingDesignatedInitializers public class Request {
  public enum State {
    case initialized
    case resumed
    case suspended
    case cancelled
    case finished
    public static func == (a: LivingMapSDK.Request.State, b: LivingMapSDK.Request.State) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let id: Foundation.UUID
  final public let underlyingQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let eventMonitor: (any LivingMapSDK.EventMonitor)?
  final public let interceptor: (any LivingMapSDK.RequestInterceptor)?
  weak public var delegate: (any LivingMapSDK.RequestDelegate)? {
    get
  }
  public var state: LivingMapSDK.Request.State {
    get
  }
  public var isInitialized: Swift.Bool {
    get
  }
  public var isResumed: Swift.Bool {
    get
  }
  public var isSuspended: Swift.Bool {
    get
  }
  public var isCancelled: Swift.Bool {
    get
  }
  public var isFinished: Swift.Bool {
    get
  }
  public typealias ProgressHandler = (Foundation.Progress) -> Swift.Void
  final public let uploadProgress: Foundation.Progress
  final public let downloadProgress: Foundation.Progress
  public var redirectHandler: (any LivingMapSDK.RedirectHandler)? {
    get
  }
  public var cachedResponseHandler: (any LivingMapSDK.CachedResponseHandler)? {
    get
  }
  public var credential: Foundation.URLCredential? {
    get
  }
  public var requests: [Foundation.URLRequest] {
    get
  }
  public var firstRequest: Foundation.URLRequest? {
    get
  }
  public var lastRequest: Foundation.URLRequest? {
    get
  }
  public var request: Foundation.URLRequest? {
    get
  }
  public var performedRequests: [Foundation.URLRequest] {
    get
  }
  public var response: Foundation.HTTPURLResponse? {
    get
  }
  public var tasks: [Foundation.URLSessionTask] {
    get
  }
  public var firstTask: Foundation.URLSessionTask? {
    get
  }
  public var lastTask: Foundation.URLSessionTask? {
    get
  }
  public var task: Foundation.URLSessionTask? {
    get
  }
  public var allMetrics: [Foundation.URLSessionTaskMetrics] {
    get
  }
  public var firstMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var lastMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var retryCount: Swift.Int {
    get
  }
  public var error: LivingMapSDK.AFError? {
    get
  }
  @discardableResult
  public func cancel() -> Self
  @discardableResult
  public func suspend() -> Self
  @discardableResult
  public func resume() -> Self
  @discardableResult
  public func authenticate(username: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence = .forSession) -> Self
  @discardableResult
  public func authenticate(with credential: Foundation.URLCredential) -> Self
  @discardableResult
  public func downloadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping LivingMapSDK.Request.ProgressHandler) -> Self
  @discardableResult
  public func uploadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping LivingMapSDK.Request.ProgressHandler) -> Self
  @discardableResult
  public func redirect(using handler: any LivingMapSDK.RedirectHandler) -> Self
  @discardableResult
  public func cacheResponse(using handler: any LivingMapSDK.CachedResponseHandler) -> Self
  @discardableResult
  public func cURLDescription(on queue: Dispatch.DispatchQueue, calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func cURLDescription(calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func onURLRequestCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLRequest) -> Swift.Void) -> Self
  @discardableResult
  public func onURLSessionTaskCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLSessionTask) -> Swift.Void) -> Self
  @objc deinit
}
extension LivingMapSDK.Request : Swift.Equatable {
  public static func == (lhs: LivingMapSDK.Request, rhs: LivingMapSDK.Request) -> Swift.Bool
}
extension LivingMapSDK.Request : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Request : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LivingMapSDK.Request {
  public func cURLDescription() -> Swift.String
}
public protocol RequestDelegate : AnyObject {
  var sessionConfiguration: Foundation.URLSessionConfiguration { get }
  var startImmediately: Swift.Bool { get }
  func cleanup(after request: LivingMapSDK.Request)
  func retryResult(for request: LivingMapSDK.Request, dueTo error: LivingMapSDK.AFError, completion: @escaping (LivingMapSDK.RetryResult) -> Swift.Void)
  func retryRequest(_ request: LivingMapSDK.Request, withDelay timeDelay: Foundation.TimeInterval?)
}
@_hasMissingDesignatedInitializers public class DataRequest : LivingMapSDK.Request {
  final public let convertible: any LivingMapSDK.URLRequestConvertible
  public var data: Foundation.Data? {
    get
  }
  @discardableResult
  public func validate(_ validation: @escaping LivingMapSDK.DataRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DataStreamRequest : LivingMapSDK.Request {
  public typealias Handler<Success, Failure> = (LivingMapSDK.DataStreamRequest.Stream<Success, Failure>) throws -> Swift.Void where Failure : Swift.Error
  public struct Stream<Success, Failure> where Failure : Swift.Error {
    public let event: LivingMapSDK.DataStreamRequest.Event<Success, Failure>
    public let token: LivingMapSDK.DataStreamRequest.CancellationToken
    public func cancel()
  }
  public enum Event<Success, Failure> where Failure : Swift.Error {
    case stream(Swift.Result<Success, Failure>)
    case complete(LivingMapSDK.DataStreamRequest.Completion)
  }
  public struct Completion {
    public let request: Foundation.URLRequest?
    public let response: Foundation.HTTPURLResponse?
    public let metrics: Foundation.URLSessionTaskMetrics?
    public let error: LivingMapSDK.AFError?
  }
  public struct CancellationToken {
    public func cancel()
  }
  final public let convertible: any LivingMapSDK.URLRequestConvertible
  final public let automaticallyCancelOnStreamError: Swift.Bool
  @discardableResult
  final public func validate(_ validation: @escaping LivingMapSDK.DataStreamRequest.Validation) -> Self
  final public func asInputStream(bufferSize: Swift.Int = 1024) -> Foundation.InputStream?
  @objc deinit
}
extension LivingMapSDK.DataStreamRequest.Stream {
  public var result: Swift.Result<Success, Failure>? {
    get
  }
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public var completion: LivingMapSDK.DataStreamRequest.Completion? {
    get
  }
}
@_hasMissingDesignatedInitializers public class DownloadRequest : LivingMapSDK.Request {
  public struct Options : Swift.OptionSet {
    public static let createIntermediateDirectories: LivingMapSDK.DownloadRequest.Options
    public static let removePreviousFile: LivingMapSDK.DownloadRequest.Options
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias ArrayLiteralElement = LivingMapSDK.DownloadRequest.Options
    public typealias Element = LivingMapSDK.DownloadRequest.Options
    public typealias RawValue = Swift.Int
  }
  public typealias Destination = (_ temporaryURL: Foundation.URL, _ response: Foundation.HTTPURLResponse) -> (destinationURL: Foundation.URL, options: LivingMapSDK.DownloadRequest.Options)
  public class func suggestedDownloadDestination(for directory: Foundation.FileManager.SearchPathDirectory = .documentDirectory, in domain: Foundation.FileManager.SearchPathDomainMask = .userDomainMask, options: LivingMapSDK.DownloadRequest.Options = []) -> LivingMapSDK.DownloadRequest.Destination
  public enum Downloadable {
    case request(any LivingMapSDK.URLRequestConvertible)
    case resumeData(Foundation.Data)
  }
  public var resumeData: Foundation.Data? {
    get
  }
  public var fileURL: Foundation.URL? {
    get
  }
  final public let downloadable: LivingMapSDK.DownloadRequest.Downloadable
  public func task(forResumeData data: Foundation.Data, using session: Foundation.URLSession) -> Foundation.URLSessionTask
  @discardableResult
  override public func cancel() -> Self
  @discardableResult
  public func cancel(producingResumeData shouldProduceResumeData: Swift.Bool) -> Self
  @discardableResult
  public func cancel(byProducingResumeData completionHandler: @escaping (_ data: Foundation.Data?) -> Swift.Void) -> Self
  @discardableResult
  public func validate(_ validation: @escaping LivingMapSDK.DownloadRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers public class UploadRequest : LivingMapSDK.DataRequest {
  public enum Uploadable {
    case data(Foundation.Data)
    case file(Foundation.URL, shouldRemove: Swift.Bool)
    case stream(Foundation.InputStream)
  }
  final public let upload: any LivingMapSDK.UploadableConvertible
  final public let fileManager: Foundation.FileManager
  public var uploadable: LivingMapSDK.UploadRequest.Uploadable?
  public func cleanup()
  @objc deinit
}
public protocol UploadableConvertible {
  func createUploadable() throws -> LivingMapSDK.UploadRequest.Uploadable
}
extension LivingMapSDK.UploadRequest.Uploadable : LivingMapSDK.UploadableConvertible {
  public func createUploadable() throws -> LivingMapSDK.UploadRequest.Uploadable
}
public protocol UploadConvertible : LivingMapSDK.URLRequestConvertible, LivingMapSDK.UploadableConvertible {
}
public enum AFError : Swift.Error {
  public enum MultipartEncodingFailureReason {
    case bodyPartURLInvalid(url: Foundation.URL)
    case bodyPartFilenameInvalid(in: Foundation.URL)
    case bodyPartFileNotReachable(at: Foundation.URL)
    case bodyPartFileNotReachableWithError(atURL: Foundation.URL, error: any Swift.Error)
    case bodyPartFileIsDirectory(at: Foundation.URL)
    case bodyPartFileSizeNotAvailable(at: Foundation.URL)
    case bodyPartFileSizeQueryFailedWithError(forURL: Foundation.URL, error: any Swift.Error)
    case bodyPartInputStreamCreationFailed(for: Foundation.URL)
    case outputStreamCreationFailed(for: Foundation.URL)
    case outputStreamFileAlreadyExists(at: Foundation.URL)
    case outputStreamURLInvalid(url: Foundation.URL)
    case outputStreamWriteFailed(error: any Swift.Error)
    case inputStreamReadFailed(error: any Swift.Error)
  }
  public struct UnexpectedInputStreamLength : Swift.Error {
    public var bytesExpected: Swift.UInt64
    public var bytesRead: Swift.UInt64
  }
  public enum ParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: any Swift.Error)
    case customEncodingFailed(error: any Swift.Error)
  }
  public enum ParameterEncoderFailureReason {
    public enum RequiredComponent {
      case url
      case httpMethod(rawValue: Swift.String)
    }
    case missingRequiredComponent(LivingMapSDK.AFError.ParameterEncoderFailureReason.RequiredComponent)
    case encoderFailed(error: any Swift.Error)
  }
  public enum ResponseValidationFailureReason {
    case dataFileNil
    case dataFileReadFailed(at: Foundation.URL)
    case missingContentType(acceptableContentTypes: [Swift.String])
    case unacceptableContentType(acceptableContentTypes: [Swift.String], responseContentType: Swift.String)
    case unacceptableStatusCode(code: Swift.Int)
    case customValidationFailed(error: any Swift.Error)
  }
  public enum ResponseSerializationFailureReason {
    case inputDataNilOrZeroLength
    case inputFileNil
    case inputFileReadFailed(at: Foundation.URL)
    case stringSerializationFailed(encoding: Swift.String.Encoding)
    case jsonSerializationFailed(error: any Swift.Error)
    case decodingFailed(error: any Swift.Error)
    case customSerializationFailed(error: any Swift.Error)
    case invalidEmptyResponse(type: Swift.String)
  }
  public enum ServerTrustFailureReason {
    public struct Output {
      public let host: Swift.String
      public let trust: Security.SecTrust
      public let status: Darwin.OSStatus
      public let result: Security.SecTrustResultType
    }
    case noRequiredEvaluator(host: Swift.String)
    case noCertificatesFound
    case noPublicKeysFound
    case policyApplicationFailed(trust: Security.SecTrust, policy: Security.SecPolicy, status: Darwin.OSStatus)
    case settingAnchorCertificatesFailed(status: Darwin.OSStatus, certificates: [Security.SecCertificate])
    case revocationPolicyCreationFailed
    case trustEvaluationFailed(error: (any Swift.Error)?)
    case defaultEvaluationFailed(output: LivingMapSDK.AFError.ServerTrustFailureReason.Output)
    case hostValidationFailed(output: LivingMapSDK.AFError.ServerTrustFailureReason.Output)
    case revocationCheckFailed(output: LivingMapSDK.AFError.ServerTrustFailureReason.Output, options: LivingMapSDK.RevocationTrustEvaluator.Options)
    case certificatePinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedCertificates: [Security.SecCertificate], serverCertificates: [Security.SecCertificate])
    case publicKeyPinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedKeys: [Security.SecKey], serverKeys: [Security.SecKey])
    case customEvaluationFailed(error: any Swift.Error)
  }
  public enum URLRequestValidationFailureReason {
    case bodyDataInGETRequest(Foundation.Data)
  }
  case createUploadableFailed(error: any Swift.Error)
  case createURLRequestFailed(error: any Swift.Error)
  case downloadedFileMoveFailed(error: any Swift.Error, source: Foundation.URL, destination: Foundation.URL)
  case explicitlyCancelled
  case invalidURL(url: any LivingMapSDK.URLConvertible)
  case multipartEncodingFailed(reason: LivingMapSDK.AFError.MultipartEncodingFailureReason)
  case parameterEncodingFailed(reason: LivingMapSDK.AFError.ParameterEncodingFailureReason)
  case parameterEncoderFailed(reason: LivingMapSDK.AFError.ParameterEncoderFailureReason)
  case requestAdaptationFailed(error: any Swift.Error)
  case requestRetryFailed(retryError: any Swift.Error, originalError: any Swift.Error)
  case responseValidationFailed(reason: LivingMapSDK.AFError.ResponseValidationFailureReason)
  case responseSerializationFailed(reason: LivingMapSDK.AFError.ResponseSerializationFailureReason)
  case serverTrustEvaluationFailed(reason: LivingMapSDK.AFError.ServerTrustFailureReason)
  case sessionDeinitialized
  case sessionInvalidated(error: (any Swift.Error)?)
  case sessionTaskFailed(error: any Swift.Error)
  case urlRequestValidationFailed(reason: LivingMapSDK.AFError.URLRequestValidationFailureReason)
}
extension Swift.Error {
  public var asAFError: LivingMapSDK.AFError? {
    get
  }
  public func asAFError(orFailWith message: @autoclosure () -> Swift.String, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> LivingMapSDK.AFError
}
extension LivingMapSDK.AFError {
  public var isSessionDeinitializedError: Swift.Bool {
    get
  }
  public var isSessionInvalidatedError: Swift.Bool {
    get
  }
  public var isExplicitlyCancelledError: Swift.Bool {
    get
  }
  public var isInvalidURLError: Swift.Bool {
    get
  }
  public var isParameterEncodingError: Swift.Bool {
    get
  }
  public var isParameterEncoderError: Swift.Bool {
    get
  }
  public var isMultipartEncodingError: Swift.Bool {
    get
  }
  public var isRequestAdaptationError: Swift.Bool {
    get
  }
  public var isResponseValidationError: Swift.Bool {
    get
  }
  public var isResponseSerializationError: Swift.Bool {
    get
  }
  public var isServerTrustEvaluationError: Swift.Bool {
    get
  }
  public var isRequestRetryError: Swift.Bool {
    get
  }
  public var isCreateUploadableError: Swift.Bool {
    get
  }
  public var isCreateURLRequestError: Swift.Bool {
    get
  }
  public var isDownloadedFileMoveError: Swift.Bool {
    get
  }
  public var isSessionTaskError: Swift.Bool {
    get
  }
}
extension LivingMapSDK.AFError {
  public var urlConvertible: (any LivingMapSDK.URLConvertible)? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var underlyingError: (any Swift.Error)? {
    get
  }
  public var acceptableContentTypes: [Swift.String]? {
    get
  }
  public var responseContentType: Swift.String? {
    get
  }
  public var responseCode: Swift.Int? {
    get
  }
  public var failedStringEncoding: Swift.String.Encoding? {
    get
  }
  public var sourceURL: Foundation.URL? {
    get
  }
  public var destinationURL: Foundation.URL? {
    get
  }
  public var downloadResumeData: Foundation.Data? {
    get
  }
}
extension LivingMapSDK.AFError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension LivingMapSDK.Message {
  public func serializedData(partial: Swift.Bool = false) throws -> Foundation.Data
  @inlinable public init(serializedData data: Foundation.Data, extensions: (any LivingMapSDK.ExtensionMap)? = nil, partial: Swift.Bool = false, options: LivingMapSDK.BinaryDecodingOptions = BinaryDecodingOptions()) throws {
    self.init()
    try merge(contiguousBytes: data, extensions: extensions, partial: partial, options: options)
  }
  @inlinable public init<Bytes>(contiguousBytes bytes: Bytes, extensions: (any LivingMapSDK.ExtensionMap)? = nil, partial: Swift.Bool = false, options: LivingMapSDK.BinaryDecodingOptions = BinaryDecodingOptions()) throws where Bytes : Foundation.ContiguousBytes {
    self.init()
    try merge(contiguousBytes: bytes, extensions: extensions, partial: partial, options: options)
  }
  @inlinable public mutating func merge(serializedData data: Foundation.Data, extensions: (any LivingMapSDK.ExtensionMap)? = nil, partial: Swift.Bool = false, options: LivingMapSDK.BinaryDecodingOptions = BinaryDecodingOptions()) throws {
    try merge(contiguousBytes: data, extensions: extensions, partial: partial, options: options)
  }
  @inlinable public mutating func merge<Bytes>(contiguousBytes bytes: Bytes, extensions: (any LivingMapSDK.ExtensionMap)? = nil, partial: Swift.Bool = false, options: LivingMapSDK.BinaryDecodingOptions = BinaryDecodingOptions()) throws where Bytes : Foundation.ContiguousBytes {
    try bytes.withUnsafeBytes { (body: UnsafeRawBufferPointer) in
      try _merge(rawBuffer: body, extensions: extensions, partial: partial, options: options)
    }
  }
  @usableFromInline
  internal mutating func _merge(rawBuffer body: Swift.UnsafeRawBufferPointer, extensions: (any LivingMapSDK.ExtensionMap)?, partial: Swift.Bool, options: LivingMapSDK.BinaryDecodingOptions) throws
}
public struct ManifestCallbacks {
  public let onManifestFailure: ((LivingMapSDK.LivingMapError) throws -> Swift.Void)?
  public let onCacheCompletion: ((LivingMapSDK.CacheManifest) -> Swift.Void)?
  public let onManifestRetrieval: ((LivingMapSDK.CacheManifest) -> Swift.Void)?
  public let cacheProgressUpdate: ((LivingMapSDK.CacheProgress) -> Swift.Void)?
  public init(onManifestRetrieval: ((LivingMapSDK.CacheManifest) -> Swift.Void)? = nil, onManifestFailure: ((LivingMapSDK.LivingMapError) throws -> Swift.Void)? = nil, onCacheCompletion: ((LivingMapSDK.CacheManifest) -> Swift.Void)? = nil, cacheProgressUpdate: ((LivingMapSDK.CacheProgress) -> Swift.Void)? = nil)
}
public struct Google_Protobuf_Duration {
  public var seconds: Swift.Int64
  public var nanos: Swift.Int32
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
extension LivingMapSDK.Google_Protobuf_Duration : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Duration : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_Duration, rhs: LivingMapSDK.Google_Protobuf_Duration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Message {
  public init(unpackingAny: LivingMapSDK.Google_Protobuf_Any, extensions: (any LivingMapSDK.ExtensionMap)? = nil, options: LivingMapSDK.BinaryDecodingOptions = BinaryDecodingOptions()) throws
}
@frozen public struct AnyCodable : Swift.Codable {
  public let value: Any
  public init<T>(_ value: T?)
}
extension LivingMapSDK.AnyCodable : LivingMapSDK._AnyEncodable, LivingMapSDK._AnyDecodable {
}
extension LivingMapSDK.AnyCodable : Swift.Equatable {
  public static func == (lhs: LivingMapSDK.AnyCodable, rhs: LivingMapSDK.AnyCodable) -> Swift.Bool
}
extension LivingMapSDK.AnyCodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LivingMapSDK.AnyCodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension LivingMapSDK.AnyCodable : Swift.ExpressibleByNilLiteral {
}
extension LivingMapSDK.AnyCodable : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
}
extension LivingMapSDK.AnyCodable : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
}
extension LivingMapSDK.AnyCodable : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
}
extension LivingMapSDK.AnyCodable : Swift.ExpressibleByStringLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension LivingMapSDK.AnyCodable : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Any
}
extension LivingMapSDK.AnyCodable : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.AnyHashable
  public typealias Value = Any
}
public struct Google_Protobuf_Timestamp {
  public var seconds: Swift.Int64
  public var nanos: Swift.Int32
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
extension LivingMapSDK.Google_Protobuf_Timestamp : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Timestamp : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_Timestamp, rhs: LivingMapSDK.Google_Protobuf_Timestamp) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class LivingMapErrorHandler {
  public static func logError(error: Foundation.NSError)
  @objc deinit
}
extension LivingMapSDK.Message {
  public static func jsonString<C>(from collection: C, options: LivingMapSDK.JSONEncodingOptions = JSONEncodingOptions()) throws -> Swift.String where Self == C.Element, C : Swift.Collection
  public static func jsonUTF8Data<C>(from collection: C, options: LivingMapSDK.JSONEncodingOptions = JSONEncodingOptions()) throws -> Foundation.Data where Self == C.Element, C : Swift.Collection
  public static func array(fromJSONString jsonString: Swift.String, options: LivingMapSDK.JSONDecodingOptions = JSONDecodingOptions()) throws -> [Self]
  public static func array(fromJSONString jsonString: Swift.String, extensions: any LivingMapSDK.ExtensionMap = SimpleExtensionMap(), options: LivingMapSDK.JSONDecodingOptions = JSONDecodingOptions()) throws -> [Self]
  public static func array(fromJSONUTF8Data jsonUTF8Data: Foundation.Data, options: LivingMapSDK.JSONDecodingOptions = JSONDecodingOptions()) throws -> [Self]
  public static func array(fromJSONUTF8Data jsonUTF8Data: Foundation.Data, extensions: any LivingMapSDK.ExtensionMap = SimpleExtensionMap(), options: LivingMapSDK.JSONDecodingOptions = JSONDecodingOptions()) throws -> [Self]
}
public typealias AFDataResponse<Success> = LivingMapSDK.DataResponse<Success, LivingMapSDK.AFError>
public typealias AFDownloadResponse<Success> = LivingMapSDK.DownloadResponse<Success, LivingMapSDK.AFError>
public struct DataResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension LivingMapSDK.DataResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension LivingMapSDK.DataResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> LivingMapSDK.DataResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> LivingMapSDK.DataResponse<NewSuccess, any Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> LivingMapSDK.DataResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> LivingMapSDK.DataResponse<Success, any Swift.Error> where NewFailure : Swift.Error
}
public struct DownloadResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let fileURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, resumeData: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension LivingMapSDK.DownloadResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension LivingMapSDK.DownloadResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> LivingMapSDK.DownloadResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> LivingMapSDK.DownloadResponse<NewSuccess, any Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> LivingMapSDK.DownloadResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> LivingMapSDK.DownloadResponse<Success, any Swift.Error> where NewFailure : Swift.Error
}
public struct UnknownStorage : Swift.Equatable {
  public var data: Foundation.Data {
    get
  }
  public init()
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (a: LivingMapSDK.UnknownStorage, b: LivingMapSDK.UnknownStorage) -> Swift.Bool
}
public protocol Visitor {
  mutating func visitSingularFloatField(value: Swift.Float, fieldNumber: Swift.Int) throws
  mutating func visitSingularDoubleField(value: Swift.Double, fieldNumber: Swift.Int) throws
  mutating func visitSingularInt32Field(value: Swift.Int32, fieldNumber: Swift.Int) throws
  mutating func visitSingularInt64Field(value: Swift.Int64, fieldNumber: Swift.Int) throws
  mutating func visitSingularUInt32Field(value: Swift.UInt32, fieldNumber: Swift.Int) throws
  mutating func visitSingularUInt64Field(value: Swift.UInt64, fieldNumber: Swift.Int) throws
  mutating func visitSingularSInt32Field(value: Swift.Int32, fieldNumber: Swift.Int) throws
  mutating func visitSingularSInt64Field(value: Swift.Int64, fieldNumber: Swift.Int) throws
  mutating func visitSingularFixed32Field(value: Swift.UInt32, fieldNumber: Swift.Int) throws
  mutating func visitSingularFixed64Field(value: Swift.UInt64, fieldNumber: Swift.Int) throws
  mutating func visitSingularSFixed32Field(value: Swift.Int32, fieldNumber: Swift.Int) throws
  mutating func visitSingularSFixed64Field(value: Swift.Int64, fieldNumber: Swift.Int) throws
  mutating func visitSingularBoolField(value: Swift.Bool, fieldNumber: Swift.Int) throws
  mutating func visitSingularStringField(value: Swift.String, fieldNumber: Swift.Int) throws
  mutating func visitSingularBytesField(value: Foundation.Data, fieldNumber: Swift.Int) throws
  mutating func visitSingularEnumField<E>(value: E, fieldNumber: Swift.Int) throws where E : LivingMapSDK.Enum
  mutating func visitSingularMessageField<M>(value: M, fieldNumber: Swift.Int) throws where M : LivingMapSDK.Message
  mutating func visitSingularGroupField<G>(value: G, fieldNumber: Swift.Int) throws where G : LivingMapSDK.Message
  mutating func visitRepeatedFloatField(value: [Swift.Float], fieldNumber: Swift.Int) throws
  mutating func visitRepeatedDoubleField(value: [Swift.Double], fieldNumber: Swift.Int) throws
  mutating func visitRepeatedInt32Field(value: [Swift.Int32], fieldNumber: Swift.Int) throws
  mutating func visitRepeatedInt64Field(value: [Swift.Int64], fieldNumber: Swift.Int) throws
  mutating func visitRepeatedUInt32Field(value: [Swift.UInt32], fieldNumber: Swift.Int) throws
  mutating func visitRepeatedUInt64Field(value: [Swift.UInt64], fieldNumber: Swift.Int) throws
  mutating func visitRepeatedSInt32Field(value: [Swift.Int32], fieldNumber: Swift.Int) throws
  mutating func visitRepeatedSInt64Field(value: [Swift.Int64], fieldNumber: Swift.Int) throws
  mutating func visitRepeatedFixed32Field(value: [Swift.UInt32], fieldNumber: Swift.Int) throws
  mutating func visitRepeatedFixed64Field(value: [Swift.UInt64], fieldNumber: Swift.Int) throws
  mutating func visitRepeatedSFixed32Field(value: [Swift.Int32], fieldNumber: Swift.Int) throws
  mutating func visitRepeatedSFixed64Field(value: [Swift.Int64], fieldNumber: Swift.Int) throws
  mutating func visitRepeatedBoolField(value: [Swift.Bool], fieldNumber: Swift.Int) throws
  mutating func visitRepeatedStringField(value: [Swift.String], fieldNumber: Swift.Int) throws
  mutating func visitRepeatedBytesField(value: [Foundation.Data], fieldNumber: Swift.Int) throws
  mutating func visitRepeatedEnumField<E>(value: [E], fieldNumber: Swift.Int) throws where E : LivingMapSDK.Enum
  mutating func visitRepeatedMessageField<M>(value: [M], fieldNumber: Swift.Int) throws where M : LivingMapSDK.Message
  mutating func visitRepeatedGroupField<G>(value: [G], fieldNumber: Swift.Int) throws where G : LivingMapSDK.Message
  mutating func visitPackedFloatField(value: [Swift.Float], fieldNumber: Swift.Int) throws
  mutating func visitPackedDoubleField(value: [Swift.Double], fieldNumber: Swift.Int) throws
  mutating func visitPackedInt32Field(value: [Swift.Int32], fieldNumber: Swift.Int) throws
  mutating func visitPackedInt64Field(value: [Swift.Int64], fieldNumber: Swift.Int) throws
  mutating func visitPackedUInt32Field(value: [Swift.UInt32], fieldNumber: Swift.Int) throws
  mutating func visitPackedUInt64Field(value: [Swift.UInt64], fieldNumber: Swift.Int) throws
  mutating func visitPackedSInt32Field(value: [Swift.Int32], fieldNumber: Swift.Int) throws
  mutating func visitPackedSInt64Field(value: [Swift.Int64], fieldNumber: Swift.Int) throws
  mutating func visitPackedFixed32Field(value: [Swift.UInt32], fieldNumber: Swift.Int) throws
  mutating func visitPackedFixed64Field(value: [Swift.UInt64], fieldNumber: Swift.Int) throws
  mutating func visitPackedSFixed32Field(value: [Swift.Int32], fieldNumber: Swift.Int) throws
  mutating func visitPackedSFixed64Field(value: [Swift.Int64], fieldNumber: Swift.Int) throws
  mutating func visitPackedBoolField(value: [Swift.Bool], fieldNumber: Swift.Int) throws
  mutating func visitPackedEnumField<E>(value: [E], fieldNumber: Swift.Int) throws where E : LivingMapSDK.Enum
  mutating func visitMapField<KeyType, ValueType>(fieldType: LivingMapSDK._ProtobufMap<KeyType, ValueType>.Type, value: LivingMapSDK._ProtobufMap<KeyType, ValueType>.BaseType, fieldNumber: Swift.Int) throws where KeyType : LivingMapSDK.MapKeyType, ValueType : LivingMapSDK.MapValueType
  mutating func visitMapField<KeyType, ValueType>(fieldType: LivingMapSDK._ProtobufEnumMap<KeyType, ValueType>.Type, value: LivingMapSDK._ProtobufEnumMap<KeyType, ValueType>.BaseType, fieldNumber: Swift.Int) throws where KeyType : LivingMapSDK.MapKeyType, ValueType : LivingMapSDK.Enum, ValueType.RawValue == Swift.Int
  mutating func visitMapField<KeyType, ValueType>(fieldType: LivingMapSDK._ProtobufMessageMap<KeyType, ValueType>.Type, value: LivingMapSDK._ProtobufMessageMap<KeyType, ValueType>.BaseType, fieldNumber: Swift.Int) throws where KeyType : LivingMapSDK.MapKeyType, ValueType : LivingMapSDK.Message, ValueType : Swift.Hashable
  mutating func visitExtensionFields(fields: LivingMapSDK.ExtensionFieldValueSet, start: Swift.Int, end: Swift.Int) throws
  mutating func visitExtensionFieldsAsMessageSet(fields: LivingMapSDK.ExtensionFieldValueSet, start: Swift.Int, end: Swift.Int) throws
  mutating func visitUnknown(bytes: Foundation.Data) throws
}
extension LivingMapSDK.Visitor {
  public mutating func visitSingularFloatField(value: Swift.Float, fieldNumber: Swift.Int) throws
  public mutating func visitSingularInt32Field(value: Swift.Int32, fieldNumber: Swift.Int) throws
  public mutating func visitSingularUInt32Field(value: Swift.UInt32, fieldNumber: Swift.Int) throws
  public mutating func visitSingularSInt32Field(value: Swift.Int32, fieldNumber: Swift.Int) throws
  public mutating func visitSingularSInt64Field(value: Swift.Int64, fieldNumber: Swift.Int) throws
  public mutating func visitSingularFixed32Field(value: Swift.UInt32, fieldNumber: Swift.Int) throws
  public mutating func visitSingularFixed64Field(value: Swift.UInt64, fieldNumber: Swift.Int) throws
  public mutating func visitSingularSFixed32Field(value: Swift.Int32, fieldNumber: Swift.Int) throws
  public mutating func visitSingularSFixed64Field(value: Swift.Int64, fieldNumber: Swift.Int) throws
  public mutating func visitRepeatedFloatField(value: [Swift.Float], fieldNumber: Swift.Int) throws
  public mutating func visitRepeatedDoubleField(value: [Swift.Double], fieldNumber: Swift.Int) throws
  public mutating func visitRepeatedInt32Field(value: [Swift.Int32], fieldNumber: Swift.Int) throws
  public mutating func visitRepeatedInt64Field(value: [Swift.Int64], fieldNumber: Swift.Int) throws
  public mutating func visitRepeatedUInt32Field(value: [Swift.UInt32], fieldNumber: Swift.Int) throws
  public mutating func visitRepeatedUInt64Field(value: [Swift.UInt64], fieldNumber: Swift.Int) throws
  public mutating func visitRepeatedSInt32Field(value: [Swift.Int32], fieldNumber: Swift.Int) throws
  public mutating func visitRepeatedSInt64Field(value: [Swift.Int64], fieldNumber: Swift.Int) throws
  public mutating func visitRepeatedFixed32Field(value: [Swift.UInt32], fieldNumber: Swift.Int) throws
  public mutating func visitRepeatedFixed64Field(value: [Swift.UInt64], fieldNumber: Swift.Int) throws
  public mutating func visitRepeatedSFixed32Field(value: [Swift.Int32], fieldNumber: Swift.Int) throws
  public mutating func visitRepeatedSFixed64Field(value: [Swift.Int64], fieldNumber: Swift.Int) throws
  public mutating func visitRepeatedBoolField(value: [Swift.Bool], fieldNumber: Swift.Int) throws
  public mutating func visitRepeatedStringField(value: [Swift.String], fieldNumber: Swift.Int) throws
  public mutating func visitRepeatedBytesField(value: [Foundation.Data], fieldNumber: Swift.Int) throws
  public mutating func visitRepeatedEnumField<E>(value: [E], fieldNumber: Swift.Int) throws where E : LivingMapSDK.Enum
  public mutating func visitRepeatedMessageField<M>(value: [M], fieldNumber: Swift.Int) throws where M : LivingMapSDK.Message
  public mutating func visitRepeatedGroupField<G>(value: [G], fieldNumber: Swift.Int) throws where G : LivingMapSDK.Message
  public mutating func visitPackedFloatField(value: [Swift.Float], fieldNumber: Swift.Int) throws
  public mutating func visitPackedDoubleField(value: [Swift.Double], fieldNumber: Swift.Int) throws
  public mutating func visitPackedInt32Field(value: [Swift.Int32], fieldNumber: Swift.Int) throws
  public mutating func visitPackedInt64Field(value: [Swift.Int64], fieldNumber: Swift.Int) throws
  public mutating func visitPackedUInt32Field(value: [Swift.UInt32], fieldNumber: Swift.Int) throws
  public mutating func visitPackedUInt64Field(value: [Swift.UInt64], fieldNumber: Swift.Int) throws
  public mutating func visitPackedSInt32Field(value: [Swift.Int32], fieldNumber: Swift.Int) throws
  public mutating func visitPackedSInt64Field(value: [Swift.Int64], fieldNumber: Swift.Int) throws
  public mutating func visitPackedFixed32Field(value: [Swift.UInt32], fieldNumber: Swift.Int) throws
  public mutating func visitPackedFixed64Field(value: [Swift.UInt64], fieldNumber: Swift.Int) throws
  public mutating func visitPackedSFixed32Field(value: [Swift.Int32], fieldNumber: Swift.Int) throws
  public mutating func visitPackedSFixed64Field(value: [Swift.Int64], fieldNumber: Swift.Int) throws
  public mutating func visitPackedBoolField(value: [Swift.Bool], fieldNumber: Swift.Int) throws
  public mutating func visitPackedEnumField<E>(value: [E], fieldNumber: Swift.Int) throws where E : LivingMapSDK.Enum
  public mutating func visitSingularGroupField<G>(value: G, fieldNumber: Swift.Int) throws where G : LivingMapSDK.Message
  public mutating func visitExtensionFieldsAsMessageSet(fields: LivingMapSDK.ExtensionFieldValueSet, start: Swift.Int, end: Swift.Int) throws
  public mutating func visitExtensionFields(fields: LivingMapSDK.ExtensionFieldValueSet, start: Swift.Int, end: Swift.Int) throws
}
public struct TextFormatEncodingOptions {
  public var printUnknownFields: Swift.Bool
  public init()
}
@_hasMissingDesignatedInitializers public class LMLocation : Swift.Codable, Foundation.NSCopying {
  public var x: Swift.Double
  public var y: Swift.Double
  public var floor: Swift.Int32
  public var subFloor: Swift.Float?
  public var uuidFloor: Swift.String?
  public var heading: Swift.Double
  public var accuracy: Swift.Double
  @objc public var timestamp: Swift.Double
  public var coordRefSystem: LivingMapSDK.LMLocation.CoordinateReferenceSystem
  public var locationSource: LivingMapSDK.LMLocation.LocationSource?
  public var gyroHeading: Swift.Double?
  public var deviceId: Swift.String?
  public var journeyId: Swift.Int?
  public init(x: Swift.Double, y: Swift.Double, floor: Swift.Int32 = -1, subFloor: Swift.Float? = -1, uuidFloor: Swift.String? = nil, heading: Swift.Double = -1, accuracy: Swift.Double = 10, timestamp: Swift.Double, coordRefSystem: LivingMapSDK.LMLocation.CoordinateReferenceSystem = LMLocation.CoordinateReferenceSystem.UNDEFINED, locationSource: LivingMapSDK.LMLocation.LocationSource? = nil)
  public func toString() -> Swift.String
  @objc public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  public func equals(location: LivingMapSDK.LMLocation) -> Swift.Bool
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
extension LivingMapSDK.LMLocation {
  public enum CoordinateReferenceSystem : Swift.Int32, Swift.Codable {
    case UNDEFINED
    case EPSG_00000
    case EPSG_4326
    public init?(rawValue: Swift.Int32)
    public typealias RawValue = Swift.Int32
    public var rawValue: Swift.Int32 {
      get
    }
  }
  public enum LocationSource : Swift.String, Swift.Codable {
    case beacon
    case indoorCoreLocation
    case outdoorCoreLocation
    case commonPositioningLibrary
    case pedestrianDeadReckoning
    case floorChange
    case userDefinedLocation
    case landmark
    case checkPointPDR
    case gyroPDR
    case routeInitialLocation
    public func toPositioningMethod() -> LivingMapSDK.CPLPositioningMethod
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum LocationError : Swift.Error {
    case invalidCRSConversion
    public static func == (a: LivingMapSDK.LMLocation.LocationError, b: LivingMapSDK.LMLocation.LocationError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public struct RequestAdapterState {
  public let requestID: Foundation.UUID
  public let session: LivingMapSDK.Session
}
public protocol RequestAdapter {
  func adapt(_ urlRequest: Foundation.URLRequest, for session: LivingMapSDK.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  func adapt(_ urlRequest: Foundation.URLRequest, using state: LivingMapSDK.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
}
extension LivingMapSDK.RequestAdapter {
  public func adapt(_ urlRequest: Foundation.URLRequest, using state: LivingMapSDK.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
}
public enum RetryResult {
  case retry
  case retryWithDelay(Foundation.TimeInterval)
  case doNotRetry
  case doNotRetryWithError(any Swift.Error)
}
public protocol RequestRetrier {
  func retry(_ request: LivingMapSDK.Request, for session: LivingMapSDK.Session, dueTo error: any Swift.Error, completion: @escaping (LivingMapSDK.RetryResult) -> Swift.Void)
}
public protocol RequestInterceptor : LivingMapSDK.RequestAdapter, LivingMapSDK.RequestRetrier {
}
extension LivingMapSDK.RequestInterceptor {
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: LivingMapSDK.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  public func retry(_ request: LivingMapSDK.Request, for session: LivingMapSDK.Session, dueTo error: any Swift.Error, completion: @escaping (LivingMapSDK.RetryResult) -> Swift.Void)
}
public typealias AdaptHandler = (Foundation.URLRequest, LivingMapSDK.Session, _ completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void) -> Swift.Void
public typealias RetryHandler = (LivingMapSDK.Request, LivingMapSDK.Session, any Swift.Error, _ completion: @escaping (LivingMapSDK.RetryResult) -> Swift.Void) -> Swift.Void
open class Adapter : LivingMapSDK.RequestInterceptor {
  public init(_ adaptHandler: @escaping LivingMapSDK.AdaptHandler)
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: LivingMapSDK.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  open func adapt(_ urlRequest: Foundation.URLRequest, using state: LivingMapSDK.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  @objc deinit
}
extension LivingMapSDK.RequestAdapter where Self == LivingMapSDK.Adapter {
  public static func adapter(using closure: @escaping LivingMapSDK.AdaptHandler) -> LivingMapSDK.Adapter
}
open class Retrier : LivingMapSDK.RequestInterceptor {
  public init(_ retryHandler: @escaping LivingMapSDK.RetryHandler)
  open func retry(_ request: LivingMapSDK.Request, for session: LivingMapSDK.Session, dueTo error: any Swift.Error, completion: @escaping (LivingMapSDK.RetryResult) -> Swift.Void)
  @objc deinit
}
extension LivingMapSDK.RequestRetrier where Self == LivingMapSDK.Retrier {
  public static func retrier(using closure: @escaping LivingMapSDK.RetryHandler) -> LivingMapSDK.Retrier
}
open class Interceptor : LivingMapSDK.RequestInterceptor {
  final public let adapters: [any LivingMapSDK.RequestAdapter]
  final public let retriers: [any LivingMapSDK.RequestRetrier]
  public init(adaptHandler: @escaping LivingMapSDK.AdaptHandler, retryHandler: @escaping LivingMapSDK.RetryHandler)
  public init(adapter: any LivingMapSDK.RequestAdapter, retrier: any LivingMapSDK.RequestRetrier)
  public init(adapters: [any LivingMapSDK.RequestAdapter] = [], retriers: [any LivingMapSDK.RequestRetrier] = [], interceptors: [any LivingMapSDK.RequestInterceptor] = [])
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: LivingMapSDK.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  open func adapt(_ urlRequest: Foundation.URLRequest, using state: LivingMapSDK.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  open func retry(_ request: LivingMapSDK.Request, for session: LivingMapSDK.Session, dueTo error: any Swift.Error, completion: @escaping (LivingMapSDK.RetryResult) -> Swift.Void)
  @objc deinit
}
extension LivingMapSDK.RequestInterceptor where Self == LivingMapSDK.Interceptor {
  public static func interceptor(adapter: @escaping LivingMapSDK.AdaptHandler, retrier: @escaping LivingMapSDK.RetryHandler) -> LivingMapSDK.Interceptor
  public static func interceptor(adapter: any LivingMapSDK.RequestAdapter, retrier: any LivingMapSDK.RequestRetrier) -> LivingMapSDK.Interceptor
  public static func interceptor(adapters: [any LivingMapSDK.RequestAdapter] = [], retriers: [any LivingMapSDK.RequestRetrier] = [], interceptors: [any LivingMapSDK.RequestInterceptor] = []) -> LivingMapSDK.Interceptor
}
public struct TextFormatDecodingOptions {
  public var messageDepthLimit: Swift.Int
  public init()
}
public protocol EventMonitor {
  var queue: Dispatch.DispatchQueue { get }
  func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  func request(_ request: LivingMapSDK.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: LivingMapSDK.Request, didFailToCreateURLRequestWithError error: LivingMapSDK.AFError)
  func request(_ request: LivingMapSDK.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  func request(_ request: LivingMapSDK.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: LivingMapSDK.AFError)
  func request(_ request: LivingMapSDK.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: LivingMapSDK.Request, didCreateTask task: Foundation.URLSessionTask)
  func request(_ request: LivingMapSDK.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  func request(_ request: LivingMapSDK.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: LivingMapSDK.AFError)
  func request(_ request: LivingMapSDK.Request, didCompleteTask task: Foundation.URLSessionTask, with error: LivingMapSDK.AFError?)
  func requestIsRetrying(_ request: LivingMapSDK.Request)
  func requestDidFinish(_ request: LivingMapSDK.Request)
  func requestDidResume(_ request: LivingMapSDK.Request)
  func request(_ request: LivingMapSDK.Request, didResumeTask task: Foundation.URLSessionTask)
  func requestDidSuspend(_ request: LivingMapSDK.Request)
  func request(_ request: LivingMapSDK.Request, didSuspendTask task: Foundation.URLSessionTask)
  func requestDidCancel(_ request: LivingMapSDK.Request)
  func request(_ request: LivingMapSDK.Request, didCancelTask task: Foundation.URLSessionTask)
  func request(_ request: LivingMapSDK.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: LivingMapSDK.Request.ValidationResult)
  func request(_ request: LivingMapSDK.DataRequest, didParseResponse response: LivingMapSDK.DataResponse<Foundation.Data?, LivingMapSDK.AFError>)
  func request<Value>(_ request: LivingMapSDK.DataRequest, didParseResponse response: LivingMapSDK.DataResponse<Value, LivingMapSDK.AFError>)
  func request(_ request: LivingMapSDK.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: LivingMapSDK.Request.ValidationResult)
  func request<Value>(_ request: LivingMapSDK.DataStreamRequest, didParseStream result: Swift.Result<Value, LivingMapSDK.AFError>)
  func request(_ request: LivingMapSDK.UploadRequest, didCreateUploadable uploadable: LivingMapSDK.UploadRequest.Uploadable)
  func request(_ request: LivingMapSDK.UploadRequest, didFailToCreateUploadableWithError error: LivingMapSDK.AFError)
  func request(_ request: LivingMapSDK.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  func request(_ request: LivingMapSDK.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, LivingMapSDK.AFError>)
  func request(_ request: LivingMapSDK.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  func request(_ request: LivingMapSDK.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: LivingMapSDK.Request.ValidationResult)
  func request(_ request: LivingMapSDK.DownloadRequest, didParseResponse response: LivingMapSDK.DownloadResponse<Foundation.URL?, LivingMapSDK.AFError>)
  func request<Value>(_ request: LivingMapSDK.DownloadRequest, didParseResponse response: LivingMapSDK.DownloadResponse<Value, LivingMapSDK.AFError>)
}
extension LivingMapSDK.EventMonitor {
  public var queue: Dispatch.DispatchQueue {
    get
  }
  public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  public func request(_ request: LivingMapSDK.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: LivingMapSDK.Request, didFailToCreateURLRequestWithError error: LivingMapSDK.AFError)
  public func request(_ request: LivingMapSDK.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  public func request(_ request: LivingMapSDK.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: LivingMapSDK.AFError)
  public func request(_ request: LivingMapSDK.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: LivingMapSDK.Request, didCreateTask task: Foundation.URLSessionTask)
  public func request(_ request: LivingMapSDK.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  public func request(_ request: LivingMapSDK.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: LivingMapSDK.AFError)
  public func request(_ request: LivingMapSDK.Request, didCompleteTask task: Foundation.URLSessionTask, with error: LivingMapSDK.AFError?)
  public func requestIsRetrying(_ request: LivingMapSDK.Request)
  public func requestDidFinish(_ request: LivingMapSDK.Request)
  public func requestDidResume(_ request: LivingMapSDK.Request)
  public func request(_ request: LivingMapSDK.Request, didResumeTask task: Foundation.URLSessionTask)
  public func requestDidSuspend(_ request: LivingMapSDK.Request)
  public func request(_ request: LivingMapSDK.Request, didSuspendTask task: Foundation.URLSessionTask)
  public func requestDidCancel(_ request: LivingMapSDK.Request)
  public func request(_ request: LivingMapSDK.Request, didCancelTask task: Foundation.URLSessionTask)
  public func request(_ request: LivingMapSDK.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: LivingMapSDK.Request.ValidationResult)
  public func request(_ request: LivingMapSDK.DataRequest, didParseResponse response: LivingMapSDK.DataResponse<Foundation.Data?, LivingMapSDK.AFError>)
  public func request<Value>(_ request: LivingMapSDK.DataRequest, didParseResponse response: LivingMapSDK.DataResponse<Value, LivingMapSDK.AFError>)
  public func request(_ request: LivingMapSDK.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: LivingMapSDK.Request.ValidationResult)
  public func request<Value>(_ request: LivingMapSDK.DataStreamRequest, didParseStream result: Swift.Result<Value, LivingMapSDK.AFError>)
  public func request(_ request: LivingMapSDK.UploadRequest, didCreateUploadable uploadable: LivingMapSDK.UploadRequest.Uploadable)
  public func request(_ request: LivingMapSDK.UploadRequest, didFailToCreateUploadableWithError error: LivingMapSDK.AFError)
  public func request(_ request: LivingMapSDK.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  public func request(_ request: LivingMapSDK.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, LivingMapSDK.AFError>)
  public func request(_ request: LivingMapSDK.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  public func request(_ request: LivingMapSDK.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: LivingMapSDK.Request.ValidationResult)
  public func request(_ request: LivingMapSDK.DownloadRequest, didParseResponse response: LivingMapSDK.DownloadResponse<Foundation.URL?, LivingMapSDK.AFError>)
  public func request<Value>(_ request: LivingMapSDK.DownloadRequest, didParseResponse response: LivingMapSDK.DownloadResponse<Value, LivingMapSDK.AFError>)
}
@_hasMissingDesignatedInitializers final public class CompositeEventMonitor : LivingMapSDK.EventMonitor {
  final public let queue: Dispatch.DispatchQueue
  final public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  final public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  final public func request(_ request: LivingMapSDK.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: LivingMapSDK.Request, didFailToCreateURLRequestWithError error: LivingMapSDK.AFError)
  final public func request(_ request: LivingMapSDK.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  final public func request(_ request: LivingMapSDK.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: LivingMapSDK.AFError)
  final public func request(_ request: LivingMapSDK.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: LivingMapSDK.Request, didCreateTask task: Foundation.URLSessionTask)
  final public func request(_ request: LivingMapSDK.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  final public func request(_ request: LivingMapSDK.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: LivingMapSDK.AFError)
  final public func request(_ request: LivingMapSDK.Request, didCompleteTask task: Foundation.URLSessionTask, with error: LivingMapSDK.AFError?)
  final public func requestIsRetrying(_ request: LivingMapSDK.Request)
  final public func requestDidFinish(_ request: LivingMapSDK.Request)
  final public func requestDidResume(_ request: LivingMapSDK.Request)
  final public func request(_ request: LivingMapSDK.Request, didResumeTask task: Foundation.URLSessionTask)
  final public func requestDidSuspend(_ request: LivingMapSDK.Request)
  final public func request(_ request: LivingMapSDK.Request, didSuspendTask task: Foundation.URLSessionTask)
  final public func requestDidCancel(_ request: LivingMapSDK.Request)
  final public func request(_ request: LivingMapSDK.Request, didCancelTask task: Foundation.URLSessionTask)
  final public func request(_ request: LivingMapSDK.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: LivingMapSDK.Request.ValidationResult)
  final public func request(_ request: LivingMapSDK.DataRequest, didParseResponse response: LivingMapSDK.DataResponse<Foundation.Data?, LivingMapSDK.AFError>)
  final public func request<Value>(_ request: LivingMapSDK.DataRequest, didParseResponse response: LivingMapSDK.DataResponse<Value, LivingMapSDK.AFError>)
  final public func request(_ request: LivingMapSDK.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: LivingMapSDK.Request.ValidationResult)
  final public func request<Value>(_ request: LivingMapSDK.DataStreamRequest, didParseStream result: Swift.Result<Value, LivingMapSDK.AFError>)
  final public func request(_ request: LivingMapSDK.UploadRequest, didCreateUploadable uploadable: LivingMapSDK.UploadRequest.Uploadable)
  final public func request(_ request: LivingMapSDK.UploadRequest, didFailToCreateUploadableWithError error: LivingMapSDK.AFError)
  final public func request(_ request: LivingMapSDK.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  final public func request(_ request: LivingMapSDK.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, LivingMapSDK.AFError>)
  final public func request(_ request: LivingMapSDK.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  final public func request(_ request: LivingMapSDK.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: LivingMapSDK.Request.ValidationResult)
  final public func request(_ request: LivingMapSDK.DownloadRequest, didParseResponse response: LivingMapSDK.DownloadResponse<Foundation.URL?, LivingMapSDK.AFError>)
  final public func request<Value>(_ request: LivingMapSDK.DownloadRequest, didParseResponse response: LivingMapSDK.DownloadResponse<Value, LivingMapSDK.AFError>)
  @objc deinit
}
open class ClosureEventMonitor : LivingMapSDK.EventMonitor {
  open var sessionDidBecomeInvalidWithError: ((Foundation.URLSession, (any Swift.Error)?) -> Swift.Void)?
  open var taskDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge) -> Swift.Void)?
  open var taskDidSendBodyData: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var taskNeedNewBodyStream: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var taskWillPerformHTTPRedirection: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest) -> Swift.Void)?
  open var taskDidFinishCollectingMetrics: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var taskDidComplete: ((Foundation.URLSession, Foundation.URLSessionTask, (any Swift.Error)?) -> Swift.Void)?
  open var taskIsWaitingForConnectivity: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var dataTaskDidReceiveData: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.Data) -> Swift.Void)?
  open var dataTaskWillCacheResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Swift.Void)?
  open var downloadTaskDidFinishDownloadingToURL: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Foundation.URL) -> Swift.Void)?
  open var downloadTaskDidWriteData: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var downloadTaskDidResumeAtOffset: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var requestDidCreateInitialURLRequest: ((LivingMapSDK.Request, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToCreateURLRequestWithError: ((LivingMapSDK.Request, LivingMapSDK.AFError) -> Swift.Void)?
  open var requestDidAdaptInitialRequestToAdaptedRequest: ((LivingMapSDK.Request, Foundation.URLRequest, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToAdaptURLRequestWithError: ((LivingMapSDK.Request, Foundation.URLRequest, LivingMapSDK.AFError) -> Swift.Void)?
  open var requestDidCreateURLRequest: ((LivingMapSDK.Request, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidCreateTask: ((LivingMapSDK.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidGatherMetrics: ((LivingMapSDK.Request, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var requestDidFailTaskEarlyWithError: ((LivingMapSDK.Request, Foundation.URLSessionTask, LivingMapSDK.AFError) -> Swift.Void)?
  open var requestDidCompleteTaskWithError: ((LivingMapSDK.Request, Foundation.URLSessionTask, LivingMapSDK.AFError?) -> Swift.Void)?
  open var requestIsRetrying: ((LivingMapSDK.Request) -> Swift.Void)?
  open var requestDidFinish: ((LivingMapSDK.Request) -> Swift.Void)?
  open var requestDidResume: ((LivingMapSDK.Request) -> Swift.Void)?
  open var requestDidResumeTask: ((LivingMapSDK.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidSuspend: ((LivingMapSDK.Request) -> Swift.Void)?
  open var requestDidSuspendTask: ((LivingMapSDK.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidCancel: ((LivingMapSDK.Request) -> Swift.Void)?
  open var requestDidCancelTask: ((LivingMapSDK.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidValidateRequestResponseDataWithResult: ((LivingMapSDK.DataRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?, LivingMapSDK.Request.ValidationResult) -> Swift.Void)?
  open var requestDidParseResponse: ((LivingMapSDK.DataRequest, LivingMapSDK.DataResponse<Foundation.Data?, LivingMapSDK.AFError>) -> Swift.Void)?
  open var requestDidValidateRequestResponseWithResult: ((LivingMapSDK.DataStreamRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, LivingMapSDK.Request.ValidationResult) -> Swift.Void)?
  open var requestDidCreateUploadable: ((LivingMapSDK.UploadRequest, LivingMapSDK.UploadRequest.Uploadable) -> Swift.Void)?
  open var requestDidFailToCreateUploadableWithError: ((LivingMapSDK.UploadRequest, LivingMapSDK.AFError) -> Swift.Void)?
  open var requestDidProvideInputStream: ((LivingMapSDK.UploadRequest, Foundation.InputStream) -> Swift.Void)?
  open var requestDidFinishDownloadingUsingTaskWithResult: ((LivingMapSDK.DownloadRequest, Foundation.URLSessionTask, Swift.Result<Foundation.URL, LivingMapSDK.AFError>) -> Swift.Void)?
  open var requestDidCreateDestinationURL: ((LivingMapSDK.DownloadRequest, Foundation.URL) -> Swift.Void)?
  open var requestDidValidateRequestResponseFileURLWithResult: ((LivingMapSDK.DownloadRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.URL?, LivingMapSDK.Request.ValidationResult) -> Swift.Void)?
  open var requestDidParseDownloadResponse: ((LivingMapSDK.DownloadRequest, LivingMapSDK.DownloadResponse<Foundation.URL?, LivingMapSDK.AFError>) -> Swift.Void)?
  final public let queue: Dispatch.DispatchQueue
  public init(queue: Dispatch.DispatchQueue = .main)
  open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  open func request(_ request: LivingMapSDK.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: LivingMapSDK.Request, didFailToCreateURLRequestWithError error: LivingMapSDK.AFError)
  open func request(_ request: LivingMapSDK.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  open func request(_ request: LivingMapSDK.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: LivingMapSDK.AFError)
  open func request(_ request: LivingMapSDK.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: LivingMapSDK.Request, didCreateTask task: Foundation.URLSessionTask)
  open func request(_ request: LivingMapSDK.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  open func request(_ request: LivingMapSDK.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: LivingMapSDK.AFError)
  open func request(_ request: LivingMapSDK.Request, didCompleteTask task: Foundation.URLSessionTask, with error: LivingMapSDK.AFError?)
  open func requestIsRetrying(_ request: LivingMapSDK.Request)
  open func requestDidFinish(_ request: LivingMapSDK.Request)
  open func requestDidResume(_ request: LivingMapSDK.Request)
  public func request(_ request: LivingMapSDK.Request, didResumeTask task: Foundation.URLSessionTask)
  open func requestDidSuspend(_ request: LivingMapSDK.Request)
  public func request(_ request: LivingMapSDK.Request, didSuspendTask task: Foundation.URLSessionTask)
  open func requestDidCancel(_ request: LivingMapSDK.Request)
  public func request(_ request: LivingMapSDK.Request, didCancelTask task: Foundation.URLSessionTask)
  open func request(_ request: LivingMapSDK.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: LivingMapSDK.Request.ValidationResult)
  open func request(_ request: LivingMapSDK.DataRequest, didParseResponse response: LivingMapSDK.DataResponse<Foundation.Data?, LivingMapSDK.AFError>)
  public func request(_ request: LivingMapSDK.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: LivingMapSDK.Request.ValidationResult)
  open func request(_ request: LivingMapSDK.UploadRequest, didCreateUploadable uploadable: LivingMapSDK.UploadRequest.Uploadable)
  open func request(_ request: LivingMapSDK.UploadRequest, didFailToCreateUploadableWithError error: LivingMapSDK.AFError)
  open func request(_ request: LivingMapSDK.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  open func request(_ request: LivingMapSDK.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, LivingMapSDK.AFError>)
  open func request(_ request: LivingMapSDK.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  open func request(_ request: LivingMapSDK.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: LivingMapSDK.Request.ValidationResult)
  open func request(_ request: LivingMapSDK.DownloadRequest, didParseResponse response: LivingMapSDK.DownloadResponse<Foundation.URL?, LivingMapSDK.AFError>)
  @objc deinit
}
public protocol _ProtoNameProviding {
  static var _protobuf_nameMap: LivingMapSDK._NameMap { get }
}
public enum PMKError : Swift.Error {
  case invalidCallingConvention
  case returnedSelf
  case badInput
  case cancelled
  @available(*, deprecated, message: "See: `compactMap`")
  case flatMap(Any, any Any.Type)
  case compactMap(Any, any Any.Type)
  case emptySequence
  case noWinner
}
extension LivingMapSDK.PMKError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension LivingMapSDK.PMKError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public protocol CancellableError : Swift.Error {
  var isCancelled: Swift.Bool { get }
}
extension Swift.Error {
  public var isCancelled: Swift.Bool {
    get
  }
}
public enum CatchPolicy {
  case allErrors
  case allErrorsExceptCancellation
  public static func == (a: LivingMapSDK.CatchPolicy, b: LivingMapSDK.CatchPolicy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum JSONDecodingError : Swift.Error {
  case failure
  case malformedNumber
  case numberRange
  case malformedMap
  case malformedBool
  case malformedString
  case invalidUTF8
  case missingFieldNames
  case schemaMismatch
  case unrecognizedEnumValue
  case illegalNull
  case unquotedMapKey
  case leadingZero
  case truncated
  case malformedDuration
  case malformedTimestamp
  case malformedFieldMask
  case trailingGarbage
  case conflictingOneOf
  case messageDepthLimit
  case unknownField(Swift.String)
}
public struct HTTPHeaders {
  public init()
  public init(_ headers: [LivingMapSDK.HTTPHeader])
  public init(_ dictionary: [Swift.String : Swift.String])
  public mutating func add(name: Swift.String, value: Swift.String)
  public mutating func add(_ header: LivingMapSDK.HTTPHeader)
  public mutating func update(name: Swift.String, value: Swift.String)
  public mutating func update(_ header: LivingMapSDK.HTTPHeader)
  public mutating func remove(name: Swift.String)
  public mutating func sort()
  public func sorted() -> LivingMapSDK.HTTPHeaders
  public func value(for name: Swift.String) -> Swift.String?
  public subscript(name: Swift.String) -> Swift.String? {
    get
    set
  }
  public var dictionary: [Swift.String : Swift.String] {
    get
  }
}
extension LivingMapSDK.HTTPHeaders : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Swift.String)...)
  public typealias Key = Swift.String
  public typealias Value = Swift.String
}
extension LivingMapSDK.HTTPHeaders : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: LivingMapSDK.HTTPHeader...)
  public typealias ArrayLiteralElement = LivingMapSDK.HTTPHeader
}
extension LivingMapSDK.HTTPHeaders : Swift.Sequence {
  public func makeIterator() -> Swift.IndexingIterator<[LivingMapSDK.HTTPHeader]>
}
extension LivingMapSDK.HTTPHeaders : Swift.Collection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(position: Swift.Int) -> LivingMapSDK.HTTPHeader {
    get
  }
  public func index(after i: Swift.Int) -> Swift.Int
  public typealias Element = LivingMapSDK.HTTPHeader
  public typealias Index = Swift.Int
  public typealias Indices = Swift.DefaultIndices<LivingMapSDK.HTTPHeaders>
  public typealias Iterator = Swift.IndexingIterator<[LivingMapSDK.HTTPHeader]>
  public typealias SubSequence = Swift.Slice<LivingMapSDK.HTTPHeaders>
}
extension LivingMapSDK.HTTPHeaders : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct HTTPHeader : Swift.Hashable {
  public let name: Swift.String
  public let value: Swift.String
  public init(name: Swift.String, value: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LivingMapSDK.HTTPHeader, b: LivingMapSDK.HTTPHeader) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.HTTPHeader : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LivingMapSDK.HTTPHeader {
  public static func accept(_ value: Swift.String) -> LivingMapSDK.HTTPHeader
  public static func acceptCharset(_ value: Swift.String) -> LivingMapSDK.HTTPHeader
  public static func acceptLanguage(_ value: Swift.String) -> LivingMapSDK.HTTPHeader
  public static func acceptEncoding(_ value: Swift.String) -> LivingMapSDK.HTTPHeader
  public static func authorization(username: Swift.String, password: Swift.String) -> LivingMapSDK.HTTPHeader
  public static func authorization(bearerToken: Swift.String) -> LivingMapSDK.HTTPHeader
  public static func authorization(_ value: Swift.String) -> LivingMapSDK.HTTPHeader
  public static func contentDisposition(_ value: Swift.String) -> LivingMapSDK.HTTPHeader
  public static func contentType(_ value: Swift.String) -> LivingMapSDK.HTTPHeader
  public static func userAgent(_ value: Swift.String) -> LivingMapSDK.HTTPHeader
}
extension LivingMapSDK.HTTPHeaders {
  public static let `default`: LivingMapSDK.HTTPHeaders
}
extension LivingMapSDK.HTTPHeader {
  public static let defaultAcceptEncoding: LivingMapSDK.HTTPHeader
  public static let defaultAcceptLanguage: LivingMapSDK.HTTPHeader
  public static let defaultUserAgent: LivingMapSDK.HTTPHeader
}
extension Foundation.URLRequest {
  public var headers: LivingMapSDK.HTTPHeaders {
    get
    set
  }
}
extension Foundation.HTTPURLResponse {
  public var headers: LivingMapSDK.HTTPHeaders {
    get
  }
}
extension Foundation.URLSessionConfiguration {
  public var headers: LivingMapSDK.HTTPHeaders {
    get
    set
  }
}
public class MapNotification {
  public enum NotificationType : Swift.String {
    case INFO
    case DEBUG
    case WARNING
    case ERROR
    case SUCCESS
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Icon : Swift.String {
    case FLIGHT_INFORMATION
    case NO_INTERNET
    case PASS
    case WARNING
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public init(livingMapSDKManager: LivingMapSDK.LivingMapSDKManager, type: LivingMapSDK.MapNotification.NotificationType, text: Swift.String, icon: LivingMapSDK.MapNotification.Icon, colour: Swift.String?, textColour: Swift.String?)
  public func show()
  public func hide()
  public class Builder {
    public init()
    public func type(_ type: LivingMapSDK.MapNotification.NotificationType) -> LivingMapSDK.MapNotification.Builder
    public func text(_ text: Swift.String) -> LivingMapSDK.MapNotification.Builder
    public func icon(_ icon: LivingMapSDK.MapNotification.Icon) -> LivingMapSDK.MapNotification.Builder
    public func colour(_ colour: Swift.String) -> LivingMapSDK.MapNotification.Builder
    public func textColour(_ textColour: Swift.String) -> LivingMapSDK.MapNotification.Builder
    public func build(livingMapSDKManager: LivingMapSDK.LivingMapSDKManager) -> LivingMapSDK.MapNotification
    @objc deinit
  }
  @objc deinit
}
public func hang<T>(_ promise: LivingMapSDK.Promise<T>) throws -> T
public struct Google_Protobuf_DoubleValue {
  public var value: Swift.Double
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
public struct Google_Protobuf_FloatValue {
  public var value: Swift.Float
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
public struct Google_Protobuf_Int64Value {
  public var value: Swift.Int64
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
public struct Google_Protobuf_UInt64Value {
  public var value: Swift.UInt64
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
public struct Google_Protobuf_Int32Value {
  public var value: Swift.Int32
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
public struct Google_Protobuf_UInt32Value {
  public var value: Swift.UInt32
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
public struct Google_Protobuf_BoolValue {
  public var value: Swift.Bool
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
public struct Google_Protobuf_StringValue {
  public var value: Swift.String
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
public struct Google_Protobuf_BytesValue {
  public var value: Foundation.Data
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
extension LivingMapSDK.Google_Protobuf_DoubleValue : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_FloatValue : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Int64Value : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_UInt64Value : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Int32Value : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_UInt32Value : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_BoolValue : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_StringValue : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_BytesValue : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_DoubleValue : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_DoubleValue, rhs: LivingMapSDK.Google_Protobuf_DoubleValue) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_FloatValue : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_FloatValue, rhs: LivingMapSDK.Google_Protobuf_FloatValue) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_Int64Value : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_Int64Value, rhs: LivingMapSDK.Google_Protobuf_Int64Value) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_UInt64Value : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_UInt64Value, rhs: LivingMapSDK.Google_Protobuf_UInt64Value) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_Int32Value : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_Int32Value, rhs: LivingMapSDK.Google_Protobuf_Int32Value) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_UInt32Value : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_UInt32Value, rhs: LivingMapSDK.Google_Protobuf_UInt32Value) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_BoolValue : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_BoolValue, rhs: LivingMapSDK.Google_Protobuf_BoolValue) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_StringValue : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_StringValue, rhs: LivingMapSDK.Google_Protobuf_StringValue) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_BytesValue : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_BytesValue, rhs: LivingMapSDK.Google_Protobuf_BytesValue) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum Google_Protobuf_NullValue : LivingMapSDK.Enum {
  public typealias RawValue = Swift.Int
  case nullValue
  case UNRECOGNIZED(Swift.Int)
  public init()
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_NullValue : Swift.CaseIterable {
  public static var allCases: [LivingMapSDK.Google_Protobuf_NullValue]
  public typealias AllCases = [LivingMapSDK.Google_Protobuf_NullValue]
}
public struct Google_Protobuf_Struct {
  public var fields: [Swift.String : LivingMapSDK.Google_Protobuf_Value]
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
public struct Google_Protobuf_Value {
  public var kind: LivingMapSDK.Google_Protobuf_Value.OneOf_Kind?
  public var nullValue: LivingMapSDK.Google_Protobuf_NullValue {
    get
    set
  }
  public var numberValue: Swift.Double {
    get
    set
  }
  public var stringValue: Swift.String {
    get
    set
  }
  public var boolValue: Swift.Bool {
    get
    set
  }
  public var structValue: LivingMapSDK.Google_Protobuf_Struct {
    get
    set
  }
  public var listValue: LivingMapSDK.Google_Protobuf_ListValue {
    get
    set
  }
  public var unknownFields: LivingMapSDK.UnknownStorage
  public enum OneOf_Kind : Swift.Equatable {
    case nullValue(LivingMapSDK.Google_Protobuf_NullValue)
    case numberValue(Swift.Double)
    case stringValue(Swift.String)
    case boolValue(Swift.Bool)
    case structValue(LivingMapSDK.Google_Protobuf_Struct)
    case listValue(LivingMapSDK.Google_Protobuf_ListValue)
    public static func == (a: LivingMapSDK.Google_Protobuf_Value.OneOf_Kind, b: LivingMapSDK.Google_Protobuf_Value.OneOf_Kind) -> Swift.Bool
  }
  public init()
}
public struct Google_Protobuf_ListValue {
  public var values: [LivingMapSDK.Google_Protobuf_Value]
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
extension LivingMapSDK.Google_Protobuf_NullValue : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Struct : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Value : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Value.OneOf_Kind : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_ListValue : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_NullValue : LivingMapSDK._ProtoNameProviding {
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
}
extension LivingMapSDK.Google_Protobuf_Struct : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_Struct, rhs: LivingMapSDK.Google_Protobuf_Struct) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_Value : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_Value, rhs: LivingMapSDK.Google_Protobuf_Value) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_ListValue : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_ListValue, rhs: LivingMapSDK.Google_Protobuf_ListValue) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ProtoDecoder {
  mutating func handleConflictingOneOf() throws
  mutating func nextFieldNumber() throws -> Swift.Int?
  mutating func decodeSingularFloatField(value: inout Swift.Float) throws
  mutating func decodeSingularFloatField(value: inout Swift.Float?) throws
  mutating func decodeRepeatedFloatField(value: inout [Swift.Float]) throws
  mutating func decodeSingularDoubleField(value: inout Swift.Double) throws
  mutating func decodeSingularDoubleField(value: inout Swift.Double?) throws
  mutating func decodeRepeatedDoubleField(value: inout [Swift.Double]) throws
  mutating func decodeSingularInt32Field(value: inout Swift.Int32) throws
  mutating func decodeSingularInt32Field(value: inout Swift.Int32?) throws
  mutating func decodeRepeatedInt32Field(value: inout [Swift.Int32]) throws
  mutating func decodeSingularInt64Field(value: inout Swift.Int64) throws
  mutating func decodeSingularInt64Field(value: inout Swift.Int64?) throws
  mutating func decodeRepeatedInt64Field(value: inout [Swift.Int64]) throws
  mutating func decodeSingularUInt32Field(value: inout Swift.UInt32) throws
  mutating func decodeSingularUInt32Field(value: inout Swift.UInt32?) throws
  mutating func decodeRepeatedUInt32Field(value: inout [Swift.UInt32]) throws
  mutating func decodeSingularUInt64Field(value: inout Swift.UInt64) throws
  mutating func decodeSingularUInt64Field(value: inout Swift.UInt64?) throws
  mutating func decodeRepeatedUInt64Field(value: inout [Swift.UInt64]) throws
  mutating func decodeSingularSInt32Field(value: inout Swift.Int32) throws
  mutating func decodeSingularSInt32Field(value: inout Swift.Int32?) throws
  mutating func decodeRepeatedSInt32Field(value: inout [Swift.Int32]) throws
  mutating func decodeSingularSInt64Field(value: inout Swift.Int64) throws
  mutating func decodeSingularSInt64Field(value: inout Swift.Int64?) throws
  mutating func decodeRepeatedSInt64Field(value: inout [Swift.Int64]) throws
  mutating func decodeSingularFixed32Field(value: inout Swift.UInt32) throws
  mutating func decodeSingularFixed32Field(value: inout Swift.UInt32?) throws
  mutating func decodeRepeatedFixed32Field(value: inout [Swift.UInt32]) throws
  mutating func decodeSingularFixed64Field(value: inout Swift.UInt64) throws
  mutating func decodeSingularFixed64Field(value: inout Swift.UInt64?) throws
  mutating func decodeRepeatedFixed64Field(value: inout [Swift.UInt64]) throws
  mutating func decodeSingularSFixed32Field(value: inout Swift.Int32) throws
  mutating func decodeSingularSFixed32Field(value: inout Swift.Int32?) throws
  mutating func decodeRepeatedSFixed32Field(value: inout [Swift.Int32]) throws
  mutating func decodeSingularSFixed64Field(value: inout Swift.Int64) throws
  mutating func decodeSingularSFixed64Field(value: inout Swift.Int64?) throws
  mutating func decodeRepeatedSFixed64Field(value: inout [Swift.Int64]) throws
  mutating func decodeSingularBoolField(value: inout Swift.Bool) throws
  mutating func decodeSingularBoolField(value: inout Swift.Bool?) throws
  mutating func decodeRepeatedBoolField(value: inout [Swift.Bool]) throws
  mutating func decodeSingularStringField(value: inout Swift.String) throws
  mutating func decodeSingularStringField(value: inout Swift.String?) throws
  mutating func decodeRepeatedStringField(value: inout [Swift.String]) throws
  mutating func decodeSingularBytesField(value: inout Foundation.Data) throws
  mutating func decodeSingularBytesField(value: inout Foundation.Data?) throws
  mutating func decodeRepeatedBytesField(value: inout [Foundation.Data]) throws
  mutating func decodeSingularEnumField<E>(value: inout E) throws where E : LivingMapSDK.Enum, E.RawValue == Swift.Int
  mutating func decodeSingularEnumField<E>(value: inout E?) throws where E : LivingMapSDK.Enum, E.RawValue == Swift.Int
  mutating func decodeRepeatedEnumField<E>(value: inout [E]) throws where E : LivingMapSDK.Enum, E.RawValue == Swift.Int
  mutating func decodeSingularMessageField<M>(value: inout M?) throws where M : LivingMapSDK.Message
  mutating func decodeRepeatedMessageField<M>(value: inout [M]) throws where M : LivingMapSDK.Message
  mutating func decodeSingularGroupField<G>(value: inout G?) throws where G : LivingMapSDK.Message
  mutating func decodeRepeatedGroupField<G>(value: inout [G]) throws where G : LivingMapSDK.Message
  mutating func decodeMapField<KeyType, ValueType>(fieldType: LivingMapSDK._ProtobufMap<KeyType, ValueType>.Type, value: inout LivingMapSDK._ProtobufMap<KeyType, ValueType>.BaseType) throws where KeyType : LivingMapSDK.MapKeyType, ValueType : LivingMapSDK.MapValueType
  mutating func decodeMapField<KeyType, ValueType>(fieldType: LivingMapSDK._ProtobufEnumMap<KeyType, ValueType>.Type, value: inout LivingMapSDK._ProtobufEnumMap<KeyType, ValueType>.BaseType) throws where KeyType : LivingMapSDK.MapKeyType, ValueType : LivingMapSDK.Enum, ValueType.RawValue == Swift.Int
  mutating func decodeMapField<KeyType, ValueType>(fieldType: LivingMapSDK._ProtobufMessageMap<KeyType, ValueType>.Type, value: inout LivingMapSDK._ProtobufMessageMap<KeyType, ValueType>.BaseType) throws where KeyType : LivingMapSDK.MapKeyType, ValueType : LivingMapSDK.Message, ValueType : Swift.Hashable
  mutating func decodeExtensionField(values: inout LivingMapSDK.ExtensionFieldValueSet, messageType: any LivingMapSDK.Message.Type, fieldNumber: Swift.Int) throws
  mutating func decodeExtensionFieldsAsMessageSet(values: inout LivingMapSDK.ExtensionFieldValueSet, messageType: any LivingMapSDK.Message.Type) throws
}
extension LivingMapSDK.ProtoDecoder {
  public mutating func decodeExtensionFieldsAsMessageSet(values: inout LivingMapSDK.ExtensionFieldValueSet, messageType: any LivingMapSDK.Message.Type) throws
}
public protocol ExtensibleMessage : LivingMapSDK.Message {
  var _protobuf_extensionFieldValues: LivingMapSDK.ExtensionFieldValueSet { get set }
}
extension LivingMapSDK.ExtensibleMessage {
  public mutating func setExtensionValue<F>(ext: LivingMapSDK.MessageExtension<F, Self>, value: F.ValueType) where F : LivingMapSDK.ExtensionField
  public func getExtensionValue<F>(ext: LivingMapSDK.MessageExtension<F, Self>) -> F.ValueType? where F : LivingMapSDK.ExtensionField
  public func hasExtensionValue<F>(ext: LivingMapSDK.MessageExtension<F, Self>) -> Swift.Bool where F : LivingMapSDK.ExtensionField
  public mutating func clearExtensionValue<F>(ext: LivingMapSDK.MessageExtension<F, Self>) where F : LivingMapSDK.ExtensionField
}
extension LivingMapSDK.ExtensibleMessage {
  public mutating func setExtensionValue<T>(ext: LivingMapSDK.MessageExtension<LivingMapSDK.RepeatedExtensionField<T>, Self>, value: [T.BaseType]) where T : LivingMapSDK.FieldType
  public mutating func setExtensionValue<T>(ext: LivingMapSDK.MessageExtension<LivingMapSDK.PackedExtensionField<T>, Self>, value: [T.BaseType]) where T : LivingMapSDK.FieldType
  public mutating func setExtensionValue<E>(ext: LivingMapSDK.MessageExtension<LivingMapSDK.RepeatedEnumExtensionField<E>, Self>, value: [E]) where E : LivingMapSDK.Enum, E.RawValue == Swift.Int
  public mutating func setExtensionValue<E>(ext: LivingMapSDK.MessageExtension<LivingMapSDK.PackedEnumExtensionField<E>, Self>, value: [E]) where E : LivingMapSDK.Enum, E.RawValue == Swift.Int
  public mutating func setExtensionValue<M>(ext: LivingMapSDK.MessageExtension<LivingMapSDK.RepeatedMessageExtensionField<M>, Self>, value: [M]) where M : LivingMapSDK.Message, M : Swift.Equatable
  public mutating func setExtensionValue<M>(ext: LivingMapSDK.MessageExtension<LivingMapSDK.RepeatedGroupExtensionField<M>, Self>, value: [M]) where M : LivingMapSDK.Message, M : Swift.Hashable
}
public struct RequestData : Swift.Codable {
  public var status: LivingMapSDK.LiveData?
  public var asset: LivingMapSDK.DeviceData
  public var journey: LivingMapSDK.JourneyData?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct LiveData : Swift.Codable, Swift.Equatable {
  public var position: LivingMapSDK.Position
  public var journey: LivingMapSDK.JourneyStatus?
  public static func == (lhs: LivingMapSDK.LiveData, rhs: LivingMapSDK.LiveData) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Position : Swift.Codable, Swift.Equatable {
  public var accuracy: Swift.Double
  public var coordinates: LivingMapSDK.Coordinates
  public var floor_level: Swift.String
  public var heading: Swift.Double
  public static func == (lhs: LivingMapSDK.Position, rhs: LivingMapSDK.Position) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct JourneyStatus : Swift.Codable, Swift.Equatable {
  public var remaining_time: Swift.Int
  public var remaining_distance: Swift.Int
  public var percentage_complete: Swift.Int?
  public init(remainingTime: Swift.Int, remainingDistance: Swift.Int, percentageComplete: Swift.Int? = nil)
  public static func == (lhs: LivingMapSDK.JourneyStatus, rhs: LivingMapSDK.JourneyStatus) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Coordinates : Swift.Codable, Swift.Equatable {
  public var latitude: Swift.Double
  public var longitude: Swift.Double
  public static func == (lhs: LivingMapSDK.Coordinates, rhs: LivingMapSDK.Coordinates) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DeviceData : Swift.Codable, Swift.Equatable {
  public var uuid: Swift.String
  public var category: Swift.String
  public var manufacturer: Swift.String
  public var meta_data: LivingMapSDK.DeviceMetaData
  public var model: Swift.String
  public var parameter_1: Swift.String?
  public var parameter_2: Swift.String?
  public var parameter_3: Swift.String?
  public var sdk_version: Swift.String
  public var tags: Swift.String?
  public static func == (lhs: LivingMapSDK.DeviceData, rhs: LivingMapSDK.DeviceData) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DeviceMetaData : Swift.Codable, Swift.Equatable {
  public var app_name: Swift.String
  public var os_version: Swift.String
  public static func == (lhs: LivingMapSDK.DeviceMetaData, rhs: LivingMapSDK.DeviceMetaData) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct JourneyData : Swift.Codable, Swift.Equatable {
  public var uuid: Swift.String
  public var calculated_time: Swift.Int
  public var calculated_distance: Swift.Int
  public var coordinates_start: LivingMapSDK.Coordinates
  public var coordinates_end: LivingMapSDK.Coordinates
  public var floor_level_start: Swift.String
  public var floor_level_end: Swift.String
  public var meta_data: LivingMapSDK.JourneyMetaData
  public var parameter_1: Swift.String?
  public var parameter_2: Swift.String?
  public var parameter_3: Swift.String?
  public static func == (lhs: LivingMapSDK.JourneyData, rhs: LivingMapSDK.JourneyData) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct JourneyMetaData : Swift.Codable, Swift.Equatable {
  public var accessible_route: Swift.Bool
  public var via_points_on_route: Swift.Bool
  public var critical_journey: Swift.Bool
  public var show_ecc_card: Swift.Bool
  public init(accessibleRoute: Swift.Bool, viaPointsOnRoute: Swift.Bool, criticalJourney: Swift.Bool, showEccCard: Swift.Bool)
  public static func == (lhs: LivingMapSDK.JourneyMetaData, rhs: LivingMapSDK.JourneyMetaData) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct JourneyInfo {
  public var time: Swift.Int
  public var distance: Swift.Int
  public init(time: Swift.Int, distance: Swift.Int)
}
open class AFSession {
  public init()
  open func createAFSession(credentials: LivingMapSDK.AuthenticationParameters, httpOriginValue: Swift.String) -> LivingMapSDK.Session
  open func generateRequest(url: Foundation.URL, method: Swift.String, contentType: Swift.String?, body: Foundation.Data?) -> Foundation.URLRequest
  @objc deinit
}
public struct Version {
  public static let major: Swift.Int
  public static let minor: Swift.Int
  public static let revision: Swift.Int
  public static let versionString: Swift.String
}
public struct LMLivePositioningConfig : Swift.Codable {
  public var positioningSystem: LivingMapSDK.PositioningSystem
  public var headingSystem: LivingMapSDK.HeadingSystem
  public var sensorUpdateFrequencies: LivingMapSDK.LMSensorUpdateFrequencies
  public var backgroundGathering: Swift.Bool
  public var clickableAssetsEnabled: Swift.Bool?
  public var lmLocationConfig: LivingMapSDK.LMLocationConfig
  public var cplLocationConfig: LivingMapSDK.CPLLocationConfig
  public var stepConfig: LivingMapSDK.LMStepConfig
  public var calibrationConfig: LivingMapSDK.LMCalibrationConfig
  public var stepLength: Swift.Double
  public var gatewayAccuracy: Swift.Double
  public var headingCalculationCadence: Swift.Double
  public var headingCalculationTrigger: LivingMapSDK.HeadingCalculationTrigger
  public var floorChangeStatusActivationHeight: Swift.Double
  public var changeActivationHeight: Swift.Double
  public var floorChangeAttempts: Swift.Int
  public init(headingSystem: LivingMapSDK.HeadingSystem = HeadingSystem.CommonPositioningLibraryHeading, positioningSystem: LivingMapSDK.PositioningSystem, sensorUpdateFrequencies: LivingMapSDK.LMSensorUpdateFrequencies = LMSensorUpdateFrequencies(), backgroundGathering: Swift.Bool = false, lmLocationConfig: LivingMapSDK.LMLocationConfig, cplLocationConfig: LivingMapSDK.CPLLocationConfig, stepConfig: LivingMapSDK.LMStepConfig = LMStepConfig(), calibrationConfig: LivingMapSDK.LMCalibrationConfig = LMCalibrationConfig(), stepLength: Swift.Double = 0.78, gatewayAccuracy: Swift.Double = 5.0, clickableAssetsEnabled: Swift.Bool? = false, headingCalculationCadence: Swift.Double = 0.5, headingCalculationTrigger: LivingMapSDK.HeadingCalculationTrigger = HeadingCalculationTrigger.TimerBased, floorChangeStatusActivationHeight: Swift.Double = 2.9, changeActivationHeight: Swift.Double = 1, floorChangeAttempts: Swift.Int = 5)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum PositioningSystem : Swift.String, Swift.Codable {
  case LMLocation
  case CoreLocation
  case LMCPLLocation
  case CoreCPLLocation
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum HeadingSystem : Swift.String, Swift.Codable {
  case CoreMotionHeading
  case CoreLocationHeading
  case CommonPositioningLibraryHeading
  case RegressionLinesHeading
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum MagnetometerCalibrationMethod : Swift.String, Swift.Codable {
  case CPL
  case System
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum HeadingCalculationTrigger : Swift.String, Swift.Codable {
  case TimerBased
  case StepBased
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct Google_Protobuf_Empty {
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
extension LivingMapSDK.Google_Protobuf_Empty : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Empty : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_Empty, rhs: LivingMapSDK.Google_Protobuf_Empty) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol URLConvertible {
  func asURL() throws -> Foundation.URL
}
extension Swift.String : LivingMapSDK.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URL : LivingMapSDK.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URLComponents : LivingMapSDK.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
public protocol URLRequestConvertible {
  func asURLRequest() throws -> Foundation.URLRequest
}
extension LivingMapSDK.URLRequestConvertible {
  public var urlRequest: Foundation.URLRequest? {
    get
  }
}
extension Foundation.URLRequest : LivingMapSDK.URLRequestConvertible {
  public func asURLRequest() throws -> Foundation.URLRequest
}
extension Foundation.URLRequest {
  public init(url: any LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod, headers: LivingMapSDK.HTTPHeaders? = nil) throws
}
public enum LogEvent {
  case waitOnMainThread
  case pendingPromiseDeallocated
  case pendingGuaranteeDeallocated
  case cauterized(any Swift.Error)
}
extension LivingMapSDK.Google_Protobuf_Value : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int64
  public init(integerLiteral value: Swift.Int64)
}
extension LivingMapSDK.Google_Protobuf_Value : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
  public init(floatLiteral value: Swift.Double)
}
extension LivingMapSDK.Google_Protobuf_Value : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
  public init(booleanLiteral value: Swift.Bool)
}
extension LivingMapSDK.Google_Protobuf_Value : Swift.ExpressibleByStringLiteral {
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
  public init(stringLiteral value: Swift.String)
  public init(unicodeScalarLiteral value: Swift.String)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
}
extension LivingMapSDK.Google_Protobuf_Value : Swift.ExpressibleByNilLiteral {
  public init(nilLiteral: ())
}
extension LivingMapSDK.Google_Protobuf_Value {
  public init(numberValue: Swift.Double)
  public init(stringValue: Swift.String)
  public init(boolValue: Swift.Bool)
  public init(structValue: LivingMapSDK.Google_Protobuf_Struct)
  public init(listValue: LivingMapSDK.Google_Protobuf_ListValue)
}
public struct LMLocationConfig : Swift.Codable {
  public var runtimeSignalUidMatchRatio: Swift.Float
  public var surveySignalUidMatchRatio: Swift.Float
  public init(runtimeSignalUidMatchRatio: Swift.Float = 0.15, surveySignalUidMatchRatio: Swift.Float = 0.15)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class DebugInfo {
  public func setMetricsData(_ offset: Swift.Double, _ depletion: Swift.Double)
  public func setStepAttributes(_ step: LivingMapSDK.LMStep)
  public func setLocationAttributes(_ location: LivingMapSDK.LMLocation)
  public func getDebugInfoAsString() -> Swift.String
  @objc deinit
}
public enum BinaryEncodingError : Swift.Error {
  case anyTranscodeFailure
  case missingRequiredFields
  public static func == (a: LivingMapSDK.BinaryEncodingError, b: LivingMapSDK.BinaryEncodingError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_ListValue : Swift.ExpressibleByArrayLiteral {
  public typealias Element = LivingMapSDK.Google_Protobuf_Value
  public init(arrayLiteral elements: LivingMapSDK.Google_Protobuf_ListValue.Element...)
  public typealias ArrayLiteralElement = LivingMapSDK.Google_Protobuf_ListValue.Element
}
extension LivingMapSDK.Google_Protobuf_ListValue {
  public init(values: [LivingMapSDK.Google_Protobuf_Value])
  public subscript(index: Swift.Int) -> LivingMapSDK.Google_Protobuf_Value {
    get
    set(newValue)
  }
}
extension Foundation.URLRequest {
  public var method: LivingMapSDK.HTTPMethod? {
    get
    set
  }
  public func validate() throws
}
public struct Checksums : Swift.Codable, Swift.Equatable {
  public static func == (lhs: LivingMapSDK.Checksums, rhs: LivingMapSDK.Checksums) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum Google_Protobuf_Syntax : LivingMapSDK.Enum {
  public typealias RawValue = Swift.Int
  case proto2
  case proto3
  case UNRECOGNIZED(Swift.Int)
  public init()
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_Syntax : Swift.CaseIterable {
  public static var allCases: [LivingMapSDK.Google_Protobuf_Syntax]
  public typealias AllCases = [LivingMapSDK.Google_Protobuf_Syntax]
}
public struct Google_Protobuf_Type {
  public var name: Swift.String
  public var fields: [LivingMapSDK.Google_Protobuf_Field]
  public var oneofs: [Swift.String]
  public var options: [LivingMapSDK.Google_Protobuf_Option]
  public var sourceContext: LivingMapSDK.Google_Protobuf_SourceContext {
    get
    set
  }
  public var hasSourceContext: Swift.Bool {
    get
  }
  public mutating func clearSourceContext()
  public var syntax: LivingMapSDK.Google_Protobuf_Syntax
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
public struct Google_Protobuf_Field {
  public var kind: LivingMapSDK.Google_Protobuf_Field.Kind
  public var cardinality: LivingMapSDK.Google_Protobuf_Field.Cardinality
  public var number: Swift.Int32
  public var name: Swift.String
  public var typeURL: Swift.String
  public var oneofIndex: Swift.Int32
  public var packed: Swift.Bool
  public var options: [LivingMapSDK.Google_Protobuf_Option]
  public var jsonName: Swift.String
  public var defaultValue: Swift.String
  public var unknownFields: LivingMapSDK.UnknownStorage
  public enum Kind : LivingMapSDK.Enum {
    public typealias RawValue = Swift.Int
    case typeUnknown
    case typeDouble
    case typeFloat
    case typeInt64
    case typeUint64
    case typeInt32
    case typeFixed64
    case typeFixed32
    case typeBool
    case typeString
    case typeGroup
    case typeMessage
    case typeBytes
    case typeUint32
    case typeEnum
    case typeSfixed32
    case typeSfixed64
    case typeSint32
    case typeSint64
    case UNRECOGNIZED(Swift.Int)
    public init()
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum Cardinality : LivingMapSDK.Enum {
    public typealias RawValue = Swift.Int
    case unknown
    case optional
    case required
    case repeated
    case UNRECOGNIZED(Swift.Int)
    public init()
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public init()
}
extension LivingMapSDK.Google_Protobuf_Field.Kind : Swift.CaseIterable {
  public static var allCases: [LivingMapSDK.Google_Protobuf_Field.Kind]
  public typealias AllCases = [LivingMapSDK.Google_Protobuf_Field.Kind]
}
extension LivingMapSDK.Google_Protobuf_Field.Cardinality : Swift.CaseIterable {
  public static var allCases: [LivingMapSDK.Google_Protobuf_Field.Cardinality]
  public typealias AllCases = [LivingMapSDK.Google_Protobuf_Field.Cardinality]
}
public struct Google_Protobuf_Enum {
  public var name: Swift.String
  public var enumvalue: [LivingMapSDK.Google_Protobuf_EnumValue]
  public var options: [LivingMapSDK.Google_Protobuf_Option]
  public var sourceContext: LivingMapSDK.Google_Protobuf_SourceContext {
    get
    set
  }
  public var hasSourceContext: Swift.Bool {
    get
  }
  public mutating func clearSourceContext()
  public var syntax: LivingMapSDK.Google_Protobuf_Syntax
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
public struct Google_Protobuf_EnumValue {
  public var name: Swift.String
  public var number: Swift.Int32
  public var options: [LivingMapSDK.Google_Protobuf_Option]
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
public struct Google_Protobuf_Option {
  public var name: Swift.String
  public var value: LivingMapSDK.Google_Protobuf_Any {
    get
    set
  }
  public var hasValue: Swift.Bool {
    get
  }
  public mutating func clearValue()
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
extension LivingMapSDK.Google_Protobuf_Syntax : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Type : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Field : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Field.Kind : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Field.Cardinality : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Enum : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_EnumValue : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Option : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Syntax : LivingMapSDK._ProtoNameProviding {
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
}
extension LivingMapSDK.Google_Protobuf_Type : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_Type, rhs: LivingMapSDK.Google_Protobuf_Type) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_Field : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_Field, rhs: LivingMapSDK.Google_Protobuf_Field) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_Field.Kind : LivingMapSDK._ProtoNameProviding {
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
}
extension LivingMapSDK.Google_Protobuf_Field.Cardinality : LivingMapSDK._ProtoNameProviding {
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
}
extension LivingMapSDK.Google_Protobuf_Enum : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_Enum, rhs: LivingMapSDK.Google_Protobuf_Enum) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_EnumValue : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_EnumValue, rhs: LivingMapSDK.Google_Protobuf_EnumValue) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_Option : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_Option, rhs: LivingMapSDK.Google_Protobuf_Option) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public typealias CustomEventAPICallback = (Foundation.NSDictionary?) -> Swift.Void
@_hasMissingDesignatedInitializers public class FileLog {
  public static func info(_ message: Swift.String, tag: Swift.String = "Info", force: Swift.Bool = false, callingFunctionName: Swift.String = #function, _ lineNumber: Swift.UInt = #line, _ fileName: Swift.String = #file)
  public static func info<D>(_ data: D, tag: Swift.String = "Info", force: Swift.Bool = false, callingFunctionName: Swift.String = #function, _ lineNumber: Swift.UInt = #line, _ fileName: Swift.String = #file) where D : Swift.Encodable
  public static func warning(_ message: Any, force: Swift.Bool = false, callingFunctionName: Swift.String = #function, _ lineNumber: Swift.UInt = #line, _ fileName: Swift.String = #file)
  public static func error(_ message: Any, force: Swift.Bool = false, callingFunctionName: Swift.String = #function, _ lineNumber: Swift.UInt = #line, _ fileName: Swift.String = #file)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class LMFileLogger {
  public static let shared: LivingMapSDK.LMFileLogger
  public func enableFileLogging()
  @objc deinit
}
public class LiveDataController {
  public init(id: Swift.String, secret: Swift.String, environment: Swift.String, deviceCategory: Swift.String?)
  public func startDataUpload(frequency: Foundation.TimeInterval = LiveDataConstants.upperBoundUploadFrequency, timeout: Foundation.TimeInterval = LiveDataConstants.lowerBoundTimeout) -> Swift.Bool
  public func stopDataUpload() -> Swift.Bool
  public func update(journeyStart start: LivingMapSDK.LMLocation, journeyEnd end: LivingMapSDK.LMLocation, journeyInfo info: LivingMapSDK.JourneyInfo, meta: LivingMapSDK.JourneyMetaData) -> Swift.String
  public func update(location: LivingMapSDK.LMLocation, status: LivingMapSDK.JourneyStatus? = nil)
  @objc deinit
}
public protocol LivingMapMappingEvents : LivingMapSDK.LivingMapPositioningEvents {
  func mapReady()
  func mapClosed()
  func destinationReached()
}
public enum AnyUnpackError : Swift.Error {
  case typeMismatch
  case malformedWellKnownTypeJSON
  case malformedAnyField
  public static func == (a: LivingMapSDK.AnyUnpackError, b: LivingMapSDK.AnyUnpackError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol RoutingCompletionHandler {
  func onRoutingError(error: Foundation.NSError)
  func onRoutingUpdate(request: LivingMapSDK.RoutingRequest, response: Foundation.NSDictionary)
}
public protocol FieldType {
  associatedtype BaseType : Swift.Hashable
  static var proto3DefaultValue: Self.BaseType { get }
  static func decodeSingular<D>(value: inout Self.BaseType?, from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  static func decodeRepeated<D>(value: inout [Self.BaseType], from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  static func visitSingular<V>(value: Self.BaseType, fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  static func visitRepeated<V>(value: [Self.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  static func visitPacked<V>(value: [Self.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
}
public protocol MapKeyType : LivingMapSDK.FieldType {
  static func _lessThan(lhs: Self.BaseType, rhs: Self.BaseType) -> Swift.Bool
}
extension LivingMapSDK.MapKeyType where Self.BaseType : Swift.Comparable {
  public static func _lessThan(lhs: Self.BaseType, rhs: Self.BaseType) -> Swift.Bool
}
public protocol MapValueType : LivingMapSDK.FieldType {
}
public struct ProtobufFloat : LivingMapSDK.FieldType, LivingMapSDK.MapValueType {
  public typealias BaseType = Swift.Float
  public static var proto3DefaultValue: Swift.Float {
    get
  }
  public static func decodeSingular<D>(value: inout LivingMapSDK.ProtobufFloat.BaseType?, from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func decodeRepeated<D>(value: inout [LivingMapSDK.ProtobufFloat.BaseType], from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func visitSingular<V>(value: LivingMapSDK.ProtobufFloat.BaseType, fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitRepeated<V>(value: [LivingMapSDK.ProtobufFloat.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitPacked<V>(value: [LivingMapSDK.ProtobufFloat.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
}
public struct ProtobufDouble : LivingMapSDK.FieldType, LivingMapSDK.MapValueType {
  public typealias BaseType = Swift.Double
  public static var proto3DefaultValue: Swift.Double {
    get
  }
  public static func decodeSingular<D>(value: inout LivingMapSDK.ProtobufDouble.BaseType?, from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func decodeRepeated<D>(value: inout [LivingMapSDK.ProtobufDouble.BaseType], from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func visitSingular<V>(value: LivingMapSDK.ProtobufDouble.BaseType, fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitRepeated<V>(value: [LivingMapSDK.ProtobufDouble.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitPacked<V>(value: [LivingMapSDK.ProtobufDouble.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
}
public struct ProtobufInt32 : LivingMapSDK.FieldType, LivingMapSDK.MapKeyType, LivingMapSDK.MapValueType {
  public typealias BaseType = Swift.Int32
  public static var proto3DefaultValue: Swift.Int32 {
    get
  }
  public static func decodeSingular<D>(value: inout LivingMapSDK.ProtobufInt32.BaseType?, from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func decodeRepeated<D>(value: inout [LivingMapSDK.ProtobufInt32.BaseType], from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func visitSingular<V>(value: LivingMapSDK.ProtobufInt32.BaseType, fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitRepeated<V>(value: [LivingMapSDK.ProtobufInt32.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitPacked<V>(value: [LivingMapSDK.ProtobufInt32.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
}
public struct ProtobufInt64 : LivingMapSDK.FieldType, LivingMapSDK.MapKeyType, LivingMapSDK.MapValueType {
  public typealias BaseType = Swift.Int64
  public static var proto3DefaultValue: Swift.Int64 {
    get
  }
  public static func decodeSingular<D>(value: inout LivingMapSDK.ProtobufInt64.BaseType?, from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func decodeRepeated<D>(value: inout [LivingMapSDK.ProtobufInt64.BaseType], from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func visitSingular<V>(value: LivingMapSDK.ProtobufInt64.BaseType, fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitRepeated<V>(value: [LivingMapSDK.ProtobufInt64.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitPacked<V>(value: [LivingMapSDK.ProtobufInt64.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
}
public struct ProtobufUInt32 : LivingMapSDK.FieldType, LivingMapSDK.MapKeyType, LivingMapSDK.MapValueType {
  public typealias BaseType = Swift.UInt32
  public static var proto3DefaultValue: Swift.UInt32 {
    get
  }
  public static func decodeSingular<D>(value: inout LivingMapSDK.ProtobufUInt32.BaseType?, from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func decodeRepeated<D>(value: inout [LivingMapSDK.ProtobufUInt32.BaseType], from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func visitSingular<V>(value: LivingMapSDK.ProtobufUInt32.BaseType, fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitRepeated<V>(value: [LivingMapSDK.ProtobufUInt32.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitPacked<V>(value: [LivingMapSDK.ProtobufUInt32.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
}
public struct ProtobufUInt64 : LivingMapSDK.FieldType, LivingMapSDK.MapKeyType, LivingMapSDK.MapValueType {
  public typealias BaseType = Swift.UInt64
  public static var proto3DefaultValue: Swift.UInt64 {
    get
  }
  public static func decodeSingular<D>(value: inout LivingMapSDK.ProtobufUInt64.BaseType?, from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func decodeRepeated<D>(value: inout [LivingMapSDK.ProtobufUInt64.BaseType], from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func visitSingular<V>(value: LivingMapSDK.ProtobufUInt64.BaseType, fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitRepeated<V>(value: [LivingMapSDK.ProtobufUInt64.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitPacked<V>(value: [LivingMapSDK.ProtobufUInt64.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
}
public struct ProtobufSInt32 : LivingMapSDK.FieldType, LivingMapSDK.MapKeyType, LivingMapSDK.MapValueType {
  public typealias BaseType = Swift.Int32
  public static var proto3DefaultValue: Swift.Int32 {
    get
  }
  public static func decodeSingular<D>(value: inout LivingMapSDK.ProtobufSInt32.BaseType?, from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func decodeRepeated<D>(value: inout [LivingMapSDK.ProtobufSInt32.BaseType], from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func visitSingular<V>(value: LivingMapSDK.ProtobufSInt32.BaseType, fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitRepeated<V>(value: [LivingMapSDK.ProtobufSInt32.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitPacked<V>(value: [LivingMapSDK.ProtobufSInt32.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
}
public struct ProtobufSInt64 : LivingMapSDK.FieldType, LivingMapSDK.MapKeyType, LivingMapSDK.MapValueType {
  public typealias BaseType = Swift.Int64
  public static var proto3DefaultValue: Swift.Int64 {
    get
  }
  public static func decodeSingular<D>(value: inout LivingMapSDK.ProtobufSInt64.BaseType?, from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func decodeRepeated<D>(value: inout [LivingMapSDK.ProtobufSInt64.BaseType], from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func visitSingular<V>(value: LivingMapSDK.ProtobufSInt64.BaseType, fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitRepeated<V>(value: [LivingMapSDK.ProtobufSInt64.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitPacked<V>(value: [LivingMapSDK.ProtobufSInt64.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
}
public struct ProtobufFixed32 : LivingMapSDK.FieldType, LivingMapSDK.MapKeyType, LivingMapSDK.MapValueType {
  public typealias BaseType = Swift.UInt32
  public static var proto3DefaultValue: Swift.UInt32 {
    get
  }
  public static func decodeSingular<D>(value: inout LivingMapSDK.ProtobufFixed32.BaseType?, from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func decodeRepeated<D>(value: inout [LivingMapSDK.ProtobufFixed32.BaseType], from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func visitSingular<V>(value: LivingMapSDK.ProtobufFixed32.BaseType, fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitRepeated<V>(value: [LivingMapSDK.ProtobufFixed32.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitPacked<V>(value: [LivingMapSDK.ProtobufFixed32.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
}
public struct ProtobufFixed64 : LivingMapSDK.FieldType, LivingMapSDK.MapKeyType, LivingMapSDK.MapValueType {
  public typealias BaseType = Swift.UInt64
  public static var proto3DefaultValue: Swift.UInt64 {
    get
  }
  public static func decodeSingular<D>(value: inout LivingMapSDK.ProtobufFixed64.BaseType?, from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func decodeRepeated<D>(value: inout [LivingMapSDK.ProtobufFixed64.BaseType], from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func visitSingular<V>(value: LivingMapSDK.ProtobufFixed64.BaseType, fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitRepeated<V>(value: [LivingMapSDK.ProtobufFixed64.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitPacked<V>(value: [LivingMapSDK.ProtobufFixed64.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
}
public struct ProtobufSFixed32 : LivingMapSDK.FieldType, LivingMapSDK.MapKeyType, LivingMapSDK.MapValueType {
  public typealias BaseType = Swift.Int32
  public static var proto3DefaultValue: Swift.Int32 {
    get
  }
  public static func decodeSingular<D>(value: inout LivingMapSDK.ProtobufSFixed32.BaseType?, from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func decodeRepeated<D>(value: inout [LivingMapSDK.ProtobufSFixed32.BaseType], from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func visitSingular<V>(value: LivingMapSDK.ProtobufSFixed32.BaseType, fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitRepeated<V>(value: [LivingMapSDK.ProtobufSFixed32.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitPacked<V>(value: [LivingMapSDK.ProtobufSFixed32.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
}
public struct ProtobufSFixed64 : LivingMapSDK.FieldType, LivingMapSDK.MapKeyType, LivingMapSDK.MapValueType {
  public typealias BaseType = Swift.Int64
  public static var proto3DefaultValue: Swift.Int64 {
    get
  }
  public static func decodeSingular<D>(value: inout LivingMapSDK.ProtobufSFixed64.BaseType?, from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func decodeRepeated<D>(value: inout [LivingMapSDK.ProtobufSFixed64.BaseType], from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func visitSingular<V>(value: LivingMapSDK.ProtobufSFixed64.BaseType, fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitRepeated<V>(value: [LivingMapSDK.ProtobufSFixed64.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitPacked<V>(value: [LivingMapSDK.ProtobufSFixed64.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
}
public struct ProtobufBool : LivingMapSDK.FieldType, LivingMapSDK.MapKeyType, LivingMapSDK.MapValueType {
  public typealias BaseType = Swift.Bool
  public static var proto3DefaultValue: Swift.Bool {
    get
  }
  public static func decodeSingular<D>(value: inout LivingMapSDK.ProtobufBool.BaseType?, from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func decodeRepeated<D>(value: inout [LivingMapSDK.ProtobufBool.BaseType], from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func visitSingular<V>(value: LivingMapSDK.ProtobufBool.BaseType, fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitRepeated<V>(value: [LivingMapSDK.ProtobufBool.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitPacked<V>(value: [LivingMapSDK.ProtobufBool.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func _lessThan(lhs: LivingMapSDK.ProtobufBool.BaseType, rhs: LivingMapSDK.ProtobufBool.BaseType) -> Swift.Bool
}
public struct ProtobufString : LivingMapSDK.FieldType, LivingMapSDK.MapKeyType, LivingMapSDK.MapValueType {
  public typealias BaseType = Swift.String
  public static var proto3DefaultValue: Swift.String {
    get
  }
  public static func decodeSingular<D>(value: inout LivingMapSDK.ProtobufString.BaseType?, from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func decodeRepeated<D>(value: inout [LivingMapSDK.ProtobufString.BaseType], from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func visitSingular<V>(value: LivingMapSDK.ProtobufString.BaseType, fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitRepeated<V>(value: [LivingMapSDK.ProtobufString.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitPacked<V>(value: [LivingMapSDK.ProtobufString.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
}
public struct ProtobufBytes : LivingMapSDK.FieldType, LivingMapSDK.MapValueType {
  public typealias BaseType = Foundation.Data
  public static var proto3DefaultValue: Foundation.Data {
    get
  }
  public static func decodeSingular<D>(value: inout LivingMapSDK.ProtobufBytes.BaseType?, from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func decodeRepeated<D>(value: inout [LivingMapSDK.ProtobufBytes.BaseType], from decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public static func visitSingular<V>(value: LivingMapSDK.ProtobufBytes.BaseType, fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitRepeated<V>(value: [LivingMapSDK.ProtobufBytes.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func visitPacked<V>(value: [LivingMapSDK.ProtobufBytes.BaseType], fieldNumber: Swift.Int, with visitor: inout V) throws where V : LivingMapSDK.Visitor
}
extension UIKit.UIAlertController {
  @_Concurrency.MainActor(unsafe) public func show()
}
extension LivingMapSDK.CPLMetrics : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension LivingMapSDK.CalibrationMatrices : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct KalmanFilter<Type> where Type : LivingMapSDK.KalmanInput {
  public let stateEstimatePrior: Type
  public let errorCovariancePrior: Type
  public init(stateEstimatePrior: Type, errorCovariancePrior: Type)
  public func predict(stateTransitionModel: Type, controlInputModel: Type, controlVector: Type, covarianceOfProcessNoise: Type) -> LivingMapSDK.KalmanFilter<Type>
  public func update(measurement: Type, observationModel: Type, covarienceOfObservationNoise: Type) -> LivingMapSDK.KalmanFilter<Type>
}
extension Foundation.URLSessionConfiguration : LivingMapSDK.AlamofireExtended {
  public typealias ExtendedType = Foundation.URLSessionConfiguration
}
extension LivingMapSDK.AlamofireExtension where ExtendedType : Foundation.URLSessionConfiguration {
  public static var `default`: Foundation.URLSessionConfiguration {
    get
  }
  public static var ephemeral: Foundation.URLSessionConfiguration {
    get
  }
}
public protocol LivingMapInterface : LivingMapSDK.LivingMapPositioningEvents {
  func elevationStatusUpdated(status: Swift.String)
  func headingReceived(heading: LivingMapSDK.LMHeading, sendToFrontend: Swift.Bool)
  func stepInfoUpdated(_ step: LivingMapSDK.LMStep)
}
extension LivingMapSDK.Request {
  public static let didResumeNotification: Foundation.Notification.Name
  public static let didSuspendNotification: Foundation.Notification.Name
  public static let didCancelNotification: Foundation.Notification.Name
  public static let didFinishNotification: Foundation.Notification.Name
  public static let didResumeTaskNotification: Foundation.Notification.Name
  public static let didSuspendTaskNotification: Foundation.Notification.Name
  public static let didCancelTaskNotification: Foundation.Notification.Name
  public static let didCompleteTaskNotification: Foundation.Notification.Name
}
extension Foundation.Notification {
  public var request: LivingMapSDK.Request? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class AlamofireNotifications : LivingMapSDK.EventMonitor {
  final public func requestDidResume(_ request: LivingMapSDK.Request)
  final public func requestDidSuspend(_ request: LivingMapSDK.Request)
  final public func requestDidCancel(_ request: LivingMapSDK.Request)
  final public func requestDidFinish(_ request: LivingMapSDK.Request)
  final public func request(_ request: LivingMapSDK.Request, didResumeTask task: Foundation.URLSessionTask)
  final public func request(_ request: LivingMapSDK.Request, didSuspendTask task: Foundation.URLSessionTask)
  final public func request(_ request: LivingMapSDK.Request, didCancelTask task: Foundation.URLSessionTask)
  final public func request(_ request: LivingMapSDK.Request, didCompleteTask task: Foundation.URLSessionTask, with error: LivingMapSDK.AFError?)
  @objc deinit
}
public typealias AFResult<Success> = Swift.Result<Success, LivingMapSDK.AFError>
public enum Model : Swift.String {
  case simulator, iPhone4, iPhone4S, iPhone5, iPhone5S, iPhone5C, iPhone6, iPhone6Plus, iPhone6S, iPhone6SPlus, iPhoneSE, iPhone7, iPhone7Plus, iPhone8, iPhone8Plus, iPhoneX, iPhoneXS, iPhoneXSMax, iPhoneXR, iPhone11, iPhone11Pro, iPhone11ProMax, iPhoneSE2, iPhone12Mini, iPhone12, iPhone12Pro, iPhone12ProMax, iPhone13Mini, iPhone13, iPhone13Pro, iPhone13ProMax, iPhoneSE3, unrecognized
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor(unsafe) public var type: LivingMapSDK.Model {
    get
  }
}
open class RoutingController {
  public init(sdkManager: LivingMapSDK.LivingMapSDKManager)
  public func routingConnectivityStatus(connectivityStatus: LivingMapSDK.LivingMapConstants.ConnectivityStatus) -> Self
  public func from(location: LivingMapSDK.RouteLocation) -> Self
  public func to(location: LivingMapSDK.RouteLocation) -> Self
  public func via(location: LivingMapSDK.RouteLocation) -> Self
  public func gate(initialized: Swift.Bool) -> Self
  public func route(options: LivingMapSDK.RoutingRequestOptions, callback: LivingMapSDK.CustomEventAPICallback? = nil) throws
  public func onPositioningReady()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class LMHeading : Swift.Codable {
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
public enum HeadingEstimateType : Swift.String, Swift.Codable, Swift.CaseIterable {
  case none
  case mag
  case cpl
  case device
  public init?(rawValue: Swift.String)
  public typealias AllCases = [LivingMapSDK.HeadingEstimateType]
  public typealias RawValue = Swift.String
  public static var allCases: [LivingMapSDK.HeadingEstimateType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum HeadingType : Swift.String, Swift.Codable, Swift.CaseIterable {
  case DEVICE
  case ADJUSTED
  case CPL
  public init?(rawValue: Swift.String)
  public typealias AllCases = [LivingMapSDK.HeadingType]
  public typealias RawValue = Swift.String
  public static var allCases: [LivingMapSDK.HeadingType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct LMStepConfig : Swift.Codable {
  public var readingsHistoryLength: Swift.Int
  public var deviationLowerThreshold: Swift.Double
  public var deviationUpperThreshold: Swift.Double
  public var standardDeviations: Swift.Double
  public var maxStepTimeInterval: Swift.Double
  public var minStepTimeInterval: Swift.Double
  public var stepTimeIntervalHistorySize: Swift.Int
  public var maxNumConsecutiveInjectedSteps: Swift.Int
  public var stoppedWalkingThreshold: Swift.Double
  public let intialStepCountToDrop: Swift.Int
  public init(readingsHistoryLength: Swift.Int = 50, deviationLowerThreshold: Swift.Double = 0.07, deviationUpperThreshold: Swift.Double = 0.50, standardDeviations: Swift.Double = 0.8, minStepTimeInterval: Swift.Double = 0.4, maxStepTimeInterval: Swift.Double = 2, stepTimeIntervalHistorySize: Swift.Int = 20, maxNumConsecutiveInjectedSteps: Swift.Int = 2, stoppedWalkingThreshold: Swift.Double = 3.0, intialStepCountToDrop: Swift.Int = 3)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers final public class Resolver<T> {
  @objc deinit
}
extension LivingMapSDK.Resolver {
  final public func fulfill(_ value: T)
  final public func reject(_ error: any Swift.Error)
  final public func resolve(_ result: LivingMapSDK.Result<T>)
  final public func resolve(_ obj: T?, _ error: (any Swift.Error)?)
  final public func resolve(_ obj: T, _ error: (any Swift.Error)?)
  final public func resolve(_ error: (any Swift.Error)?, _ obj: T?)
}
extension LivingMapSDK.Resolver where T == () {
  final public func resolve(_ error: (any Swift.Error)?)
  final public func fulfill_()
}
extension LivingMapSDK.Resolver {
  final public func resolve<E>(_ result: Swift.Result<T, E>) where E : Swift.Error
}
public enum Result<T> {
  case fulfilled(T)
  case rejected(any Swift.Error)
}
extension LivingMapSDK.Result {
  public var isFulfilled: Swift.Bool {
    get
  }
}
extension LivingMapSDK.Request {
  public typealias ValidationResult = Swift.Result<Swift.Void, any Swift.Error>
}
extension LivingMapSDK.DataRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?) -> LivingMapSDK.DataRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension LivingMapSDK.DataStreamRequest {
  public typealias Validation = (_ request: Foundation.URLRequest?, _ response: Foundation.HTTPURLResponse) -> LivingMapSDK.DataStreamRequest.ValidationResult
  @discardableResult
  final public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  final public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  final public func validate() -> Self
}
extension LivingMapSDK.DownloadRequest {
  public typealias Validation = (_ request: Foundation.URLRequest?, _ response: Foundation.HTTPURLResponse, _ fileURL: Foundation.URL?) -> LivingMapSDK.DownloadRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
@_hasMissingDesignatedInitializers public class LivePositioningManager {
  public var liveDataController: LivingMapSDK.LiveDataController?
  public func startUpdating()
  public func stopUpdating()
  public func set(location newLocation: LivingMapSDK.LMLocation) -> Swift.Bool
  @objc deinit
}
extension LivingMapSDK.LivePositioningManager {
  public func routeLoadFailed()
}
public enum LMLogLevel : Swift.Int, Swift.CaseIterable {
  case debug
  case info
  case event
  case warning
  case error
  case exception
  case none
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [LivingMapSDK.LMLogLevel]
  public typealias RawValue = Swift.Int
  public static var allCases: [LivingMapSDK.LMLogLevel] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
public protocol LMLogConfigurationProtocol {
  var logLevel: LivingMapSDK.LMLogLevel { get }
  var filter: ((Swift.String) -> (Swift.Bool))? { get }
  var display: [LivingMapSDK.LMLogLevel : LivingMapSDK.LMLogLevelDisplay] { get }
}
public enum LMLogLevelDisplay {
  case all(console: Swift.Bool? = true, timestamp: Swift.Bool? = true, filename: Swift.Bool? = true, function: Swift.Bool? = true, line: Swift.Bool? = true)
  case debug(console: Swift.Bool? = true, timestamp: Swift.Bool? = true, filename: Swift.Bool? = true, function: Swift.Bool? = true, line: Swift.Bool? = true)
  case info(console: Swift.Bool? = true, timestamp: Swift.Bool? = true, filename: Swift.Bool? = false, function: Swift.Bool? = false, line: Swift.Bool? = false)
  case event(console: Swift.Bool? = true, timestamp: Swift.Bool? = true, filename: Swift.Bool? = true, function: Swift.Bool? = true, line: Swift.Bool? = true)
  case warning(console: Swift.Bool? = true, timestamp: Swift.Bool? = true, filename: Swift.Bool? = true, function: Swift.Bool? = true, line: Swift.Bool? = true)
  case error(console: Swift.Bool? = true, timestamp: Swift.Bool? = true, filename: Swift.Bool? = true, function: Swift.Bool? = true, line: Swift.Bool? = true)
  case exception(console: Swift.Bool? = true, timestamp: Swift.Bool? = true, filename: Swift.Bool? = true, function: Swift.Bool? = true, line: Swift.Bool? = true)
}
public struct LMLogConfig : LivingMapSDK.LMLogConfigurationProtocol {
  public var logLevel: LivingMapSDK.LMLogLevel
  public var filter: ((Swift.String) -> (Swift.Bool))?
  public var display: [LivingMapSDK.LMLogLevel : LivingMapSDK.LMLogLevelDisplay]
  public init(logLevel: LivingMapSDK.LMLogLevel = .none, filter: ((Swift.String) -> (Swift.Bool))? = nil, display: LivingMapSDK.LMLogLevelDisplay...)
}
@_hasMissingDesignatedInitializers public class log {
  public static func debug(_ message: Any..., force: Swift.Bool = false, callingFunctionName: Swift.String = #function, _ lineNumber: Swift.UInt = #line, _ fileName: Swift.String = #file)
  public static func info(_ message: Any..., force: Swift.Bool = false, callingFunctionName: Swift.String = #function, _ lineNumber: Swift.UInt = #line, _ fileName: Swift.String = #file)
  public static func event(_ message: Any..., force: Swift.Bool = false, callingFunctionName: Swift.String = #function, _ lineNumber: Swift.UInt = #line, _ fileName: Swift.String = #file)
  public static func warning(_ message: Any..., force: Swift.Bool = false, callingFunctionName: Swift.String = #function, _ lineNumber: Swift.UInt = #line, _ fileName: Swift.String = #file)
  public static func error(_ message: Any..., force: Swift.Bool = false, callingFunctionName: Swift.String = #function, _ lineNumber: Swift.UInt = #line, _ fileName: Swift.String = #file)
  public static func exception(_ message: Any..., force: Swift.Bool = false, callingFunctionName: Swift.String = #function, _ lineNumber: Swift.UInt = #line, _ fileName: Swift.String = #file)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class LMLogger {
  public static let shared: LivingMapSDK.LMLogger
  public var configuration: any LivingMapSDK.LMLogConfigurationProtocol
  @objc deinit
}
public struct CPLLocationConfig : Swift.Codable {
  public var lowerBoundWaitingToUploadData: Swift.Double
  public var timeIntervalBufferSensorData: Swift.Double
  public var syncTimeInterval: Swift.Double
  public var injectLikelihood: Swift.Int
  public var initializationInjectLikelihood: Swift.Double
  public var assistingLocationMaxAge: Swift.Double
  public var cplRunConfigFilePath: Swift.String
  public var resetInitializationRange: Swift.Double
  public var pathInitializationLength: Swift.Double
  public init(lowerBoundWaitingToUploadData: Swift.Double = 0.3, timeIntervalBufferSensorData: Swift.Double = 1.0, syncTimeInterval: Swift.Double = 0.02, injectLikelihood: Swift.Int = 20, initializationInjectLikelihood: Swift.Double = 1.0, assistingLocationMaxAge: Swift.Double = 10.0, cplRunConfigFilePath: Swift.String, resetInitializationRange: Swift.Double = 5.0, pathInitializationLength: Swift.Double = 10.0)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers final public class Promise<T> : LivingMapSDK.Thenable, LivingMapSDK.CatchMixin {
  public static func value(_ value: T) -> LivingMapSDK.Promise<T>
  public init(error: any Swift.Error)
  public init<U>(_ bridge: U) where T == U.T, U : LivingMapSDK.Thenable
  public init(resolver body: (LivingMapSDK.Resolver<T>) throws -> Swift.Void)
  final public class func pending() -> (promise: LivingMapSDK.Promise<T>, resolver: LivingMapSDK.Resolver<T>)
  final public func pipe(to: @escaping (LivingMapSDK.Result<T>) -> Swift.Void)
  final public var result: LivingMapSDK.Result<T>? {
    get
  }
  @objc deinit
}
extension LivingMapSDK.Promise {
  final public func wait() throws -> T
}
extension LivingMapSDK.Promise where T == () {
  convenience public init()
  public static var value: LivingMapSDK.Promise<Swift.Void> {
    get
  }
}
extension Dispatch.DispatchQueue {
  @available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *)
  final public func async<T>(_: LivingMapSDK.PMKNamespacer, group: Dispatch.DispatchGroup? = nil, qos: Dispatch.DispatchQoS = .default, flags: Dispatch.DispatchWorkItemFlags = [], execute body: @escaping () throws -> T) -> LivingMapSDK.Promise<T>
}
public enum PMKNamespacer {
  case promise
  public static func == (a: LivingMapSDK.PMKNamespacer, b: LivingMapSDK.PMKNamespacer) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
open class MultipartFormData {
  public static let encodingMemoryThreshold: Swift.UInt64
  open var contentType: Swift.String {
    get
    set
  }
  public var contentLength: Swift.UInt64 {
    get
  }
  final public let boundary: Swift.String
  public init(fileManager: Foundation.FileManager = .default, boundary: Swift.String? = nil)
  public func append(_ data: Foundation.Data, withName name: Swift.String, fileName: Swift.String? = nil, mimeType: Swift.String? = nil)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, headers: LivingMapSDK.HTTPHeaders)
  public func encode() throws -> Foundation.Data
  public func writeEncodedData(to fileURL: Foundation.URL) throws
  @objc deinit
}
public func after(seconds: Foundation.TimeInterval) -> LivingMapSDK.Guarantee<Swift.Void>
public func after(_ interval: Dispatch.DispatchTimeInterval) -> LivingMapSDK.Guarantee<Swift.Void>
public enum MapView : Swift.String {
  case ROUTING
  case MAP
  case NAVIGATION
  case DOWNLOADING_MAP
  case MAP_DOWNLOAD_FAILED
  case NO_INTERNET_CONNECTION
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum CacheProgress : Swift.String {
  case GETTING_CACHE_MANIFEST, GETTING_CACHE_CHECKSUMS, GETTING_CACHE_PACKS, DECOMPRESSING_CACHE_PACKS, MAP_CACHE_IS_READY, MAP_CACHE_IS_UP_TO_DATE, POSITIONING_CACHE_IS_READY, POSITIONING_CACHE_IS_UP_TO_DATE
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public class LivingMapSDKMCacheManager {
  final public let monitor: LivingMapSDK.ConnectivityMonitor
  public init(authenticationParameters: LivingMapSDK.AuthenticationParameters, monitor: LivingMapSDK.ConnectivityMonitor? = nil)
  public func initialiseCache(manifestURL: Swift.String, key: [Swift.String : Swift.String], manifestCallbacks: LivingMapSDK.ManifestCallbacks)
  public func retrieveCacheManifest(manifestURL: Swift.String, key: [Swift.String : Swift.String], manifestCallback: LivingMapSDK.ManifestCallbacks)
  public func getCachedManifests() -> [LivingMapSDK.CacheManifest]
  @discardableResult
  public class func clearOfflineAssets(subDirectory: Swift.String? = nil) -> Swift.Bool
  @discardableResult
  public func clearOfflineAssets(subDirectory: Swift.String? = nil) -> Swift.Bool
  public func retrieveManifestFromCache(key: [Swift.String : Swift.String]) throws -> LivingMapSDK.CacheManifest?
  public func deleteManifestFromCache(key: [Swift.String : Swift.String], subDirectory: Swift.String) throws
  public func updateLocalCacheManifest(cacheManifest: LivingMapSDK.CacheManifest) throws
  @objc deinit
}
extension LivingMapSDK.Promise : Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
}
extension LivingMapSDK.Promise : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
public protocol RedirectHandler {
  func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct Redirector {
  public enum Behavior {
    case follow
    case doNotFollow
    case modify((Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?)
  }
  public static let follow: LivingMapSDK.Redirector
  public static let doNotFollow: LivingMapSDK.Redirector
  public let behavior: LivingMapSDK.Redirector.Behavior
  public init(behavior: LivingMapSDK.Redirector.Behavior)
}
extension LivingMapSDK.Redirector : LivingMapSDK.RedirectHandler {
  public func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
extension LivingMapSDK.RedirectHandler where Self == LivingMapSDK.Redirector {
  public static var follow: LivingMapSDK.Redirector {
    get
  }
  public static var doNotFollow: LivingMapSDK.Redirector {
    get
  }
  public static func modify(using closure: @escaping (Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?) -> LivingMapSDK.Redirector
}
public struct _NameMap : Swift.ExpressibleByDictionaryLiteral {
  public enum NameDescription {
    case same(proto: Swift.StaticString)
    case standard(proto: Swift.StaticString)
    case unique(proto: Swift.StaticString, json: Swift.StaticString)
    case aliased(proto: Swift.StaticString, aliases: [Swift.StaticString])
  }
  public init()
  public init(dictionaryLiteral elements: (Swift.Int, LivingMapSDK._NameMap.NameDescription)...)
  public typealias Key = Swift.Int
  public typealias Value = LivingMapSDK._NameMap.NameDescription
}
@_hasMissingDesignatedInitializers public class LiveDataConstants {
  public static let lowerBoundTimeout: Swift.Double
  public static let upperBoundUploadFrequency: Swift.Double
  public static let genericDeviceCategory: Swift.String
  public static let aaDeviceCategory: Swift.String
  @objc deinit
}
public struct JSONEncodingOptions {
  public var alwaysPrintEnumsAsInts: Swift.Bool
  public var preserveProtoFieldNames: Swift.Bool
  public init()
}
@_hasMissingDesignatedInitializers open class LivingMapConstants {
  public static let HTTP_PROTOCOL: Swift.String
  public static let URL_SCHEME: Swift.String
  public static let HTTP_ORIGIN_KEY: Swift.String
  public static let HTTP_ORIGIN_VALUE_TEMPLATE: Swift.String
  public static let URL_SCHEME_FORMATTED: Swift.String
  public static let SLASH: Swift.String
  public static let SCREEN_MODE: Swift.String
  public static let MOBILESDK: Swift.String
  public static let DISABLE_WEBVIEW_GEOLOCATION: Swift.String
  public static let URL_VIEW_VALUE: Swift.String
  public static let ALTITUDE_STATUS_STRINGS: [Swift.String]
  public static let OFFLINE_STORAGE: Swift.String
  public static let OFFLINE_STORAGE_DIRNAME: Swift.String
  public static let OFFLINE_MAPURL_SCHEME: Swift.String
  public static let CACHE_ENDPOINT: Swift.String
  public static let FLOOR_HEIGHTS_FILE: Swift.String
  public static let FLOOR_MAPPING_FILE: Swift.String
  public static let LANDMARKS_FILE: Swift.String
  public static let POSITIONING_ASSETS_ROOT_DIRECTORY: Swift.String
  public static let GRIDS_CACHE_DIRECTORY: Swift.String
  public static let JSON_ASSETS_CACHE_DIRECTORY: Swift.String
  public static let MAG_FILE: Swift.String
  public static let BEACON_FILE: Swift.String
  public static let ROUTING_FILE: Swift.String
  public static let ROUTING_DIR: Swift.String
  public enum ConnectivityStatus : Swift.String {
    case ONLINE
    case OFFLINE
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public static let EXTRAS_POSITIONING_AVAILABLE_KEY: Swift.String
  public static let KEYCLOAK_URL: Swift.String
  public static let KEYCLOAK_LOGIN: Swift.String
  public static let API_ENDPOINT: Swift.String
  public static let CONFIG_ENDPOINT: Swift.String
  public static let CONFIG_DESIGNATOR: Swift.String
  public static let SDK_CONFIG_FILE: Swift.String
  public static let CPL_CONFIG_FILE: Swift.String
  public static let SDK_CONFIG_FILE_AND_SUFFIX: Swift.String
  public static let CPL_CONFIG_FILE_AND_SUFFIX: Swift.String
  public static let CONFIG_STORAGE_DIRECTORY: Swift.String
  public static let JSON: Swift.String
  public static let CONFIG_IDENTIFIER_SDK: Swift.String
  public static let CONFIG_IDENTIFIER_CPL: Swift.String
  public static let CONFIG_CPL_REVISION: Swift.String
  public static let CONFIG_SDK_REVISION: Swift.String
  @objc deinit
}
public protocol ParameterEncoder {
  func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
}
open class JSONParameterEncoder : LivingMapSDK.ParameterEncoder {
  public static var `default`: LivingMapSDK.JSONParameterEncoder {
    get
  }
  public static var prettyPrinted: LivingMapSDK.JSONParameterEncoder {
    get
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var sortedKeys: LivingMapSDK.JSONParameterEncoder {
    get
  }
  public init(encoder: Foundation.JSONEncoder = JSONEncoder())
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  @objc deinit
}
extension LivingMapSDK.ParameterEncoder where Self == LivingMapSDK.JSONParameterEncoder {
  public static var json: LivingMapSDK.JSONParameterEncoder {
    get
  }
}
open class URLEncodedFormParameterEncoder : LivingMapSDK.ParameterEncoder {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: LivingMapSDK.URLEncodedFormParameterEncoder.Destination, b: LivingMapSDK.URLEncodedFormParameterEncoder.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: LivingMapSDK.URLEncodedFormParameterEncoder {
    get
  }
  final public let encoder: LivingMapSDK.URLEncodedFormEncoder
  final public let destination: LivingMapSDK.URLEncodedFormParameterEncoder.Destination
  public init(encoder: LivingMapSDK.URLEncodedFormEncoder = URLEncodedFormEncoder(), destination: LivingMapSDK.URLEncodedFormParameterEncoder.Destination = .methodDependent)
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  @objc deinit
}
extension LivingMapSDK.ParameterEncoder where Self == LivingMapSDK.URLEncodedFormParameterEncoder {
  public static var urlEncodedForm: LivingMapSDK.URLEncodedFormParameterEncoder {
    get
  }
  public static func urlEncodedForm(encoder: LivingMapSDK.URLEncodedFormEncoder = URLEncodedFormEncoder(), destination: LivingMapSDK.URLEncodedFormParameterEncoder.Destination = .methodDependent) -> LivingMapSDK.URLEncodedFormParameterEncoder
}
extension LivingMapSDK.Google_Protobuf_DoubleValue : Swift.ExpressibleByFloatLiteral {
  public typealias WrappedType = LivingMapSDK.ProtobufDouble
  public typealias FloatLiteralType = LivingMapSDK.Google_Protobuf_DoubleValue.WrappedType.BaseType
  public init(_ value: LivingMapSDK.Google_Protobuf_DoubleValue.WrappedType.BaseType)
  public init(floatLiteral: LivingMapSDK.Google_Protobuf_DoubleValue.FloatLiteralType)
}
extension LivingMapSDK.Google_Protobuf_FloatValue : Swift.ExpressibleByFloatLiteral {
  public typealias WrappedType = LivingMapSDK.ProtobufFloat
  public typealias FloatLiteralType = Swift.Float
  public init(_ value: LivingMapSDK.Google_Protobuf_FloatValue.WrappedType.BaseType)
  public init(floatLiteral: LivingMapSDK.Google_Protobuf_FloatValue.FloatLiteralType)
}
extension LivingMapSDK.Google_Protobuf_Int64Value : Swift.ExpressibleByIntegerLiteral {
  public typealias WrappedType = LivingMapSDK.ProtobufInt64
  public typealias IntegerLiteralType = LivingMapSDK.Google_Protobuf_Int64Value.WrappedType.BaseType
  public init(_ value: LivingMapSDK.Google_Protobuf_Int64Value.WrappedType.BaseType)
  public init(integerLiteral: LivingMapSDK.Google_Protobuf_Int64Value.IntegerLiteralType)
}
extension LivingMapSDK.Google_Protobuf_UInt64Value : Swift.ExpressibleByIntegerLiteral {
  public typealias WrappedType = LivingMapSDK.ProtobufUInt64
  public typealias IntegerLiteralType = LivingMapSDK.Google_Protobuf_UInt64Value.WrappedType.BaseType
  public init(_ value: LivingMapSDK.Google_Protobuf_UInt64Value.WrappedType.BaseType)
  public init(integerLiteral: LivingMapSDK.Google_Protobuf_UInt64Value.IntegerLiteralType)
}
extension LivingMapSDK.Google_Protobuf_Int32Value : Swift.ExpressibleByIntegerLiteral {
  public typealias WrappedType = LivingMapSDK.ProtobufInt32
  public typealias IntegerLiteralType = LivingMapSDK.Google_Protobuf_Int32Value.WrappedType.BaseType
  public init(_ value: LivingMapSDK.Google_Protobuf_Int32Value.WrappedType.BaseType)
  public init(integerLiteral: LivingMapSDK.Google_Protobuf_Int32Value.IntegerLiteralType)
}
extension LivingMapSDK.Google_Protobuf_UInt32Value : Swift.ExpressibleByIntegerLiteral {
  public typealias WrappedType = LivingMapSDK.ProtobufUInt32
  public typealias IntegerLiteralType = LivingMapSDK.Google_Protobuf_UInt32Value.WrappedType.BaseType
  public init(_ value: LivingMapSDK.Google_Protobuf_UInt32Value.WrappedType.BaseType)
  public init(integerLiteral: LivingMapSDK.Google_Protobuf_UInt32Value.IntegerLiteralType)
}
extension LivingMapSDK.Google_Protobuf_BoolValue : Swift.ExpressibleByBooleanLiteral {
  public typealias WrappedType = LivingMapSDK.ProtobufBool
  public typealias BooleanLiteralType = Swift.Bool
  public init(_ value: LivingMapSDK.Google_Protobuf_BoolValue.WrappedType.BaseType)
  public init(booleanLiteral: Swift.Bool)
}
extension LivingMapSDK.Google_Protobuf_StringValue : Swift.ExpressibleByStringLiteral {
  public typealias WrappedType = LivingMapSDK.ProtobufString
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
  public init(_ value: LivingMapSDK.Google_Protobuf_StringValue.WrappedType.BaseType)
  public init(stringLiteral: Swift.String)
  public init(extendedGraphemeClusterLiteral: Swift.String)
  public init(unicodeScalarLiteral: Swift.String)
}
extension LivingMapSDK.Google_Protobuf_BytesValue {
  public typealias WrappedType = LivingMapSDK.ProtobufBytes
  public init(_ value: LivingMapSDK.Google_Protobuf_BytesValue.WrappedType.BaseType)
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DataResponsePublisher<Value> : Combine.Publisher {
  public typealias Output = LivingMapSDK.DataResponse<Value, LivingMapSDK.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: LivingMapSDK.DataRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : LivingMapSDK.ResponseSerializer
  public init<Serializer>(_ request: LivingMapSDK.DataRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : LivingMapSDK.DataResponseSerializerProtocol
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, LivingMapSDK.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, LivingMapSDK.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == LivingMapSDK.DataResponse<Value, LivingMapSDK.AFError>
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
extension LivingMapSDK.DataResponsePublisher where Value == Foundation.Data? {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init(_ request: LivingMapSDK.DataRequest, queue: Dispatch.DispatchQueue)
}
extension LivingMapSDK.DataRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> LivingMapSDK.DataResponsePublisher<T> where Serializer : LivingMapSDK.ResponseSerializer, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishData(queue: Dispatch.DispatchQueue = .main, preprocessor: any LivingMapSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> LivingMapSDK.DataResponsePublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishString(queue: Dispatch.DispatchQueue = .main, preprocessor: any LivingMapSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> LivingMapSDK.DataResponsePublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  @available(*, deprecated, message: "Renamed publishDecodable(type:queue:preprocessor:decoder:emptyResponseCodes:emptyRequestMethods).")
  @_disfavoredOverload public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: any LivingMapSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any LivingMapSDK.DataDecoder = JSONDecoder() as DataDecoder, emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyResponseMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> LivingMapSDK.DataResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: any LivingMapSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any LivingMapSDK.DataDecoder = JSONDecoder() as DataDecoder, emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> LivingMapSDK.DataResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishUnserialized(queue: Dispatch.DispatchQueue = .main) -> LivingMapSDK.DataResponsePublisher<Foundation.Data?>
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DataStreamPublisher<Value> : Combine.Publisher {
  public typealias Output = LivingMapSDK.DataStreamRequest.Stream<Value, LivingMapSDK.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: LivingMapSDK.DataStreamRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : LivingMapSDK.DataStreamSerializer
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, LivingMapSDK.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, LivingMapSDK.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == LivingMapSDK.DataStreamRequest.Stream<Value, LivingMapSDK.AFError>
}
extension LivingMapSDK.DataStreamRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> LivingMapSDK.DataStreamPublisher<Serializer.SerializedObject> where Serializer : LivingMapSDK.DataStreamSerializer
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishData(queue: Dispatch.DispatchQueue = .main) -> LivingMapSDK.DataStreamPublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishString(queue: Dispatch.DispatchQueue = .main) -> LivingMapSDK.DataStreamPublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, decoder: any LivingMapSDK.DataDecoder = JSONDecoder() as DataDecoder, preprocessor: any LivingMapSDK.DataPreprocessor = PassthroughPreprocessor()) -> LivingMapSDK.DataStreamPublisher<T> where T : Swift.Decodable
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DownloadResponsePublisher<Value> : Combine.Publisher {
  public typealias Output = LivingMapSDK.DownloadResponse<Value, LivingMapSDK.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: LivingMapSDK.DownloadRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : LivingMapSDK.ResponseSerializer
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init<Serializer>(_ request: LivingMapSDK.DownloadRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : LivingMapSDK.DownloadResponseSerializerProtocol
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, LivingMapSDK.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, LivingMapSDK.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == LivingMapSDK.DownloadResponse<Value, LivingMapSDK.AFError>
}
extension LivingMapSDK.DownloadRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> LivingMapSDK.DownloadResponsePublisher<T> where Serializer : LivingMapSDK.ResponseSerializer, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> LivingMapSDK.DownloadResponsePublisher<T> where Serializer : LivingMapSDK.DownloadResponseSerializerProtocol, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishURL(queue: Dispatch.DispatchQueue = .main) -> LivingMapSDK.DownloadResponsePublisher<Foundation.URL>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishData(queue: Dispatch.DispatchQueue = .main, preprocessor: any LivingMapSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> LivingMapSDK.DownloadResponsePublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishString(queue: Dispatch.DispatchQueue = .main, preprocessor: any LivingMapSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> LivingMapSDK.DownloadResponsePublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  @available(*, deprecated, message: "Renamed publishDecodable(type:queue:preprocessor:decoder:emptyResponseCodes:emptyRequestMethods).")
  @_disfavoredOverload public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: any LivingMapSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any LivingMapSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyResponseMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> LivingMapSDK.DownloadResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: any LivingMapSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any LivingMapSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> LivingMapSDK.DownloadResponsePublisher<T> where T : Swift.Decodable
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
extension LivingMapSDK.DownloadResponsePublisher where Value == Foundation.URL? {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init(_ request: LivingMapSDK.DownloadRequest, queue: Dispatch.DispatchQueue)
}
extension LivingMapSDK.DownloadRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishUnserialized(on queue: Dispatch.DispatchQueue = .main) -> LivingMapSDK.DownloadResponsePublisher<Foundation.URL?>
}
extension LivingMapSDK.Message {
  public func textFormatString() -> Swift.String
  public func textFormatString(options: LivingMapSDK.TextFormatEncodingOptions) -> Swift.String
  public init(textFormatString: Swift.String, options: LivingMapSDK.TextFormatDecodingOptions = TextFormatDecodingOptions(), extensions: (any LivingMapSDK.ExtensionMap)? = nil) throws
}
public enum Internal {
  public static let emptyData: Foundation.Data
  public static func areAllInitialized(_ listOfMessages: [any LivingMapSDK.Message]) -> Swift.Bool
  public static func areAllInitialized<K>(_ mapToMessages: [K : any LivingMapSDK.Message]) -> Swift.Bool where K : Swift.Hashable
}
public protocol Thenable : AnyObject {
  associatedtype T
  func pipe(to: @escaping (LivingMapSDK.Result<Self.T>) -> Swift.Void)
  var result: LivingMapSDK.Result<Self.T>? { get }
}
extension LivingMapSDK.Thenable {
  public func then<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (Self.T) throws -> U) -> LivingMapSDK.Promise<U.T> where U : LivingMapSDK.Thenable
  public func map<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (Self.T) throws -> U) -> LivingMapSDK.Promise<U>
  public func compactMap<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (Self.T) throws -> U?) -> LivingMapSDK.Promise<U>
  public func done(on: Dispatch.DispatchQueue? = conf.Q.return, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (Self.T) throws -> Swift.Void) -> LivingMapSDK.Promise<Swift.Void>
  public func get(on: Dispatch.DispatchQueue? = conf.Q.return, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (Self.T) throws -> Swift.Void) -> LivingMapSDK.Promise<Self.T>
  public func tap(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (LivingMapSDK.Result<Self.T>) -> Swift.Void) -> LivingMapSDK.Promise<Self.T>
  public func asVoid() -> LivingMapSDK.Promise<Swift.Void>
}
extension LivingMapSDK.Thenable {
  public var error: (any Swift.Error)? {
    get
  }
  public var isPending: Swift.Bool {
    get
  }
  public var isResolved: Swift.Bool {
    get
  }
  public var isFulfilled: Swift.Bool {
    get
  }
  public var isRejected: Swift.Bool {
    get
  }
  public var value: Self.T? {
    get
  }
}
extension LivingMapSDK.Thenable where Self.T : Swift.Sequence {
  public func mapValues<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (Self.T.Iterator.Element) throws -> U) -> LivingMapSDK.Promise<[U]>
  public func flatMapValues<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (Self.T.Iterator.Element) throws -> U) -> LivingMapSDK.Promise<[U.Iterator.Element]> where U : Swift.Sequence
  public func compactMapValues<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (Self.T.Iterator.Element) throws -> U?) -> LivingMapSDK.Promise<[U]>
  public func thenMap<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (Self.T.Iterator.Element) throws -> U) -> LivingMapSDK.Promise<[U.T]> where U : LivingMapSDK.Thenable
  public func thenFlatMap<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (Self.T.Iterator.Element) throws -> U) -> LivingMapSDK.Promise<[U.T.Iterator.Element]> where U : LivingMapSDK.Thenable, U.T : Swift.Sequence
  public func filterValues(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ isIncluded: @escaping (Self.T.Iterator.Element) -> Swift.Bool) -> LivingMapSDK.Promise<[Self.T.Iterator.Element]>
}
extension LivingMapSDK.Thenable where Self.T : Swift.Collection {
  public var firstValue: LivingMapSDK.Promise<Self.T.Element> {
    get
  }
  public func firstValue(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, where test: @escaping (Self.T.Iterator.Element) -> Swift.Bool) -> LivingMapSDK.Promise<Self.T.Iterator.Element>
  public var lastValue: LivingMapSDK.Promise<Self.T.Element> {
    get
  }
}
extension LivingMapSDK.Thenable where Self.T : Swift.Sequence, Self.T.Element : Swift.Comparable {
  public func sortedValues(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil) -> LivingMapSDK.Promise<[Self.T.Iterator.Element]>
}
public typealias Parameters = [Swift.String : Any]
public protocol ParameterEncoding {
  func encode(_ urlRequest: any LivingMapSDK.URLRequestConvertible, with parameters: LivingMapSDK.Parameters?) throws -> Foundation.URLRequest
}
public struct URLEncoding : LivingMapSDK.ParameterEncoding {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: LivingMapSDK.URLEncoding.Destination, b: LivingMapSDK.URLEncoding.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    case indexInBrackets
    public static func == (a: LivingMapSDK.URLEncoding.ArrayEncoding, b: LivingMapSDK.URLEncoding.ArrayEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: LivingMapSDK.URLEncoding.BoolEncoding, b: LivingMapSDK.URLEncoding.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: LivingMapSDK.URLEncoding {
    get
  }
  public static var queryString: LivingMapSDK.URLEncoding {
    get
  }
  public static var httpBody: LivingMapSDK.URLEncoding {
    get
  }
  public let destination: LivingMapSDK.URLEncoding.Destination
  public let arrayEncoding: LivingMapSDK.URLEncoding.ArrayEncoding
  public let boolEncoding: LivingMapSDK.URLEncoding.BoolEncoding
  public init(destination: LivingMapSDK.URLEncoding.Destination = .methodDependent, arrayEncoding: LivingMapSDK.URLEncoding.ArrayEncoding = .brackets, boolEncoding: LivingMapSDK.URLEncoding.BoolEncoding = .numeric)
  public func encode(_ urlRequest: any LivingMapSDK.URLRequestConvertible, with parameters: LivingMapSDK.Parameters?) throws -> Foundation.URLRequest
  public func queryComponents(fromKey key: Swift.String, value: Any) -> [(Swift.String, Swift.String)]
  public func escape(_ string: Swift.String) -> Swift.String
}
public struct JSONEncoding : LivingMapSDK.ParameterEncoding {
  public static var `default`: LivingMapSDK.JSONEncoding {
    get
  }
  public static var prettyPrinted: LivingMapSDK.JSONEncoding {
    get
  }
  public let options: Foundation.JSONSerialization.WritingOptions
  public init(options: Foundation.JSONSerialization.WritingOptions = [])
  public func encode(_ urlRequest: any LivingMapSDK.URLRequestConvertible, with parameters: LivingMapSDK.Parameters?) throws -> Foundation.URLRequest
  public func encode(_ urlRequest: any LivingMapSDK.URLRequestConvertible, withJSONObject jsonObject: Any? = nil) throws -> Foundation.URLRequest
}
public enum BinaryDecodingError : Swift.Error {
  case trailingGarbage
  case truncated
  case invalidUTF8
  case malformedProtobuf
  case missingRequiredFields
  case internalExtensionError
  case messageDepthLimit
  public static func == (a: LivingMapSDK.BinaryDecodingError, b: LivingMapSDK.BinaryDecodingError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct JSONDecodingOptions {
  public var messageDepthLimit: Swift.Int
  public var ignoreUnknownFields: Swift.Bool
  public init()
}
@objc @_inheritsConvenienceInitializers open class ConnectivityMonitor : ObjectiveC.NSObject {
  public func startMonitoring(livingMapEvents: (any LivingMapSDK.LivingMapPositioningEvents)? = nil)
  public func stopMonitoring()
  open func isReachable() -> Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
public func firstly<U>(execute body: () throws -> U) -> LivingMapSDK.Promise<U.T> where U : LivingMapSDK.Thenable
public func firstly<T>(execute body: () -> LivingMapSDK.Guarantee<T>) -> LivingMapSDK.Guarantee<T>
public struct AlamofireExtension<ExtendedType> {
  public var type: ExtendedType {
    get
  }
  public init(_ type: ExtendedType)
}
public protocol AlamofireExtended {
  associatedtype ExtendedType
  static var af: LivingMapSDK.AlamofireExtension<Self.ExtendedType>.Type { get set }
  var af: LivingMapSDK.AlamofireExtension<Self.ExtendedType> { get set }
}
extension LivingMapSDK.AlamofireExtended {
  public static var af: LivingMapSDK.AlamofireExtension<Self>.Type {
    get
    set
  }
  public var af: LivingMapSDK.AlamofireExtension<Self> {
    get
    set
  }
}
extension LivingMapSDK.Google_Protobuf_Timestamp {
  public init(seconds: Swift.Int64 = 0, nanos: Swift.Int32 = 0)
}
extension LivingMapSDK.Google_Protobuf_Timestamp {
  public init(timeIntervalSince1970: Foundation.TimeInterval)
  public init(timeIntervalSinceReferenceDate: Foundation.TimeInterval)
  public init(date: Foundation.Date)
  public var timeIntervalSince1970: Foundation.TimeInterval {
    get
  }
  public var timeIntervalSinceReferenceDate: Foundation.TimeInterval {
    get
  }
  public var date: Foundation.Date {
    get
  }
}
public func + (lhs: LivingMapSDK.Google_Protobuf_Timestamp, rhs: LivingMapSDK.Google_Protobuf_Duration) -> LivingMapSDK.Google_Protobuf_Timestamp
public func + (lhs: LivingMapSDK.Google_Protobuf_Duration, rhs: LivingMapSDK.Google_Protobuf_Timestamp) -> LivingMapSDK.Google_Protobuf_Timestamp
public func - (lhs: LivingMapSDK.Google_Protobuf_Timestamp, rhs: LivingMapSDK.Google_Protobuf_Duration) -> LivingMapSDK.Google_Protobuf_Timestamp
public protocol OfflineCacheCallback {
  func onProgressUpdate(progress: LivingMapSDK.CacheProgress)
  func onCachePrepareCompletion()
  func onCachePrepareFailure(error: LivingMapSDK.LivingMapError)
}
public struct Google_Protobuf_Api {
  public var name: Swift.String
  public var methods: [LivingMapSDK.Google_Protobuf_Method]
  public var options: [LivingMapSDK.Google_Protobuf_Option]
  public var version: Swift.String
  public var sourceContext: LivingMapSDK.Google_Protobuf_SourceContext {
    get
    set
  }
  public var hasSourceContext: Swift.Bool {
    get
  }
  public mutating func clearSourceContext()
  public var mixins: [LivingMapSDK.Google_Protobuf_Mixin]
  public var syntax: LivingMapSDK.Google_Protobuf_Syntax
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
public struct Google_Protobuf_Method {
  public var name: Swift.String
  public var requestTypeURL: Swift.String
  public var requestStreaming: Swift.Bool
  public var responseTypeURL: Swift.String
  public var responseStreaming: Swift.Bool
  public var options: [LivingMapSDK.Google_Protobuf_Option]
  public var syntax: LivingMapSDK.Google_Protobuf_Syntax
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
public struct Google_Protobuf_Mixin {
  public var name: Swift.String
  public var root: Swift.String
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
extension LivingMapSDK.Google_Protobuf_Api : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Method : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Mixin : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Api : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_Api, rhs: LivingMapSDK.Google_Protobuf_Api) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_Method : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_Method, rhs: LivingMapSDK.Google_Protobuf_Method) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LivingMapSDK.Google_Protobuf_Mixin : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_Mixin, rhs: LivingMapSDK.Google_Protobuf_Mixin) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol LivingMapPositioningEvents : LivingMapSDK.LivingMapLocationListener {
  func customEvent(eventId: Swift.String, eventParameters: Foundation.NSArray)
  func errorReceived(error: LivingMapSDK.LivingMapError)
  func onConnectivityStatusChanged(connectivityStatus: LivingMapSDK.LivingMapConstants.ConnectivityStatus)
  func onPositioningReady()
}
open class Session {
  public static let `default`: LivingMapSDK.Session
  final public let session: Foundation.URLSession
  final public let delegate: LivingMapSDK.SessionDelegate
  final public let rootQueue: Dispatch.DispatchQueue
  final public let startRequestsImmediately: Swift.Bool
  final public let requestQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let interceptor: (any LivingMapSDK.RequestInterceptor)?
  final public let serverTrustManager: LivingMapSDK.ServerTrustManager?
  final public let redirectHandler: (any LivingMapSDK.RedirectHandler)?
  final public let cachedResponseHandler: (any LivingMapSDK.CachedResponseHandler)?
  final public let eventMonitor: LivingMapSDK.CompositeEventMonitor
  final public let defaultEventMonitors: [any LivingMapSDK.EventMonitor]
  public init(session: Foundation.URLSession, delegate: LivingMapSDK.SessionDelegate, rootQueue: Dispatch.DispatchQueue, startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, serverTrustManager: LivingMapSDK.ServerTrustManager? = nil, redirectHandler: (any LivingMapSDK.RedirectHandler)? = nil, cachedResponseHandler: (any LivingMapSDK.CachedResponseHandler)? = nil, eventMonitors: [any LivingMapSDK.EventMonitor] = [])
  convenience public init(configuration: Foundation.URLSessionConfiguration = URLSessionConfiguration.af.default, delegate: LivingMapSDK.SessionDelegate = SessionDelegate(), rootQueue: Dispatch.DispatchQueue = DispatchQueue(label: "org.alamofire.session.rootQueue"), startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, serverTrustManager: LivingMapSDK.ServerTrustManager? = nil, redirectHandler: (any LivingMapSDK.RedirectHandler)? = nil, cachedResponseHandler: (any LivingMapSDK.CachedResponseHandler)? = nil, eventMonitors: [any LivingMapSDK.EventMonitor] = [])
  @objc deinit
  public func withAllRequests(perform action: @escaping (Swift.Set<LivingMapSDK.Request>) -> Swift.Void)
  public func cancelAllRequests(completingOnQueue queue: Dispatch.DispatchQueue = .main, completion: (() -> Swift.Void)? = nil)
  public typealias RequestModifier = (inout Foundation.URLRequest) throws -> Swift.Void
  open func request(_ convertible: any LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod = .get, parameters: LivingMapSDK.Parameters? = nil, encoding: any LivingMapSDK.ParameterEncoding = URLEncoding.default, headers: LivingMapSDK.HTTPHeaders? = nil, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, requestModifier: LivingMapSDK.Session.RequestModifier? = nil) -> LivingMapSDK.DataRequest
  open func request<Parameters>(_ convertible: any LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod = .get, parameters: Parameters? = nil, encoder: any LivingMapSDK.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: LivingMapSDK.HTTPHeaders? = nil, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, requestModifier: LivingMapSDK.Session.RequestModifier? = nil) -> LivingMapSDK.DataRequest where Parameters : Swift.Encodable
  open func request(_ convertible: any LivingMapSDK.URLRequestConvertible, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil) -> LivingMapSDK.DataRequest
  open func streamRequest<Parameters>(_ convertible: any LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod = .get, parameters: Parameters? = nil, encoder: any LivingMapSDK.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: LivingMapSDK.HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, requestModifier: LivingMapSDK.Session.RequestModifier? = nil) -> LivingMapSDK.DataStreamRequest where Parameters : Swift.Encodable
  open func streamRequest(_ convertible: any LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod = .get, headers: LivingMapSDK.HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, requestModifier: LivingMapSDK.Session.RequestModifier? = nil) -> LivingMapSDK.DataStreamRequest
  open func streamRequest(_ convertible: any LivingMapSDK.URLRequestConvertible, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil) -> LivingMapSDK.DataStreamRequest
  open func download(_ convertible: any LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod = .get, parameters: LivingMapSDK.Parameters? = nil, encoding: any LivingMapSDK.ParameterEncoding = URLEncoding.default, headers: LivingMapSDK.HTTPHeaders? = nil, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, requestModifier: LivingMapSDK.Session.RequestModifier? = nil, to destination: LivingMapSDK.DownloadRequest.Destination? = nil) -> LivingMapSDK.DownloadRequest
  open func download<Parameters>(_ convertible: any LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod = .get, parameters: Parameters? = nil, encoder: any LivingMapSDK.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: LivingMapSDK.HTTPHeaders? = nil, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, requestModifier: LivingMapSDK.Session.RequestModifier? = nil, to destination: LivingMapSDK.DownloadRequest.Destination? = nil) -> LivingMapSDK.DownloadRequest where Parameters : Swift.Encodable
  open func download(_ convertible: any LivingMapSDK.URLRequestConvertible, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, to destination: LivingMapSDK.DownloadRequest.Destination? = nil) -> LivingMapSDK.DownloadRequest
  open func download(resumingWith data: Foundation.Data, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, to destination: LivingMapSDK.DownloadRequest.Destination? = nil) -> LivingMapSDK.DownloadRequest
  open func upload(_ data: Foundation.Data, to convertible: any LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod = .post, headers: LivingMapSDK.HTTPHeaders? = nil, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: LivingMapSDK.Session.RequestModifier? = nil) -> LivingMapSDK.UploadRequest
  open func upload(_ data: Foundation.Data, with convertible: any LivingMapSDK.URLRequestConvertible, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> LivingMapSDK.UploadRequest
  open func upload(_ fileURL: Foundation.URL, to convertible: any LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod = .post, headers: LivingMapSDK.HTTPHeaders? = nil, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: LivingMapSDK.Session.RequestModifier? = nil) -> LivingMapSDK.UploadRequest
  open func upload(_ fileURL: Foundation.URL, with convertible: any LivingMapSDK.URLRequestConvertible, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> LivingMapSDK.UploadRequest
  open func upload(_ stream: Foundation.InputStream, to convertible: any LivingMapSDK.URLConvertible, method: LivingMapSDK.HTTPMethod = .post, headers: LivingMapSDK.HTTPHeaders? = nil, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: LivingMapSDK.Session.RequestModifier? = nil) -> LivingMapSDK.UploadRequest
  open func upload(_ stream: Foundation.InputStream, with convertible: any LivingMapSDK.URLRequestConvertible, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> LivingMapSDK.UploadRequest
  open func upload(multipartFormData: @escaping (LivingMapSDK.MultipartFormData) -> Swift.Void, to url: any LivingMapSDK.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, method: LivingMapSDK.HTTPMethod = .post, headers: LivingMapSDK.HTTPHeaders? = nil, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: LivingMapSDK.Session.RequestModifier? = nil) -> LivingMapSDK.UploadRequest
  open func upload(multipartFormData: @escaping (LivingMapSDK.MultipartFormData) -> Swift.Void, with request: any LivingMapSDK.URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> LivingMapSDK.UploadRequest
  open func upload(multipartFormData: LivingMapSDK.MultipartFormData, to url: any LivingMapSDK.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, method: LivingMapSDK.HTTPMethod = .post, headers: LivingMapSDK.HTTPHeaders? = nil, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: LivingMapSDK.Session.RequestModifier? = nil) -> LivingMapSDK.UploadRequest
  open func upload(multipartFormData: LivingMapSDK.MultipartFormData, with request: any LivingMapSDK.URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, interceptor: (any LivingMapSDK.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> LivingMapSDK.UploadRequest
}
extension LivingMapSDK.Session : LivingMapSDK.RequestDelegate {
  public var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
  }
  public var startImmediately: Swift.Bool {
    get
  }
  public func cleanup(after request: LivingMapSDK.Request)
  public func retryResult(for request: LivingMapSDK.Request, dueTo error: LivingMapSDK.AFError, completion: @escaping (LivingMapSDK.RetryResult) -> Swift.Void)
  public func retryRequest(_ request: LivingMapSDK.Request, withDelay timeDelay: Foundation.TimeInterval?)
}
public typealias StringMap = [Swift.String : Swift.String]
public typealias StringAnyMap = [Swift.String : LivingMapSDK.AnyCodable]
public struct CacheManifest {
  public var environment: Swift.String
  public var project: Swift.String
  public var urls: LivingMapSDK.Urls
  public var extras: LivingMapSDK.StringAnyMap?
  public var mapPackChecksums: LivingMapSDK.Checksums?
  public var gridPackChecksums: LivingMapSDK.Checksums?
  public var key: LivingMapSDK.StringMap?
  public var manifestUrl: Swift.String?
  public var outOfDate: Swift.Bool?
}
extension LivingMapSDK.CacheManifest : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension LivingMapSDK.CacheManifest : Swift.Equatable {
  public static func == (lhs: LivingMapSDK.CacheManifest, rhs: LivingMapSDK.CacheManifest) -> Swift.Bool
}
extension LivingMapSDK.CacheManifest {
  public init(_ json: Swift.String, using encoding: Swift.String.Encoding = .utf8) throws
  public init(fromURL url: Foundation.URL) throws
  public mutating func parseMappings()
  public func getExtras() -> LivingMapSDK.StringAnyMap?
  public func positioningAvailable() -> Swift.Bool
  public func getExtraValue(value: Swift.String) -> Any?
}
public struct Urls : Swift.Codable, Swift.Equatable {
  public var map: Swift.String
  public static func == (a: LivingMapSDK.Urls, b: LivingMapSDK.Urls) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public class LivingMapSDKManager {
  public var mapVC: LivingMapSDK.LMWebViewController?
  public var livePositioningManager: LivingMapSDK.LivePositioningManager?
  public init()
  @discardableResult
  public func createMapComponent(mapConfig: LivingMapSDK.LivingMapConfig, lmLivePositioningConfig: LivingMapSDK.LMLivePositioningConfig?, cacheManifest: LivingMapSDK.CacheManifest) -> WebKit.WKWebView?
  public func initPositioningSystem(livePositioningConfig: LivingMapSDK.LMLivePositioningConfig?, mapConfig: LivingMapSDK.LivingMapConfig, eventHandler: any LivingMapSDK.LivingMapPositioningEvents, cacheManifest: LivingMapSDK.CacheManifest, deviceCategory: Swift.String?, knownLocation: Swift.Bool)
  public func deinitPositioningSystem()
  public func deinitMapComponent()
  public func startScanning()
  public func stopScanning()
  public func addLivingMapInterface(interface: any LivingMapSDK.LivingMapInterface)
  public func removeLivingMapInterface(interface: any LivingMapSDK.LivingMapInterface)
  public func add(debugModeListener listener: any LivingMapSDK.DebugModeListener)
  public func remove(debugModeListener listener: any LivingMapSDK.DebugModeListener)
  public func set(simulationFilePath: Foundation.URL?)
  public func routeLoadedSuccessfully(originLocation: LivingMapSDK.LMLocation)
  public func routeLoadFailed()
  public func set(deviceName: Swift.String?)
  public func set(location newLocation: LivingMapSDK.LMLocation) -> Swift.Bool
  public func setDebugLayoutDisplay(showDebugLayout: Swift.Bool)
  public func isDebugging() -> Swift.Bool
  public func sendCommandToFrontEnd(command: Swift.String, completionHandler: @escaping (Any?, (any Swift.Error)?) -> Swift.Void)
  public func sendCommandToFrontEnd(command: Swift.String, returnCallback: @escaping (Any?, (any Swift.Error)?) -> Swift.Void, eventKeyCallbackListener: Swift.String, asyncCallback: @escaping (Foundation.NSArray) -> Swift.Void)
  public static func getVersion() -> Swift.String
  public static func getCPLVersion() -> Swift.String
  @objc deinit
}
extension LivingMapSDK.LivingMapSDKManager {
  public func fireCustomEvent(eventId: Swift.String, eventParameters: Foundation.NSArray)
  public func onMapReady()
  public func destinationReached()
}
public protocol Enum : Swift.Hashable, Swift.RawRepresentable {
  init()
  init?(rawValue: Swift.Int)
  var rawValue: Swift.Int { get }
}
extension LivingMapSDK.Enum {
  public func hash(into hasher: inout Swift.Hasher)
}
public struct HTTPMethod : Swift.RawRepresentable, Swift.Equatable, Swift.Hashable {
  public static let connect: LivingMapSDK.HTTPMethod
  public static let delete: LivingMapSDK.HTTPMethod
  public static let get: LivingMapSDK.HTTPMethod
  public static let head: LivingMapSDK.HTTPMethod
  public static let options: LivingMapSDK.HTTPMethod
  public static let patch: LivingMapSDK.HTTPMethod
  public static let post: LivingMapSDK.HTTPMethod
  public static let put: LivingMapSDK.HTTPMethod
  public static let trace: LivingMapSDK.HTTPMethod
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
public struct Google_Protobuf_SourceContext {
  public var fileName: Swift.String
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
extension LivingMapSDK.Google_Protobuf_SourceContext : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_SourceContext : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_SourceContext, rhs: LivingMapSDK.Google_Protobuf_SourceContext) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol LivingMapLocationListener : AnyObject {
  func locationReceived(location: LivingMapSDK.LMLocation)
}
public protocol DebugModeListener : AnyObject {
  func onCPLMetricsUpdate(offset: Swift.Double, depletion: Swift.Double)
  func onCalibrationMatricesUpdate(calibrationMatrices: LivingMapSDK.CalibrationMatrices?, calibrationMethod: LivingMapSDK.MagnetometerCalibrationMethod)
  func onAltitudeUpdate(altitude: Swift.Double, pressure: Swift.Double)
}
public struct SimpleExtensionMap : LivingMapSDK.ExtensionMap, Swift.ExpressibleByArrayLiteral, Swift.CustomDebugStringConvertible {
  public typealias Element = LivingMapSDK.AnyMessageExtension
  public init()
  public init(arrayLiteral: any LivingMapSDK.AnyMessageExtension...)
  public init(_ others: LivingMapSDK.SimpleExtensionMap...)
  public subscript(messageType: any LivingMapSDK.Message.Type, fieldNumber: Swift.Int) -> (any LivingMapSDK.AnyMessageExtension)? {
    get
  }
  public func fieldNumberForProto(messageType: any LivingMapSDK.Message.Type, protoFieldName: Swift.String) -> Swift.Int?
  public mutating func insert(_ newValue: any LivingMapSDK.AnyMessageExtension)
  public mutating func insert(contentsOf: [any LivingMapSDK.AnyMessageExtension])
  public mutating func formUnion(_ other: LivingMapSDK.SimpleExtensionMap)
  public func union(_ other: LivingMapSDK.SimpleExtensionMap) -> LivingMapSDK.SimpleExtensionMap
  public var debugDescription: Swift.String {
    get
  }
  public typealias ArrayLiteralElement = any LivingMapSDK.AnyMessageExtension
}
public struct ExtensionFieldValueSet : Swift.Hashable {
  public static func == (lhs: LivingMapSDK.ExtensionFieldValueSet, rhs: LivingMapSDK.ExtensionFieldValueSet) -> Swift.Bool
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public func traverse<V>(visitor: inout V, start: Swift.Int, end: Swift.Int) throws where V : LivingMapSDK.Visitor
  public subscript(index: Swift.Int) -> (any LivingMapSDK.AnyExtensionField)? {
    get
    set
  }
  public var isInitialized: Swift.Bool {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public struct Google_Protobuf_FieldMask {
  public var paths: [Swift.String]
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
extension LivingMapSDK.Google_Protobuf_FieldMask : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_FieldMask : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_FieldMask, rhs: LivingMapSDK.Google_Protobuf_FieldMask) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Guarantee<T> : LivingMapSDK.Thenable {
  public static func value(_ value: T) -> LivingMapSDK.Guarantee<T>
  public init(resolver body: (@escaping (T) -> Swift.Void) -> Swift.Void)
  final public func pipe(to: @escaping (LivingMapSDK.Result<T>) -> Swift.Void)
  final public var result: LivingMapSDK.Result<T>? {
    get
  }
  final public class func pending() -> (guarantee: LivingMapSDK.Guarantee<T>, resolve: (T) -> Swift.Void)
  @objc deinit
}
extension LivingMapSDK.Guarantee {
  @discardableResult
  final public func done(on: Dispatch.DispatchQueue? = conf.Q.return, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (T) -> Swift.Void) -> LivingMapSDK.Guarantee<Swift.Void>
  final public func get(on: Dispatch.DispatchQueue? = conf.Q.return, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (T) -> Swift.Void) -> LivingMapSDK.Guarantee<T>
  final public func map<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (T) -> U) -> LivingMapSDK.Guarantee<U>
  @discardableResult
  final public func then<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (T) -> LivingMapSDK.Guarantee<U>) -> LivingMapSDK.Guarantee<U>
  final public func asVoid() -> LivingMapSDK.Guarantee<Swift.Void>
  final public func wait() -> T
}
extension LivingMapSDK.Guarantee where T : Swift.Sequence {
  final public func mapValues<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (T.Iterator.Element) -> U) -> LivingMapSDK.Guarantee<[U]>
  final public func flatMapValues<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (T.Iterator.Element) -> U) -> LivingMapSDK.Guarantee<[U.Iterator.Element]> where U : Swift.Sequence
  final public func compactMapValues<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (T.Iterator.Element) -> U?) -> LivingMapSDK.Guarantee<[U]>
  final public func thenMap<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (T.Iterator.Element) -> LivingMapSDK.Guarantee<U>) -> LivingMapSDK.Guarantee<[U]>
  final public func thenFlatMap<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ transform: @escaping (T.Iterator.Element) -> U) -> LivingMapSDK.Guarantee<[U.T.Iterator.Element]> where U : LivingMapSDK.Thenable, U.T : Swift.Sequence
  final public func filterValues(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ isIncluded: @escaping (T.Iterator.Element) -> Swift.Bool) -> LivingMapSDK.Guarantee<[T.Iterator.Element]>
  final public func sortedValues(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ areInIncreasingOrder: @escaping (T.Iterator.Element, T.Iterator.Element) -> Swift.Bool) -> LivingMapSDK.Guarantee<[T.Iterator.Element]>
}
extension LivingMapSDK.Guarantee where T : Swift.Sequence, T.Element : Swift.Comparable {
  final public func sortedValues(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil) -> LivingMapSDK.Guarantee<[T.Iterator.Element]>
}
extension LivingMapSDK.Guarantee where T == () {
  convenience public init()
  public static var value: LivingMapSDK.Guarantee<Swift.Void> {
    get
  }
}
extension Dispatch.DispatchQueue {
  @available(macOS 10.10, iOS 2.0, tvOS 10.0, watchOS 2.0, *)
  final public func async<T>(_: LivingMapSDK.PMKNamespacer, group: Dispatch.DispatchGroup? = nil, qos: Dispatch.DispatchQoS = .default, flags: Dispatch.DispatchWorkItemFlags = [], execute body: @escaping () -> T) -> LivingMapSDK.Guarantee<T>
}
final public class URLEncodedFormEncoder {
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    case indexInBrackets
    public static func == (a: LivingMapSDK.URLEncodedFormEncoder.ArrayEncoding, b: LivingMapSDK.URLEncodedFormEncoder.ArrayEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: LivingMapSDK.URLEncodedFormEncoder.BoolEncoding, b: LivingMapSDK.URLEncodedFormEncoder.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum DataEncoding {
    case deferredToData
    case base64
    case custom((Foundation.Data) throws -> Swift.String)
  }
  public enum DateEncoding {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    case iso8601
    case formatted(Foundation.DateFormatter)
    case custom((Foundation.Date) throws -> Swift.String)
  }
  public enum KeyEncoding {
    case useDefaultKeys
    case convertToSnakeCase
    case convertToKebabCase
    case capitalized
    case uppercased
    case lowercased
    case custom((Swift.String) -> Swift.String)
  }
  public enum SpaceEncoding {
    case percentEscaped
    case plusReplaced
    public static func == (a: LivingMapSDK.URLEncodedFormEncoder.SpaceEncoding, b: LivingMapSDK.URLEncodedFormEncoder.SpaceEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Error : Swift.Error {
    case invalidRootObject(Swift.String)
  }
  final public let alphabetizeKeyValuePairs: Swift.Bool
  final public let arrayEncoding: LivingMapSDK.URLEncodedFormEncoder.ArrayEncoding
  final public let boolEncoding: LivingMapSDK.URLEncodedFormEncoder.BoolEncoding
  final public let dataEncoding: LivingMapSDK.URLEncodedFormEncoder.DataEncoding
  final public let dateEncoding: LivingMapSDK.URLEncodedFormEncoder.DateEncoding
  final public let keyEncoding: LivingMapSDK.URLEncodedFormEncoder.KeyEncoding
  final public let spaceEncoding: LivingMapSDK.URLEncodedFormEncoder.SpaceEncoding
  final public var allowedCharacters: Foundation.CharacterSet
  public init(alphabetizeKeyValuePairs: Swift.Bool = true, arrayEncoding: LivingMapSDK.URLEncodedFormEncoder.ArrayEncoding = .brackets, boolEncoding: LivingMapSDK.URLEncodedFormEncoder.BoolEncoding = .numeric, dataEncoding: LivingMapSDK.URLEncodedFormEncoder.DataEncoding = .base64, dateEncoding: LivingMapSDK.URLEncodedFormEncoder.DateEncoding = .deferredToDate, keyEncoding: LivingMapSDK.URLEncodedFormEncoder.KeyEncoding = .useDefaultKeys, spaceEncoding: LivingMapSDK.URLEncodedFormEncoder.SpaceEncoding = .percentEscaped, allowedCharacters: Foundation.CharacterSet = .afURLQueryAllowed)
  final public func encode(_ value: any Swift.Encodable) throws -> Swift.String
  final public func encode(_ value: any Swift.Encodable) throws -> Foundation.Data
  @objc deinit
}
extension Foundation.CharacterSet {
  public static let afURLQueryAllowed: Foundation.CharacterSet
}
public protocol KalmanInput {
  var transposed: Self { get }
  var inversed: Self { get }
  var additionToUnit: Self { get }
  static func + (lhs: Self, rhs: Self) -> Self
  static func - (lhs: Self, rhs: Self) -> Self
  static func * (lhs: Self, rhs: Self) -> Self
}
public class Coordinate : Swift.Codable {
  final public let lat: Swift.Double
  final public let lon: Swift.Double
  final public let floorId: Swift.Int
  final public let lmId: Swift.String?
  public init(lat: Swift.Double, lon: Swift.Double, floorId: Swift.Int, lmId: Swift.String?)
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
public class RouteLocation : Swift.Codable {
  final public let coordinate: LivingMapSDK.Coordinate?
  public init(coordinate: LivingMapSDK.Coordinate?, name: Swift.String? = "", gid: Swift.Int? = nil, type: Swift.String? = nil)
  public init(name: Swift.String)
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
public struct BinaryDecodingOptions {
  public var messageDepthLimit: Swift.Int
  public var discardUnknownFields: Swift.Bool
  public init()
}
public class AuthenticationParameters : Swift.Codable {
  final public let environment: Swift.String
  final public let clientId: Swift.String
  final public let clientSecret: Swift.String
  public init(environment: Swift.String = "prod", clientId: Swift.String, clientSecret: Swift.String)
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
public enum BinaryDelimited {
  public enum Error : Swift.Error {
    case unknownStreamError
    case truncated
    public static func == (a: LivingMapSDK.BinaryDelimited.Error, b: LivingMapSDK.BinaryDelimited.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func serialize(message: any LivingMapSDK.Message, to stream: Foundation.OutputStream, partial: Swift.Bool = false) throws
  public static func parse<M>(messageType: M.Type, from stream: Foundation.InputStream, extensions: (any LivingMapSDK.ExtensionMap)? = nil, partial: Swift.Bool = false, options: LivingMapSDK.BinaryDecodingOptions = BinaryDecodingOptions()) throws -> M where M : LivingMapSDK.Message
  public static func merge<M>(into message: inout M, from stream: Foundation.InputStream, extensions: (any LivingMapSDK.ExtensionMap)? = nil, partial: Swift.Bool = false, options: LivingMapSDK.BinaryDecodingOptions = BinaryDecodingOptions()) throws where M : LivingMapSDK.Message
}
public protocol ProtobufAPIVersion_3 {
}
public protocol ProtobufAPIVersionCheck {
  associatedtype Version : LivingMapSDK.ProtobufAPIVersion_3
}
@frozen public struct AnyEncodable : Swift.Encodable {
  public let value: Any
  public init<T>(_ value: T?)
}
@usableFromInline
internal protocol _AnyEncodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
extension LivingMapSDK.AnyEncodable : LivingMapSDK._AnyEncodable {
}
extension LivingMapSDK._AnyEncodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension LivingMapSDK.AnyEncodable : Swift.Equatable {
  public static func == (lhs: LivingMapSDK.AnyEncodable, rhs: LivingMapSDK.AnyEncodable) -> Swift.Bool
}
extension LivingMapSDK.AnyEncodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LivingMapSDK.AnyEncodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension LivingMapSDK.AnyEncodable : Swift.ExpressibleByNilLiteral {
}
extension LivingMapSDK.AnyEncodable : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
}
extension LivingMapSDK.AnyEncodable : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
}
extension LivingMapSDK.AnyEncodable : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
}
extension LivingMapSDK.AnyEncodable : Swift.ExpressibleByStringLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension LivingMapSDK.AnyEncodable : Swift.ExpressibleByStringInterpolation {
  public typealias StringInterpolation = Swift.DefaultStringInterpolation
}
extension LivingMapSDK.AnyEncodable : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Any
}
extension LivingMapSDK.AnyEncodable : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.AnyHashable
  public typealias Value = Any
}
extension LivingMapSDK._AnyEncodable {
  public init(nilLiteral _: ())
  public init(booleanLiteral value: Swift.Bool)
  public init(integerLiteral value: Swift.Int)
  public init(floatLiteral value: Swift.Double)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.String)
  public init(arrayLiteral elements: Any...)
  public init(dictionaryLiteral elements: (Swift.AnyHashable, Any)...)
}
public protocol AuthenticationCredential {
  var requiresRefresh: Swift.Bool { get }
}
public protocol Authenticator : AnyObject {
  associatedtype Credential : LivingMapSDK.AuthenticationCredential
  func apply(_ credential: Self.Credential, to urlRequest: inout Foundation.URLRequest)
  func refresh(_ credential: Self.Credential, for session: LivingMapSDK.Session, completion: @escaping (Swift.Result<Self.Credential, any Swift.Error>) -> Swift.Void)
  func didRequest(_ urlRequest: Foundation.URLRequest, with response: Foundation.HTTPURLResponse, failDueToAuthenticationError error: any Swift.Error) -> Swift.Bool
  func isRequest(_ urlRequest: Foundation.URLRequest, authenticatedWith credential: Self.Credential) -> Swift.Bool
}
public enum AuthenticationError : Swift.Error {
  case missingCredential
  case excessiveRefresh
  public static func == (a: LivingMapSDK.AuthenticationError, b: LivingMapSDK.AuthenticationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class AuthenticationInterceptor<AuthenticatorType> : LivingMapSDK.RequestInterceptor where AuthenticatorType : LivingMapSDK.Authenticator {
  public typealias Credential = AuthenticatorType.Credential
  public struct RefreshWindow {
    public let interval: Foundation.TimeInterval
    public let maximumAttempts: Swift.Int
    public init(interval: Foundation.TimeInterval = 30.0, maximumAttempts: Swift.Int = 5)
  }
  public var credential: LivingMapSDK.AuthenticationInterceptor<AuthenticatorType>.Credential? {
    get
    set
  }
  public init(authenticator: AuthenticatorType, credential: LivingMapSDK.AuthenticationInterceptor<AuthenticatorType>.Credential? = nil, refreshWindow: LivingMapSDK.AuthenticationInterceptor<AuthenticatorType>.RefreshWindow? = RefreshWindow())
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: LivingMapSDK.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  public func retry(_ request: LivingMapSDK.Request, for session: LivingMapSDK.Session, dueTo error: any Swift.Error, completion: @escaping (LivingMapSDK.RetryResult) -> Swift.Void)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class LMStep : Swift.Codable {
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
extension LivingMapSDK.Google_Protobuf_Any {
  @discardableResult
  public static func register(messageType: any LivingMapSDK.Message.Type) -> Swift.Bool
  public static func messageType(forTypeURL url: Swift.String) -> (any LivingMapSDK.Message.Type)?
  public static func messageType(forMessageName name: Swift.String) -> (any LivingMapSDK.Message.Type)?
}
public struct LMCalibrationConfig : Swift.Codable {
  public var magneticFieldUpperThreshold: Swift.Double
  public var magneticFieldLowerThreshold: Swift.Double
  public var calibrationPromptTimeThreshold: Swift.Double
  public var magReadingsCheckThreshold: Swift.Double
  public var magnetometerCalibrationMethod: LivingMapSDK.MagnetometerCalibrationMethod
  public var calibrationDataBufferLengthSeconds: Swift.Double
  public var cplCalibrationCadence: Swift.Double
  public var minimumCalibrationAccuracy: Swift.Double
  public init(magneticFieldUpperThreshould: Swift.Double = 80.0, magneticFieldLowerThreshould: Swift.Double = 25.0, calibrationPromptTimeThreshold: Swift.Double = 10.0, magReadingsCheckThreshold: Swift.Double = 1.0, magnetometerCalibrationMethod: LivingMapSDK.MagnetometerCalibrationMethod = .CPL, calibrationDataBufferLengthSeconds: Swift.Double = 20.0, cplCalibrationCadence: Swift.Double = 10.0, minimumCalibrationAccuracy: Swift.Double = 15)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public protocol CachedResponseHandler {
  func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
public struct ResponseCacher {
  public enum Behavior {
    case cache
    case doNotCache
    case modify((Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)
  }
  public static let cache: LivingMapSDK.ResponseCacher
  public static let doNotCache: LivingMapSDK.ResponseCacher
  public let behavior: LivingMapSDK.ResponseCacher.Behavior
  public init(behavior: LivingMapSDK.ResponseCacher.Behavior)
}
extension LivingMapSDK.ResponseCacher : LivingMapSDK.CachedResponseHandler {
  public func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension LivingMapSDK.CachedResponseHandler where Self == LivingMapSDK.ResponseCacher {
  public static var cache: LivingMapSDK.ResponseCacher {
    get
  }
  public static var doNotCache: LivingMapSDK.ResponseCacher {
    get
  }
  public static func modify(using closure: @escaping ((Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)) -> LivingMapSDK.ResponseCacher
}
@available(*, deprecated, message: "See `init(resolver:)`")
public func wrap<T>(_ body: (@escaping (T?, (any Swift.Error)?) -> Swift.Void) throws -> Swift.Void) -> LivingMapSDK.Promise<T>
@available(*, deprecated, message: "See `init(resolver:)`")
public func wrap<T>(_ body: (@escaping (T, (any Swift.Error)?) -> Swift.Void) throws -> Swift.Void) -> LivingMapSDK.Promise<T>
@available(*, deprecated, message: "See `init(resolver:)`")
public func wrap<T>(_ body: (@escaping ((any Swift.Error)?, T?) -> Swift.Void) throws -> Swift.Void) -> LivingMapSDK.Promise<T>
@available(*, deprecated, message: "See `init(resolver:)`")
public func wrap(_ body: (@escaping ((any Swift.Error)?) -> Swift.Void) throws -> Swift.Void) -> LivingMapSDK.Promise<Swift.Void>
@available(*, deprecated, message: "See `init(resolver:)`")
public func wrap<T>(_ body: (@escaping (T) -> Swift.Void) throws -> Swift.Void) -> LivingMapSDK.Promise<T>
extension LivingMapSDK.Promise {
  @available(*, deprecated, message: "See `ensure`")
  final public func always(on q: Dispatch.DispatchQueue = .main, execute body: @escaping () -> Swift.Void) -> LivingMapSDK.Promise<T>
}
extension LivingMapSDK.Thenable where Self.T : Swift.Sequence {
  @available(*, deprecated, message: "See: `filterValues`")
  public func filter(on: Dispatch.DispatchQueue? = conf.Q.map, test: @escaping (Self.T.Iterator.Element) -> Swift.Bool) -> LivingMapSDK.Promise<[Self.T.Iterator.Element]>
}
extension LivingMapSDK.Thenable where Self.T : Swift.Collection {
  @available(*, deprecated, message: "See: `firstValue`")
  public var first: LivingMapSDK.Promise<Self.T.Element> {
    get
  }
  @available(*, deprecated, message: "See: `lastValue`")
  public var last: LivingMapSDK.Promise<Self.T.Element> {
    get
  }
}
extension LivingMapSDK.Thenable where Self.T : Swift.Sequence, Self.T.Element : Swift.Comparable {
  @available(*, deprecated, message: "See: `sortedValues`")
  public func sorted(on: Dispatch.DispatchQueue? = conf.Q.map) -> LivingMapSDK.Promise<[Self.T.Iterator.Element]>
}
public let AF: LivingMapSDK.Session
public class RoutingService {
  public init(ppsSDKManager: LivingMapSDK.LivingMapSDKManager, maxRetries: Swift.Int, connectivityStatus: LivingMapSDK.LivingMapConstants.ConnectivityStatus, eventHandler: any LivingMapSDK.RoutingCompletionHandler, gateInitialisedLocation: Swift.Bool?)
  public func addRoutingRequest(routingRequest: LivingMapSDK.RoutingRequest)
  public func onConnectivityStatusChanged(connectivityStatus: LivingMapSDK.LivingMapConstants.ConnectivityStatus)
  public func onPositioningReady()
  @objc deinit
}
public struct Google_Protobuf_Any {
  public var typeURL: Swift.String {
    get
    set
  }
  public var value: Foundation.Data {
    get
    set
  }
  public var unknownFields: LivingMapSDK.UnknownStorage
  public init()
}
extension LivingMapSDK.Google_Protobuf_Any : @unchecked Swift.Sendable {
}
extension LivingMapSDK.Google_Protobuf_Any : LivingMapSDK.Message, LivingMapSDK._MessageImplementationBase, LivingMapSDK._ProtoNameProviding {
  public static let protoMessageName: Swift.String
  public static let _protobuf_nameMap: LivingMapSDK._NameMap
  public mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public static func == (lhs: LivingMapSDK.Google_Protobuf_Any, rhs: LivingMapSDK.Google_Protobuf_Any) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct LMSensorUpdateFrequencies : Swift.Codable {
  public var foreground: LivingMapSDK.LMSensorUpdateFrequencies.SensorValues
  public var background: LivingMapSDK.LMSensorUpdateFrequencies.SensorValues
  public init(foreground: LivingMapSDK.LMSensorUpdateFrequencies.SensorValues = SensorValues(), background: LivingMapSDK.LMSensorUpdateFrequencies.SensorValues = SensorValues())
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension LivingMapSDK.LMSensorUpdateFrequencies {
  public struct SensorValues : Swift.Codable {
    public var accelerometer: Foundation.TimeInterval
    public var gyro: Foundation.TimeInterval
    public var mag: Foundation.TimeInterval
    public var device: Foundation.TimeInterval
    public var altimeter: Foundation.TimeInterval
    public var locationAccuracy: LivingMapSDK.LMSensorUpdateFrequencies.LocationAccuracy
    public var distanceFilter: CoreLocation.CLLocationDistance
    public init(accelerometer: Foundation.TimeInterval = 0.02, gyro: Foundation.TimeInterval = 0.02, mag: Foundation.TimeInterval = 0.02, device: Foundation.TimeInterval = 0.02, altimeter: Foundation.TimeInterval = 0.1, locationAccuracy: LivingMapSDK.LMSensorUpdateFrequencies.LocationAccuracy = .Best, distanceFilter: Swift.Double = 0.0)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum LocationAccuracy : Swift.String, Swift.Codable {
    case Navigation
    case Meters
    case Best
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
open class LivingMapConfig {
  final public let mapUrl: Swift.String
  final public let project: Swift.String
  final public let debugMode: Swift.Bool
  final public let authenticationParameters: LivingMapSDK.AuthenticationParameters
  public var routingMode: Swift.Bool
  public var viewController: UIKit.UIViewController
  public var mapSize: CoreFoundation.CGRect
  public var mapView: LivingMapSDK.MapView
  public var diagnosticLoggingEnabled: Swift.Bool
  public init(mapUrl: Swift.String, project: Swift.String, authenticationParameters: LivingMapSDK.AuthenticationParameters, debugMode: Swift.Bool, routingMode: Swift.Bool, mapView: LivingMapSDK.MapView, diagnosticLoggingEnabled: Swift.Bool)
  public class Builder {
    public init()
    public func mapView(_ mapView: LivingMapSDK.MapView) -> LivingMapSDK.LivingMapConfig.Builder
    public func mapUrl(_ mapUrl: Swift.String) -> LivingMapSDK.LivingMapConfig.Builder
    public func project(_ project: Swift.String) -> LivingMapSDK.LivingMapConfig.Builder
    public func authenticationParameters(_ authenticationParameters: LivingMapSDK.AuthenticationParameters) -> LivingMapSDK.LivingMapConfig.Builder
    public func viewController(_ viewController: UIKit.UIViewController) -> LivingMapSDK.LivingMapConfig.Builder
    public func debugMode(_ debugMode: Swift.Bool) -> LivingMapSDK.LivingMapConfig.Builder
    public func routingMode(_ routingMode: Swift.Bool) -> LivingMapSDK.LivingMapConfig.Builder
    public func diagnosticLoggingEnabled(_ diagnosticLoggingEnabled: Swift.Bool) -> LivingMapSDK.LivingMapConfig.Builder
    public func build() throws -> LivingMapSDK.LivingMapConfig
    @objc deinit
  }
  @objc deinit
}
public enum LivingMapErrorSeverity : Swift.String {
  case fatalError
  case error
  case warning
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public class LivingMapError : Swift.Error {
  final public let severity: LivingMapSDK.LivingMapErrorSeverity
  final public let errorCode: LivingMapSDK.LivingMapErrorCode
  final public let errorMessage: Swift.String
  public init(severity: LivingMapSDK.LivingMapErrorSeverity, errorCode: LivingMapSDK.LivingMapErrorCode, errorMessage: Swift.String)
  @objc deinit
}
public struct _ProtobufMap<KeyType, ValueType> where KeyType : LivingMapSDK.MapKeyType, ValueType : LivingMapSDK.FieldType {
  public typealias Key = KeyType.BaseType
  public typealias Value = ValueType.BaseType
  public typealias BaseType = Swift.Dictionary<LivingMapSDK._ProtobufMap<KeyType, ValueType>.Key, LivingMapSDK._ProtobufMap<KeyType, ValueType>.Value>
}
public struct _ProtobufMessageMap<KeyType, ValueType> where KeyType : LivingMapSDK.MapKeyType, ValueType : LivingMapSDK.Message, ValueType : Swift.Hashable {
  public typealias Key = KeyType.BaseType
  public typealias Value = ValueType
  public typealias BaseType = Swift.Dictionary<LivingMapSDK._ProtobufMessageMap<KeyType, ValueType>.Key, LivingMapSDK._ProtobufMessageMap<KeyType, ValueType>.Value>
}
public struct _ProtobufEnumMap<KeyType, ValueType> where KeyType : LivingMapSDK.MapKeyType, ValueType : LivingMapSDK.Enum {
  public typealias Key = KeyType.BaseType
  public typealias Value = ValueType
  public typealias BaseType = Swift.Dictionary<LivingMapSDK._ProtobufEnumMap<KeyType, ValueType>.Key, LivingMapSDK._ProtobufEnumMap<KeyType, ValueType>.Value>
}
@frozen public struct AnyDecodable : Swift.Decodable {
  public let value: Any
  public init<T>(_ value: T?)
}
@usableFromInline
internal protocol _AnyDecodable {
  init<T>(_ value: T?)
}
extension LivingMapSDK.AnyDecodable : LivingMapSDK._AnyDecodable {
}
extension LivingMapSDK._AnyDecodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension LivingMapSDK.AnyDecodable : Swift.Equatable {
  public static func == (lhs: LivingMapSDK.AnyDecodable, rhs: LivingMapSDK.AnyDecodable) -> Swift.Bool
}
extension LivingMapSDK.AnyDecodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LivingMapSDK.AnyDecodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum LivingMapErrorCode : Swift.Int {
  case CannotConvertLivingMapLocationToJSON
  case NetworkUnreachable
  case CachingFailure
  case ConfigurationError
  case BluetoothIsOff
  case UnknownConnectivityStatus
  case CouldNotLoadWebView
  case UnrecognisedEventSentToSDK
  case EddystoneBeaconError
  case ErrorRunningJSCommand
  case MapHasNotFinishedLoading
  case ErrorWritingToLog
  case ErrorPreparingSimulatorCommandList
  case RequestForFloorHeightGridDataFailed
  case RequestForGatewayGridDataFailed
  case RequestForBeaconGridDataFailed
  case RequestForMagGridDataFailed
  case UnknownErrorRequestingGridData
  case failedToCreateMLMultiArray
  case failedToStartCalssificationModel
  case failedToPrediteActivity
  case failedToCreateMLModelInput
  case ErrorDownloadingCacheManifest
  case ErrorParsingCacheManifest
  case ErrorDownloadingPack
  case MapPackIsNotAValidZipFile
  case FailedToCreateUnzipDirectory
  case ErrorUnzippingMapPack
  case DeviceIsOffline
  case ErrorDownloadingGridFile
  case ErrorDownloadingChecksums
  case KeyCannotBeNull
  case GeneralFileDownloadError
  case ChecksumsDoNotMatch
  case NoSensorData
  case ErrorDownloadingConfig
  case ErrorSavingConfig
  case ErrorReadingConfig
  case ErrorReadingLivePositioningAssets
  case NoViewControllerInConfig
  case RoutingErrorNoDepartureGate
  case RoutingErrorNoResponse
  case ErrorRegisteringForFlightData
  case InvalidFlightData
  case RoutingGeneralError
  case FATAL_ERROR_EXIT_CALLBACK
  case InvalidConnectionStatus
  case UnableToSetInitialLocation
  case PollingResponse
  case MapUrls
  case NoMapUrlsReturned
  case PollResponseParse
  case RoutingErrorInResponse
  case AviationAcceleratorAlreadRunning
  case InitializationError
  case GridFileError
  case NoGridFoundError
  case DataAlreadyUploadedError
  case DataNotUploadedError
  case PositioningError
  case NoSynchronizationError
  case NoHeadingEstimatorError
  case HeadingEstimationError
  case NoFloorEstimatorError
  case FloorEstimationError
  case NonRecoverableError
  case EKFCalibrationError
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum TextFormatDecodingError : Swift.Error {
  case malformedText
  case malformedNumber
  case trailingGarbage
  case truncated
  case invalidUTF8
  case schemaMismatch
  case missingFieldNames
  case unknownField
  case unrecognizedEnumValue
  case conflictingOneOf
  case internalExtensionError
  case messageDepthLimit
  public static func == (a: LivingMapSDK.TextFormatDecodingError, b: LivingMapSDK.TextFormatDecodingError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum JSONEncodingError : Swift.Error {
  case anyTranscodeFailure
  case timestampRange
  case durationRange
  case fieldMaskConversion
  case missingFieldNames
  case missingValue
  public static func == (a: LivingMapSDK.JSONEncodingError, b: LivingMapSDK.JSONEncodingError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct LMActivityClassificationConfig : Swift.Codable {
  public var predictionWindowSize: Swift.Int
  public var stateInLength: Swift.Int
  public var travelatorsFloorsID: [Swift.Int32]
  public init(predictionWindowSize: Swift.Int = 10, stateInLength: Swift.Int = 400, stoppedWalkingThreshold: Swift.Double = 2.0, travelatorsFloorsID: [Swift.Int32])
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension LivingMapSDK.Google_Protobuf_Duration {
  public init(seconds: Swift.Int64 = 0, nanos: Swift.Int32 = 0)
}
extension LivingMapSDK.Google_Protobuf_Duration : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
  public init(floatLiteral value: Swift.Double)
}
extension LivingMapSDK.Google_Protobuf_Duration {
  public init(timeInterval: Foundation.TimeInterval)
  public var timeInterval: Foundation.TimeInterval {
    get
  }
}
prefix public func - (operand: LivingMapSDK.Google_Protobuf_Duration) -> LivingMapSDK.Google_Protobuf_Duration
public func + (lhs: LivingMapSDK.Google_Protobuf_Duration, rhs: LivingMapSDK.Google_Protobuf_Duration) -> LivingMapSDK.Google_Protobuf_Duration
public func - (lhs: LivingMapSDK.Google_Protobuf_Duration, rhs: LivingMapSDK.Google_Protobuf_Duration) -> LivingMapSDK.Google_Protobuf_Duration
public func - (lhs: LivingMapSDK.Google_Protobuf_Timestamp, rhs: LivingMapSDK.Google_Protobuf_Timestamp) -> LivingMapSDK.Google_Protobuf_Duration
public struct Matrix : Swift.Equatable {
  public let rows: Swift.Int, columns: Swift.Int
  public var grid: [Swift.Double]
  public init(rows: Swift.Int, columns: Swift.Int)
  public init(grid: [Swift.Double], rows: Swift.Int, columns: Swift.Int)
  public init(vector: [Swift.Double])
  public init(vectorOf size: Swift.Int)
  public init(squareOfSize size: Swift.Int)
  public init(identityOfSize size: Swift.Int)
  public init(_ array2d: [[Swift.Double]])
  public func indexIsValid(forRow row: Swift.Int, column: Swift.Int) -> Swift.Bool
  public subscript(row: Swift.Int, column: Swift.Int) -> Swift.Double {
    get
    set
  }
}
public func == (lhs: LivingMapSDK.Matrix, rhs: LivingMapSDK.Matrix) -> Swift.Bool
extension LivingMapSDK.Matrix : LivingMapSDK.KalmanInput {
  public var transposed: LivingMapSDK.Matrix {
    get
  }
  public var additionToUnit: LivingMapSDK.Matrix {
    get
  }
  public var inversed: LivingMapSDK.Matrix {
    get
  }
}
public func + (lhs: LivingMapSDK.Matrix, rhs: LivingMapSDK.Matrix) -> LivingMapSDK.Matrix
public func - (lhs: LivingMapSDK.Matrix, rhs: LivingMapSDK.Matrix) -> LivingMapSDK.Matrix
public func * (lhs: LivingMapSDK.Matrix, rhs: LivingMapSDK.Matrix) -> LivingMapSDK.Matrix
extension LivingMapSDK.Matrix : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol AnyMessageExtension {
  var fieldNumber: Swift.Int { get }
  var fieldName: Swift.String { get }
  var messageType: any LivingMapSDK.Message.Type { get }
  func _protobuf_newField<D>(decoder: inout D) throws -> (any LivingMapSDK.AnyExtensionField)? where D : LivingMapSDK.ProtoDecoder
}
public class MessageExtension<FieldType, MessageType> : LivingMapSDK.AnyMessageExtension where FieldType : LivingMapSDK.ExtensionField, MessageType : LivingMapSDK.Message {
  final public let fieldNumber: Swift.Int
  final public let fieldName: Swift.String
  final public let messageType: any LivingMapSDK.Message.Type
  public init(_protobuf_fieldNumber: Swift.Int, fieldName: Swift.String)
  public func _protobuf_newField<D>(decoder: inout D) throws -> (any LivingMapSDK.AnyExtensionField)? where D : LivingMapSDK.ProtoDecoder
  @objc deinit
}
public enum ApplicationState : Swift.String, Swift.Codable {
  case APPLICATION_BACKGROUND
  case APPLICATION_FOREGROUND
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public func when<U>(fulfilled thenables: [U]) -> LivingMapSDK.Promise<[U.T]> where U : LivingMapSDK.Thenable
public func when<U>(fulfilled promises: U...) -> LivingMapSDK.Promise<Swift.Void> where U : LivingMapSDK.Thenable, U.T == ()
public func when<U>(fulfilled promises: [U]) -> LivingMapSDK.Promise<Swift.Void> where U : LivingMapSDK.Thenable, U.T == ()
public func when<U, V>(fulfilled pu: U, _ pv: V) -> LivingMapSDK.Promise<(U.T, V.T)> where U : LivingMapSDK.Thenable, V : LivingMapSDK.Thenable
public func when<U, V, W>(fulfilled pu: U, _ pv: V, _ pw: W) -> LivingMapSDK.Promise<(U.T, V.T, W.T)> where U : LivingMapSDK.Thenable, V : LivingMapSDK.Thenable, W : LivingMapSDK.Thenable
public func when<U, V, W, X>(fulfilled pu: U, _ pv: V, _ pw: W, _ px: X) -> LivingMapSDK.Promise<(U.T, V.T, W.T, X.T)> where U : LivingMapSDK.Thenable, V : LivingMapSDK.Thenable, W : LivingMapSDK.Thenable, X : LivingMapSDK.Thenable
public func when<U, V, W, X, Y>(fulfilled pu: U, _ pv: V, _ pw: W, _ px: X, _ py: Y) -> LivingMapSDK.Promise<(U.T, V.T, W.T, X.T, Y.T)> where U : LivingMapSDK.Thenable, V : LivingMapSDK.Thenable, W : LivingMapSDK.Thenable, X : LivingMapSDK.Thenable, Y : LivingMapSDK.Thenable
public func when<It>(fulfilled promiseIterator: It, concurrently: Swift.Int) -> LivingMapSDK.Promise<[It.Element.T]> where It : Swift.IteratorProtocol, It.Element : LivingMapSDK.Thenable
public func when<T>(resolved promises: LivingMapSDK.Promise<T>...) -> LivingMapSDK.Guarantee<[LivingMapSDK.Result<T>]>
public func when<T>(resolved promises: [LivingMapSDK.Promise<T>]) -> LivingMapSDK.Guarantee<[LivingMapSDK.Result<T>]>
public func when<It>(resolved promiseIterator: It, concurrently: Swift.Int) -> LivingMapSDK.Guarantee<[LivingMapSDK.Result<It.Element.T>]> where It : Swift.IteratorProtocol, It.Element : LivingMapSDK.Thenable
public func when(_ guarantees: LivingMapSDK.Guarantee<Swift.Void>...) -> LivingMapSDK.Guarantee<Swift.Void>
public func when(guarantees: [LivingMapSDK.Guarantee<Swift.Void>]) -> LivingMapSDK.Guarantee<Swift.Void>
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class LMWebViewController : UIKit.UIViewController, WebKit.WKUIDelegate, LivingMapSDK.LivingMapInterface, LivingMapSDK.DebugModeListener {
  @_Concurrency.MainActor(unsafe) public var mapUrl: Swift.String?
  @_Concurrency.MainActor(unsafe) public var mapQueryParams: [Foundation.URLQueryItem]?
  @_Concurrency.MainActor(unsafe) public var eventHandler: (any LivingMapSDK.LivingMapMappingEvents)?
  @_Concurrency.MainActor(unsafe) public var mapPackUpToDate: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var mapPackDoneLoading: Swift.Bool
  @_Concurrency.MainActor(unsafe) public func setSDKManager(sdkManager: LivingMapSDK.LivingMapSDKManager)
  @_Concurrency.MainActor(unsafe) public func onConnectivityStatusChanged(connectivityStatus: LivingMapSDK.LivingMapConstants.ConnectivityStatus)
  @_Concurrency.MainActor(unsafe) public func changeView(mapView: LivingMapSDK.MapView)
  @_Concurrency.MainActor(unsafe) public func set(mapPackDoneLoading: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func set(mapPackUpToDate: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor(unsafe) public func getWebView() -> WebKit.WKWebView?
  @_Concurrency.MainActor(unsafe) public func isMapReady() -> Swift.Bool
  @_Concurrency.MainActor(unsafe) public func sendCommandToFrontEnd(command: Swift.String, completionHandler: @escaping (Any?, (any Swift.Error)?) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func sendCommandToFrontEnd(command: Swift.String, returnCallback: @escaping (Any?, (any Swift.Error)?) -> Swift.Void, eventKeyCallbackListener: Swift.String, asyncCallback: @escaping (Foundation.NSArray) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func onCalibrationMatricesUpdate(calibrationMatrices: LivingMapSDK.CalibrationMatrices?, calibrationMethod: LivingMapSDK.MagnetometerCalibrationMethod)
  @_Concurrency.MainActor(unsafe) public func onAltitudeUpdate(altitude: Swift.Double, pressure: Swift.Double)
  @_Concurrency.MainActor(unsafe) public func stepInfoUpdated(_ step: LivingMapSDK.LMStep)
  @_Concurrency.MainActor(unsafe) public func elevationStatusUpdated(status: Swift.String)
  @_Concurrency.MainActor(unsafe) public func headingReceived(heading: LivingMapSDK.LMHeading, sendToFrontend: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func locationReceived(location: LivingMapSDK.LMLocation)
  @_Concurrency.MainActor(unsafe) public func onCPLMetricsUpdate(offset: Swift.Double, depletion: Swift.Double)
  @_Concurrency.MainActor(unsafe) public func errorReceived(error: LivingMapSDK.LivingMapError)
  @_Concurrency.MainActor(unsafe) public func setEventHandler(eventHandler: any LivingMapSDK.LivingMapMappingEvents)
  @_Concurrency.MainActor(unsafe) public func customEvent(eventId: Swift.String, eventParameters: Foundation.NSArray)
  @_Concurrency.MainActor(unsafe) public func destinationReached()
  @_Concurrency.MainActor(unsafe) public func disableClickableAssets()
  @_Concurrency.MainActor(unsafe) public func enableClickableAssets()
  @_Concurrency.MainActor(unsafe) public func onPositioningReady()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
open class ServerTrustManager {
  final public let allHostsMustBeEvaluated: Swift.Bool
  final public let evaluators: [Swift.String : any LivingMapSDK.ServerTrustEvaluating]
  public init(allHostsMustBeEvaluated: Swift.Bool = true, evaluators: [Swift.String : any LivingMapSDK.ServerTrustEvaluating])
  open func serverTrustEvaluator(forHost host: Swift.String) throws -> (any LivingMapSDK.ServerTrustEvaluating)?
  @objc deinit
}
public protocol ServerTrustEvaluating {
  func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
final public class DefaultTrustEvaluator : LivingMapSDK.ServerTrustEvaluating {
  public init(validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class RevocationTrustEvaluator : LivingMapSDK.ServerTrustEvaluating {
  public struct Options : Swift.OptionSet {
    public static let crl: LivingMapSDK.RevocationTrustEvaluator.Options
    public static let networkAccessDisabled: LivingMapSDK.RevocationTrustEvaluator.Options
    public static let ocsp: LivingMapSDK.RevocationTrustEvaluator.Options
    public static let preferCRL: LivingMapSDK.RevocationTrustEvaluator.Options
    public static let requirePositiveResponse: LivingMapSDK.RevocationTrustEvaluator.Options
    public static let any: LivingMapSDK.RevocationTrustEvaluator.Options
    public let rawValue: CoreFoundation.CFOptionFlags
    public init(rawValue: CoreFoundation.CFOptionFlags)
    public typealias ArrayLiteralElement = LivingMapSDK.RevocationTrustEvaluator.Options
    public typealias Element = LivingMapSDK.RevocationTrustEvaluator.Options
    public typealias RawValue = CoreFoundation.CFOptionFlags
  }
  public init(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: LivingMapSDK.RevocationTrustEvaluator.Options = .any)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension LivingMapSDK.ServerTrustEvaluating where Self == LivingMapSDK.RevocationTrustEvaluator {
  public static var revocationChecking: LivingMapSDK.RevocationTrustEvaluator {
    get
  }
  public static func revocationChecking(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: LivingMapSDK.RevocationTrustEvaluator.Options = .any) -> LivingMapSDK.RevocationTrustEvaluator
}
final public class PinnedCertificatesTrustEvaluator : LivingMapSDK.ServerTrustEvaluating {
  public init(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension LivingMapSDK.ServerTrustEvaluating where Self == LivingMapSDK.PinnedCertificatesTrustEvaluator {
  public static var pinnedCertificates: LivingMapSDK.PinnedCertificatesTrustEvaluator {
    get
  }
  public static func pinnedCertificates(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true) -> LivingMapSDK.PinnedCertificatesTrustEvaluator
}
final public class PublicKeysTrustEvaluator : LivingMapSDK.ServerTrustEvaluating {
  public init(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension LivingMapSDK.ServerTrustEvaluating where Self == LivingMapSDK.PublicKeysTrustEvaluator {
  public static var publicKeys: LivingMapSDK.PublicKeysTrustEvaluator {
    get
  }
  public static func publicKeys(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true) -> LivingMapSDK.PublicKeysTrustEvaluator
}
final public class CompositeTrustEvaluator : LivingMapSDK.ServerTrustEvaluating {
  public init(evaluators: [any LivingMapSDK.ServerTrustEvaluating])
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension LivingMapSDK.ServerTrustEvaluating where Self == LivingMapSDK.CompositeTrustEvaluator {
  public static func composite(evaluators: [any LivingMapSDK.ServerTrustEvaluating]) -> LivingMapSDK.CompositeTrustEvaluator
}
@available(*, deprecated, renamed: "DisabledTrustEvaluator", message: "DisabledEvaluator has been renamed DisabledTrustEvaluator.")
public typealias DisabledEvaluator = LivingMapSDK.DisabledTrustEvaluator
final public class DisabledTrustEvaluator : LivingMapSDK.ServerTrustEvaluating {
  public init()
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension Swift.Array where Element == any LivingMapSDK.ServerTrustEvaluating {
  public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
extension Foundation.Bundle : LivingMapSDK.AlamofireExtended {
  public typealias ExtendedType = Foundation.Bundle
}
extension LivingMapSDK.AlamofireExtension where ExtendedType : Foundation.Bundle {
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
  public func paths(forResourcesOfTypes types: [Swift.String]) -> [Swift.String]
}
extension Security.SecTrust : LivingMapSDK.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrust
}
extension LivingMapSDK.AlamofireExtension where ExtendedType == Security.SecTrust {
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate(afterApplying policy: Security.SecPolicy) throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate(afterApplying:)")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate(afterApplying:)")
  public func validate(policy: Security.SecPolicy, errorProducer: (_ status: Darwin.OSStatus, _ result: Security.SecTrustResultType) -> any Swift.Error) throws
  public func apply(policy: Security.SecPolicy) throws -> Security.SecTrust
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate() throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate()")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate()")
  public func validate(errorProducer: (_ status: Darwin.OSStatus, _ result: Security.SecTrustResultType) -> any Swift.Error) throws
  public func setAnchorCertificates(_ certificates: [Security.SecCertificate]) throws
  public var publicKeys: [Security.SecKey] {
    get
  }
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var certificateData: [Foundation.Data] {
    get
  }
  public func performDefaultValidation(forHost host: Swift.String) throws
  public func performValidation(forHost host: Swift.String) throws
}
extension Security.SecPolicy : LivingMapSDK.AlamofireExtended {
  public typealias ExtendedType = Security.SecPolicy
}
extension LivingMapSDK.AlamofireExtension where ExtendedType == Security.SecPolicy {
  public static let `default`: Security.SecPolicy
  public static func hostname(_ hostname: Swift.String) -> Security.SecPolicy
  public static func revocation(options: LivingMapSDK.RevocationTrustEvaluator.Options) throws -> Security.SecPolicy
}
extension Swift.Array : LivingMapSDK.AlamofireExtended {
  public typealias ExtendedType = Swift.Array<Element>
}
extension LivingMapSDK.AlamofireExtension where ExtendedType == [Security.SecCertificate] {
  public var data: [Foundation.Data] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
}
extension Security.SecCertificate : LivingMapSDK.AlamofireExtended {
  public typealias ExtendedType = Security.SecCertificate
}
extension LivingMapSDK.AlamofireExtension where ExtendedType == Security.SecCertificate {
  public var publicKey: Security.SecKey? {
    get
  }
}
extension Swift.Int32 : LivingMapSDK.AlamofireExtended {
  public typealias ExtendedType = Swift.Int32
}
extension LivingMapSDK.AlamofireExtension where ExtendedType == Swift.Int32 {
  public var isSuccess: Swift.Bool {
    get
  }
}
extension Security.SecTrustResultType : LivingMapSDK.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrustResultType
}
extension LivingMapSDK.AlamofireExtension where ExtendedType == Security.SecTrustResultType {
  public var isSuccess: Swift.Bool {
    get
  }
}
public let JS_COMMAND_GET_CENTER_LOCATION: Swift.String
public let JS_COMMAND_GET_DISPLAYED_FLOOR: Swift.String
public let JS_COMMAND_CREATE_LOCATION_MARKER: Swift.String
public let JS_COMMAND_CLEAR_MARKERS: Swift.String
public protocol CatchMixin : LivingMapSDK.Thenable {
}
extension LivingMapSDK.CatchMixin {
  @discardableResult
  public func `catch`(on: Dispatch.DispatchQueue? = conf.Q.return, flags: Dispatch.DispatchWorkItemFlags? = nil, policy: LivingMapSDK.CatchPolicy = conf.catchPolicy, _ body: @escaping (any Swift.Error) -> Swift.Void) -> LivingMapSDK.PMKFinalizer
}
@_hasMissingDesignatedInitializers public class PMKFinalizer {
  public func finally(on: Dispatch.DispatchQueue? = conf.Q.return, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping () -> Swift.Void)
  @objc deinit
}
extension LivingMapSDK.CatchMixin {
  public func recover<U>(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, policy: LivingMapSDK.CatchPolicy = conf.catchPolicy, _ body: @escaping (any Swift.Error) throws -> U) -> LivingMapSDK.Promise<Self.T> where U : LivingMapSDK.Thenable, Self.T == U.T
  @discardableResult
  public func recover(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (any Swift.Error) -> LivingMapSDK.Guarantee<Self.T>) -> LivingMapSDK.Guarantee<Self.T>
  public func ensure(on: Dispatch.DispatchQueue? = conf.Q.return, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping () -> Swift.Void) -> LivingMapSDK.Promise<Self.T>
  public func ensureThen(on: Dispatch.DispatchQueue? = conf.Q.return, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping () -> LivingMapSDK.Guarantee<Swift.Void>) -> LivingMapSDK.Promise<Self.T>
  @discardableResult
  public func cauterize() -> LivingMapSDK.PMKFinalizer
}
extension LivingMapSDK.CatchMixin where Self.T == () {
  @discardableResult
  public func recover(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, _ body: @escaping (any Swift.Error) -> Swift.Void) -> LivingMapSDK.Guarantee<Swift.Void>
  public func recover(on: Dispatch.DispatchQueue? = conf.Q.map, flags: Dispatch.DispatchWorkItemFlags? = nil, policy: LivingMapSDK.CatchPolicy = conf.catchPolicy, _ body: @escaping (any Swift.Error) throws -> Swift.Void) -> LivingMapSDK.Promise<Swift.Void>
}
@_hasMissingDesignatedInitializers open class NetworkReachabilityManager {
  public enum NetworkReachabilityStatus {
    case unknown
    case notReachable
    case reachable(LivingMapSDK.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType)
    public enum ConnectionType {
      case ethernetOrWiFi
      case cellular
      public static func == (a: LivingMapSDK.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType, b: LivingMapSDK.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
  }
  public typealias Listener = (LivingMapSDK.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Void
  public static let `default`: LivingMapSDK.NetworkReachabilityManager?
  open var isReachable: Swift.Bool {
    get
  }
  open var isReachableOnCellular: Swift.Bool {
    get
  }
  open var isReachableOnEthernetOrWiFi: Swift.Bool {
    get
  }
  final public let reachabilityQueue: Dispatch.DispatchQueue
  open var flags: SystemConfiguration.SCNetworkReachabilityFlags? {
    get
  }
  open var status: LivingMapSDK.NetworkReachabilityManager.NetworkReachabilityStatus {
    get
  }
  convenience public init?(host: Swift.String)
  convenience public init?()
  @objc deinit
  @discardableResult
  open func startListening(onQueue queue: Dispatch.DispatchQueue = .main, onUpdatePerforming listener: @escaping LivingMapSDK.NetworkReachabilityManager.Listener) -> Swift.Bool
  open func stopListening()
}
extension LivingMapSDK.NetworkReachabilityManager.NetworkReachabilityStatus : Swift.Equatable {
  public static func == (a: LivingMapSDK.NetworkReachabilityManager.NetworkReachabilityStatus, b: LivingMapSDK.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Bool
}
public protocol DataResponseSerializerProtocol {
  associatedtype SerializedObject
  func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> Self.SerializedObject
}
public protocol DownloadResponseSerializerProtocol {
  associatedtype SerializedObject
  func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: (any Swift.Error)?) throws -> Self.SerializedObject
}
public protocol ResponseSerializer : LivingMapSDK.DataResponseSerializerProtocol, LivingMapSDK.DownloadResponseSerializerProtocol {
  var dataPreprocessor: any LivingMapSDK.DataPreprocessor { get }
  var emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> { get }
  var emptyResponseCodes: Swift.Set<Swift.Int> { get }
}
public protocol DataPreprocessor {
  func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct PassthroughPreprocessor : LivingMapSDK.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct GoogleXSSIPreprocessor : LivingMapSDK.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
extension LivingMapSDK.DataPreprocessor where Self == LivingMapSDK.PassthroughPreprocessor {
  public static var passthrough: LivingMapSDK.PassthroughPreprocessor {
    get
  }
}
extension LivingMapSDK.DataPreprocessor where Self == LivingMapSDK.GoogleXSSIPreprocessor {
  public static var googleXSSI: LivingMapSDK.GoogleXSSIPreprocessor {
    get
  }
}
extension LivingMapSDK.ResponseSerializer {
  public static var defaultDataPreprocessor: any LivingMapSDK.DataPreprocessor {
    get
  }
  public static var defaultEmptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> {
    get
  }
  public static var defaultEmptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public var dataPreprocessor: any LivingMapSDK.DataPreprocessor {
    get
  }
  public var emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> {
    get
  }
  public var emptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public func requestAllowsEmptyResponseData(_ request: Foundation.URLRequest?) -> Swift.Bool?
  public func responseAllowsEmptyResponseData(_ response: Foundation.HTTPURLResponse?) -> Swift.Bool?
  public func emptyResponseAllowed(forRequest request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?) -> Swift.Bool
}
extension LivingMapSDK.DownloadResponseSerializerProtocol where Self : LivingMapSDK.DataResponseSerializerProtocol {
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: (any Swift.Error)?) throws -> Self.SerializedObject
}
extension LivingMapSDK.DataRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (LivingMapSDK.AFDataResponse<Foundation.Data?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (LivingMapSDK.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : LivingMapSDK.DataResponseSerializerProtocol
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (LivingMapSDK.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : LivingMapSDK.ResponseSerializer
}
extension LivingMapSDK.DownloadRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (LivingMapSDK.AFDownloadResponse<Foundation.URL?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (LivingMapSDK.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : LivingMapSDK.DownloadResponseSerializerProtocol
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (LivingMapSDK.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : LivingMapSDK.ResponseSerializer
}
public struct URLResponseSerializer : LivingMapSDK.DownloadResponseSerializerProtocol {
  public init()
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: (any Swift.Error)?) throws -> Foundation.URL
  public typealias SerializedObject = Foundation.URL
}
extension LivingMapSDK.DownloadResponseSerializerProtocol where Self == LivingMapSDK.URLResponseSerializer {
  public static var url: LivingMapSDK.URLResponseSerializer {
    get
  }
}
extension LivingMapSDK.DownloadRequest {
  @discardableResult
  public func responseURL(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (LivingMapSDK.AFDownloadResponse<Foundation.URL>) -> Swift.Void) -> Self
}
final public class DataResponseSerializer : LivingMapSDK.ResponseSerializer {
  final public let dataPreprocessor: any LivingMapSDK.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod>
  public init(dataPreprocessor: any LivingMapSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
  @objc deinit
}
extension LivingMapSDK.ResponseSerializer where Self == LivingMapSDK.DataResponseSerializer {
  public static var data: LivingMapSDK.DataResponseSerializer {
    get
  }
  public static func data(dataPreprocessor: any LivingMapSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> LivingMapSDK.DataResponseSerializer
}
extension LivingMapSDK.DataRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any LivingMapSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (LivingMapSDK.AFDataResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension LivingMapSDK.DownloadRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any LivingMapSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (LivingMapSDK.AFDownloadResponse<Foundation.Data>) -> Swift.Void) -> Self
}
final public class StringResponseSerializer : LivingMapSDK.ResponseSerializer {
  final public let dataPreprocessor: any LivingMapSDK.DataPreprocessor
  final public let encoding: Swift.String.Encoding?
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod>
  public init(dataPreprocessor: any LivingMapSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> Swift.String
  public typealias SerializedObject = Swift.String
  @objc deinit
}
extension LivingMapSDK.ResponseSerializer where Self == LivingMapSDK.StringResponseSerializer {
  public static var string: LivingMapSDK.StringResponseSerializer {
    get
  }
  public static func string(dataPreprocessor: any LivingMapSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> LivingMapSDK.StringResponseSerializer
}
extension LivingMapSDK.DataRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any LivingMapSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (LivingMapSDK.AFDataResponse<Swift.String>) -> Swift.Void) -> Self
}
extension LivingMapSDK.DownloadRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any LivingMapSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (LivingMapSDK.AFDownloadResponse<Swift.String>) -> Swift.Void) -> Self
}
@available(*, deprecated, message: "JSONResponseSerializer deprecated and will be removed in Alamofire 6. Use DecodableResponseSerializer instead.")
final public class JSONResponseSerializer : LivingMapSDK.ResponseSerializer {
  final public let dataPreprocessor: any LivingMapSDK.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod>
  final public let options: Foundation.JSONSerialization.ReadingOptions
  public init(dataPreprocessor: any LivingMapSDK.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> Any
  public typealias SerializedObject = Any
  @objc deinit
}
extension LivingMapSDK.DataRequest {
  @available(*, deprecated, message: "responseJSON deprecated and will be removed in Alamofire 6. Use responseDecodable instead.")
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any LivingMapSDK.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (LivingMapSDK.AFDataResponse<Any>) -> Swift.Void) -> Self
}
extension LivingMapSDK.DownloadRequest {
  @available(*, deprecated, message: "responseJSON deprecated and will be removed in Alamofire 6. Use responseDecodable instead.")
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any LivingMapSDK.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (LivingMapSDK.AFDownloadResponse<Any>) -> Swift.Void) -> Self
}
public protocol EmptyResponse {
  static func emptyValue() -> Self
}
public struct Empty : Swift.Codable {
  public static let value: LivingMapSDK.Empty
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension LivingMapSDK.Empty : LivingMapSDK.EmptyResponse {
  public static func emptyValue() -> LivingMapSDK.Empty
}
public protocol DataDecoder {
  func decode<D>(_ type: D.Type, from data: Foundation.Data) throws -> D where D : Swift.Decodable
}
extension Foundation.JSONDecoder : LivingMapSDK.DataDecoder {
}
extension Foundation.PropertyListDecoder : LivingMapSDK.DataDecoder {
}
final public class DecodableResponseSerializer<T> : LivingMapSDK.ResponseSerializer where T : Swift.Decodable {
  final public let dataPreprocessor: any LivingMapSDK.DataPreprocessor
  final public let decoder: any LivingMapSDK.DataDecoder
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod>
  public init(dataPreprocessor: any LivingMapSDK.DataPreprocessor = DecodableResponseSerializer.defaultDataPreprocessor, decoder: any LivingMapSDK.DataDecoder = JSONDecoder() as DataDecoder, emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DecodableResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> T
  public typealias SerializedObject = T
  @objc deinit
}
extension LivingMapSDK.ResponseSerializer {
  public static func decodable<T>(of type: T.Type, dataPreprocessor: any LivingMapSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any LivingMapSDK.DataDecoder = JSONDecoder() as DataDecoder, emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> LivingMapSDK.DecodableResponseSerializer<T> where Self == LivingMapSDK.DecodableResponseSerializer<T>, T : Swift.Decodable
}
extension LivingMapSDK.DataRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any LivingMapSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any LivingMapSDK.DataDecoder = JSONDecoder() as DataDecoder, emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (LivingMapSDK.AFDataResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
extension LivingMapSDK.DownloadRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any LivingMapSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any LivingMapSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<LivingMapSDK.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (LivingMapSDK.AFDownloadResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
public protocol DataStreamSerializer {
  associatedtype SerializedObject
  func serialize(_ data: Foundation.Data) throws -> Self.SerializedObject
}
public struct DecodableStreamSerializer<T> : LivingMapSDK.DataStreamSerializer where T : Swift.Decodable {
  public let decoder: any LivingMapSDK.DataDecoder
  public let dataPreprocessor: any LivingMapSDK.DataPreprocessor
  public init(decoder: any LivingMapSDK.DataDecoder = JSONDecoder(), dataPreprocessor: any LivingMapSDK.DataPreprocessor = PassthroughPreprocessor())
  public func serialize(_ data: Foundation.Data) throws -> T
  public typealias SerializedObject = T
}
public struct PassthroughStreamSerializer : LivingMapSDK.DataStreamSerializer {
  public func serialize(_ data: Foundation.Data) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
}
public struct StringStreamSerializer : LivingMapSDK.DataStreamSerializer {
  public func serialize(_ data: Foundation.Data) throws -> Swift.String
  public typealias SerializedObject = Swift.String
}
extension LivingMapSDK.DataStreamSerializer {
  public static func decodable<T>(of type: T.Type, decoder: any LivingMapSDK.DataDecoder = JSONDecoder(), dataPreprocessor: any LivingMapSDK.DataPreprocessor = PassthroughPreprocessor()) -> Self where Self == LivingMapSDK.DecodableStreamSerializer<T>, T : Swift.Decodable
}
extension LivingMapSDK.DataStreamSerializer where Self == LivingMapSDK.PassthroughStreamSerializer {
  public static var passthrough: LivingMapSDK.PassthroughStreamSerializer {
    get
  }
}
extension LivingMapSDK.DataStreamSerializer where Self == LivingMapSDK.StringStreamSerializer {
  public static var string: LivingMapSDK.StringStreamSerializer {
    get
  }
}
extension LivingMapSDK.DataStreamRequest {
  @discardableResult
  final public func responseStream(on queue: Dispatch.DispatchQueue = .main, stream: @escaping LivingMapSDK.DataStreamRequest.Handler<Foundation.Data, Swift.Never>) -> Self
  @discardableResult
  final public func responseStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main, stream: @escaping LivingMapSDK.DataStreamRequest.Handler<Serializer.SerializedObject, LivingMapSDK.AFError>) -> Self where Serializer : LivingMapSDK.DataStreamSerializer
  @discardableResult
  final public func responseStreamString(on queue: Dispatch.DispatchQueue = .main, stream: @escaping LivingMapSDK.DataStreamRequest.Handler<Swift.String, Swift.Never>) -> Self
  @discardableResult
  final public func responseStreamDecodable<T>(of type: T.Type = T.self, on queue: Dispatch.DispatchQueue = .main, using decoder: any LivingMapSDK.DataDecoder = JSONDecoder() as DataDecoder, preprocessor: any LivingMapSDK.DataPreprocessor = PassthroughPreprocessor(), stream: @escaping LivingMapSDK.DataStreamRequest.Handler<T, LivingMapSDK.AFError>) -> Self where T : Swift.Decodable
}
extension LivingMapSDK.Google_Protobuf_FieldMask {
  public init(protoPaths: [Swift.String])
  public init(protoPaths: Swift.String...)
  public init?(jsonPaths: Swift.String...)
}
extension LivingMapSDK.Message {
  public func jsonString(options: LivingMapSDK.JSONEncodingOptions = JSONEncodingOptions()) throws -> Swift.String
  public func jsonUTF8Data(options: LivingMapSDK.JSONEncodingOptions = JSONEncodingOptions()) throws -> Foundation.Data
  public init(jsonString: Swift.String, options: LivingMapSDK.JSONDecodingOptions = JSONDecodingOptions()) throws
  public init(jsonString: Swift.String, extensions: (any LivingMapSDK.ExtensionMap)? = nil, options: LivingMapSDK.JSONDecodingOptions = JSONDecodingOptions()) throws
  public init(jsonUTF8Data: Foundation.Data, options: LivingMapSDK.JSONDecodingOptions = JSONDecodingOptions()) throws
  public init(jsonUTF8Data: Foundation.Data, extensions: (any LivingMapSDK.ExtensionMap)? = nil, options: LivingMapSDK.JSONDecodingOptions = JSONDecodingOptions()) throws
}
public protocol AnyExtensionField : Swift.CustomDebugStringConvertible {
  func hash(into hasher: inout Swift.Hasher)
  var protobufExtension: any LivingMapSDK.AnyMessageExtension { get }
  func isEqual(other: any LivingMapSDK.AnyExtensionField) -> Swift.Bool
  mutating func decodeExtensionField<T>(decoder: inout T) throws where T : LivingMapSDK.ProtoDecoder
  func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  var isInitialized: Swift.Bool { get }
}
extension LivingMapSDK.AnyExtensionField {
  public var isInitialized: Swift.Bool {
    get
  }
}
public protocol ExtensionField : LivingMapSDK.AnyExtensionField, Swift.Hashable {
  associatedtype ValueType
  var value: Self.ValueType { get set }
  init(protobufExtension: any LivingMapSDK.AnyMessageExtension, value: Self.ValueType)
  init?<D>(protobufExtension: any LivingMapSDK.AnyMessageExtension, decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
}
public struct OptionalExtensionField<T> : LivingMapSDK.ExtensionField where T : LivingMapSDK.FieldType {
  public typealias BaseType = T.BaseType
  public typealias ValueType = LivingMapSDK.OptionalExtensionField<T>.BaseType
  public var value: LivingMapSDK.OptionalExtensionField<T>.ValueType
  public var protobufExtension: any LivingMapSDK.AnyMessageExtension
  public static func == (lhs: LivingMapSDK.OptionalExtensionField<T>, rhs: LivingMapSDK.OptionalExtensionField<T>) -> Swift.Bool
  public init(protobufExtension: any LivingMapSDK.AnyMessageExtension, value: LivingMapSDK.OptionalExtensionField<T>.ValueType)
  public var debugDescription: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public func isEqual(other: any LivingMapSDK.AnyExtensionField) -> Swift.Bool
  public mutating func decodeExtensionField<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public init?<D>(protobufExtension: any LivingMapSDK.AnyMessageExtension, decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public var hashValue: Swift.Int {
    get
  }
}
public struct RepeatedExtensionField<T> : LivingMapSDK.ExtensionField where T : LivingMapSDK.FieldType {
  public typealias BaseType = T.BaseType
  public typealias ValueType = [LivingMapSDK.RepeatedExtensionField<T>.BaseType]
  public var value: LivingMapSDK.RepeatedExtensionField<T>.ValueType
  public var protobufExtension: any LivingMapSDK.AnyMessageExtension
  public static func == (lhs: LivingMapSDK.RepeatedExtensionField<T>, rhs: LivingMapSDK.RepeatedExtensionField<T>) -> Swift.Bool
  public init(protobufExtension: any LivingMapSDK.AnyMessageExtension, value: LivingMapSDK.RepeatedExtensionField<T>.ValueType)
  public func hash(into hasher: inout Swift.Hasher)
  public func isEqual(other: any LivingMapSDK.AnyExtensionField) -> Swift.Bool
  public var debugDescription: Swift.String {
    get
  }
  public mutating func decodeExtensionField<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public init?<D>(protobufExtension: any LivingMapSDK.AnyMessageExtension, decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public var hashValue: Swift.Int {
    get
  }
}
public struct PackedExtensionField<T> : LivingMapSDK.ExtensionField where T : LivingMapSDK.FieldType {
  public typealias BaseType = T.BaseType
  public typealias ValueType = [LivingMapSDK.PackedExtensionField<T>.BaseType]
  public var value: LivingMapSDK.PackedExtensionField<T>.ValueType
  public var protobufExtension: any LivingMapSDK.AnyMessageExtension
  public static func == (lhs: LivingMapSDK.PackedExtensionField<T>, rhs: LivingMapSDK.PackedExtensionField<T>) -> Swift.Bool
  public init(protobufExtension: any LivingMapSDK.AnyMessageExtension, value: LivingMapSDK.PackedExtensionField<T>.ValueType)
  public func hash(into hasher: inout Swift.Hasher)
  public func isEqual(other: any LivingMapSDK.AnyExtensionField) -> Swift.Bool
  public var debugDescription: Swift.String {
    get
  }
  public mutating func decodeExtensionField<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public init?<D>(protobufExtension: any LivingMapSDK.AnyMessageExtension, decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public var hashValue: Swift.Int {
    get
  }
}
public struct OptionalEnumExtensionField<E> : LivingMapSDK.ExtensionField where E : LivingMapSDK.Enum, E.RawValue == Swift.Int {
  public typealias BaseType = E
  public typealias ValueType = E
  public var value: LivingMapSDK.OptionalEnumExtensionField<E>.ValueType
  public var protobufExtension: any LivingMapSDK.AnyMessageExtension
  public static func == (lhs: LivingMapSDK.OptionalEnumExtensionField<E>, rhs: LivingMapSDK.OptionalEnumExtensionField<E>) -> Swift.Bool
  public init(protobufExtension: any LivingMapSDK.AnyMessageExtension, value: LivingMapSDK.OptionalEnumExtensionField<E>.ValueType)
  public var debugDescription: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public func isEqual(other: any LivingMapSDK.AnyExtensionField) -> Swift.Bool
  public mutating func decodeExtensionField<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public init?<D>(protobufExtension: any LivingMapSDK.AnyMessageExtension, decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public var hashValue: Swift.Int {
    get
  }
}
public struct RepeatedEnumExtensionField<E> : LivingMapSDK.ExtensionField where E : LivingMapSDK.Enum, E.RawValue == Swift.Int {
  public typealias BaseType = E
  public typealias ValueType = [E]
  public var value: LivingMapSDK.RepeatedEnumExtensionField<E>.ValueType
  public var protobufExtension: any LivingMapSDK.AnyMessageExtension
  public static func == (lhs: LivingMapSDK.RepeatedEnumExtensionField<E>, rhs: LivingMapSDK.RepeatedEnumExtensionField<E>) -> Swift.Bool
  public init(protobufExtension: any LivingMapSDK.AnyMessageExtension, value: LivingMapSDK.RepeatedEnumExtensionField<E>.ValueType)
  public func hash(into hasher: inout Swift.Hasher)
  public func isEqual(other: any LivingMapSDK.AnyExtensionField) -> Swift.Bool
  public var debugDescription: Swift.String {
    get
  }
  public mutating func decodeExtensionField<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public init?<D>(protobufExtension: any LivingMapSDK.AnyMessageExtension, decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public var hashValue: Swift.Int {
    get
  }
}
public struct PackedEnumExtensionField<E> : LivingMapSDK.ExtensionField where E : LivingMapSDK.Enum, E.RawValue == Swift.Int {
  public typealias BaseType = E
  public typealias ValueType = [E]
  public var value: LivingMapSDK.PackedEnumExtensionField<E>.ValueType
  public var protobufExtension: any LivingMapSDK.AnyMessageExtension
  public static func == (lhs: LivingMapSDK.PackedEnumExtensionField<E>, rhs: LivingMapSDK.PackedEnumExtensionField<E>) -> Swift.Bool
  public init(protobufExtension: any LivingMapSDK.AnyMessageExtension, value: LivingMapSDK.PackedEnumExtensionField<E>.ValueType)
  public func hash(into hasher: inout Swift.Hasher)
  public func isEqual(other: any LivingMapSDK.AnyExtensionField) -> Swift.Bool
  public var debugDescription: Swift.String {
    get
  }
  public mutating func decodeExtensionField<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public init?<D>(protobufExtension: any LivingMapSDK.AnyMessageExtension, decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public var hashValue: Swift.Int {
    get
  }
}
public struct OptionalMessageExtensionField<M> : LivingMapSDK.ExtensionField where M : LivingMapSDK.Message, M : Swift.Equatable {
  public typealias BaseType = M
  public typealias ValueType = LivingMapSDK.OptionalMessageExtensionField<M>.BaseType
  public var value: LivingMapSDK.OptionalMessageExtensionField<M>.ValueType
  public var protobufExtension: any LivingMapSDK.AnyMessageExtension
  public static func == (lhs: LivingMapSDK.OptionalMessageExtensionField<M>, rhs: LivingMapSDK.OptionalMessageExtensionField<M>) -> Swift.Bool
  public init(protobufExtension: any LivingMapSDK.AnyMessageExtension, value: LivingMapSDK.OptionalMessageExtensionField<M>.ValueType)
  public var debugDescription: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public func isEqual(other: any LivingMapSDK.AnyExtensionField) -> Swift.Bool
  public mutating func decodeExtensionField<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public init?<D>(protobufExtension: any LivingMapSDK.AnyMessageExtension, decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public var isInitialized: Swift.Bool {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public struct RepeatedMessageExtensionField<M> : LivingMapSDK.ExtensionField where M : LivingMapSDK.Message, M : Swift.Equatable {
  public typealias BaseType = M
  public typealias ValueType = [LivingMapSDK.RepeatedMessageExtensionField<M>.BaseType]
  public var value: LivingMapSDK.RepeatedMessageExtensionField<M>.ValueType
  public var protobufExtension: any LivingMapSDK.AnyMessageExtension
  public static func == (lhs: LivingMapSDK.RepeatedMessageExtensionField<M>, rhs: LivingMapSDK.RepeatedMessageExtensionField<M>) -> Swift.Bool
  public init(protobufExtension: any LivingMapSDK.AnyMessageExtension, value: LivingMapSDK.RepeatedMessageExtensionField<M>.ValueType)
  public func hash(into hasher: inout Swift.Hasher)
  public func isEqual(other: any LivingMapSDK.AnyExtensionField) -> Swift.Bool
  public var debugDescription: Swift.String {
    get
  }
  public mutating func decodeExtensionField<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public init?<D>(protobufExtension: any LivingMapSDK.AnyMessageExtension, decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public var isInitialized: Swift.Bool {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public struct OptionalGroupExtensionField<G> : LivingMapSDK.ExtensionField where G : LivingMapSDK.Message, G : Swift.Hashable {
  public typealias BaseType = G
  public typealias ValueType = LivingMapSDK.OptionalGroupExtensionField<G>.BaseType
  public var value: G
  public var protobufExtension: any LivingMapSDK.AnyMessageExtension
  public static func == (lhs: LivingMapSDK.OptionalGroupExtensionField<G>, rhs: LivingMapSDK.OptionalGroupExtensionField<G>) -> Swift.Bool
  public init(protobufExtension: any LivingMapSDK.AnyMessageExtension, value: LivingMapSDK.OptionalGroupExtensionField<G>.ValueType)
  public func hash(into hasher: inout Swift.Hasher)
  public var debugDescription: Swift.String {
    get
  }
  public func isEqual(other: any LivingMapSDK.AnyExtensionField) -> Swift.Bool
  public mutating func decodeExtensionField<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public init?<D>(protobufExtension: any LivingMapSDK.AnyMessageExtension, decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public var isInitialized: Swift.Bool {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public struct RepeatedGroupExtensionField<G> : LivingMapSDK.ExtensionField where G : LivingMapSDK.Message, G : Swift.Hashable {
  public typealias BaseType = G
  public typealias ValueType = [LivingMapSDK.RepeatedGroupExtensionField<G>.BaseType]
  public var value: LivingMapSDK.RepeatedGroupExtensionField<G>.ValueType
  public var protobufExtension: any LivingMapSDK.AnyMessageExtension
  public static func == (lhs: LivingMapSDK.RepeatedGroupExtensionField<G>, rhs: LivingMapSDK.RepeatedGroupExtensionField<G>) -> Swift.Bool
  public init(protobufExtension: any LivingMapSDK.AnyMessageExtension, value: LivingMapSDK.RepeatedGroupExtensionField<G>.ValueType)
  public func hash(into hasher: inout Swift.Hasher)
  public var debugDescription: Swift.String {
    get
  }
  public func isEqual(other: any LivingMapSDK.AnyExtensionField) -> Swift.Bool
  public mutating func decodeExtensionField<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public init?<D>(protobufExtension: any LivingMapSDK.AnyMessageExtension, decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  public func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  public var isInitialized: Swift.Bool {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public let defaultAnyTypeURLPrefix: Swift.String
extension LivingMapSDK.Google_Protobuf_Any {
  public init(message: any LivingMapSDK.Message, partial: Swift.Bool = false, typePrefix: Swift.String = defaultAnyTypeURLPrefix) throws
  public init(textFormatString: Swift.String, options: LivingMapSDK.TextFormatDecodingOptions = TextFormatDecodingOptions(), extensions: (any LivingMapSDK.ExtensionMap)? = nil) throws
  public func isA<M>(_ type: M.Type) -> Swift.Bool where M : LivingMapSDK.Message
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol ExtensionMap {
  subscript(messageType: any LivingMapSDK.Message.Type, fieldNumber: Swift.Int) -> (any LivingMapSDK.AnyMessageExtension)? { get }
  func fieldNumberForProto(messageType: any LivingMapSDK.Message.Type, protoFieldName: Swift.String) -> Swift.Int?
}
public struct PMKConfiguration {
  public var Q: (map: Dispatch.DispatchQueue?, return: Dispatch.DispatchQueue?)
  public var catchPolicy: LivingMapSDK.CatchPolicy
  public var logHandler: (_ event: LivingMapSDK.LogEvent) -> Swift.Void
}
public var conf: LivingMapSDK.PMKConfiguration
open class RetryPolicy : LivingMapSDK.RequestInterceptor {
  public static let defaultRetryLimit: Swift.UInt
  public static let defaultExponentialBackoffBase: Swift.UInt
  public static let defaultExponentialBackoffScale: Swift.Double
  public static let defaultRetryableHTTPMethods: Swift.Set<LivingMapSDK.HTTPMethod>
  public static let defaultRetryableHTTPStatusCodes: Swift.Set<Swift.Int>
  public static let defaultRetryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  final public let retryLimit: Swift.UInt
  final public let exponentialBackoffBase: Swift.UInt
  final public let exponentialBackoffScale: Swift.Double
  final public let retryableHTTPMethods: Swift.Set<LivingMapSDK.HTTPMethod>
  final public let retryableHTTPStatusCodes: Swift.Set<Swift.Int>
  final public let retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<LivingMapSDK.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = RetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes)
  open func retry(_ request: LivingMapSDK.Request, for session: LivingMapSDK.Session, dueTo error: any Swift.Error, completion: @escaping (LivingMapSDK.RetryResult) -> Swift.Void)
  open func shouldRetry(request: LivingMapSDK.Request, dueTo error: any Swift.Error) -> Swift.Bool
  @objc deinit
}
extension LivingMapSDK.RequestInterceptor where Self == LivingMapSDK.RetryPolicy {
  public static var retryPolicy: LivingMapSDK.RetryPolicy {
    get
  }
  public static func retryPolicy(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<LivingMapSDK.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = RetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes) -> LivingMapSDK.RetryPolicy
}
open class ConnectionLostRetryPolicy : LivingMapSDK.RetryPolicy {
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<LivingMapSDK.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods)
  @objc deinit
}
extension LivingMapSDK.RequestInterceptor where Self == LivingMapSDK.ConnectionLostRetryPolicy {
  public static var connectionLostRetryPolicy: LivingMapSDK.ConnectionLostRetryPolicy {
    get
  }
  public static func connectionLostRetryPolicy(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<LivingMapSDK.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods) -> LivingMapSDK.ConnectionLostRetryPolicy
}
@objc open class SessionDelegate : ObjectiveC.NSObject {
  public init(fileManager: Foundation.FileManager = .default)
  @objc deinit
}
extension LivingMapSDK.SessionDelegate : Foundation.URLSessionDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
}
extension LivingMapSDK.SessionDelegate : Foundation.URLSessionTaskDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, needNewBodyStream completionHandler: @escaping (Foundation.InputStream?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
}
extension LivingMapSDK.SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension LivingMapSDK.SessionDelegate : Foundation.URLSessionDownloadDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
}
public protocol Message : Swift.CustomDebugStringConvertible {
  init()
  static var protoMessageName: Swift.String { get }
  var isInitialized: Swift.Bool { get }
  var unknownFields: LivingMapSDK.UnknownStorage { get set }
  mutating func decodeMessage<D>(decoder: inout D) throws where D : LivingMapSDK.ProtoDecoder
  func traverse<V>(visitor: inout V) throws where V : LivingMapSDK.Visitor
  func hash(into hasher: inout Swift.Hasher)
  func isEqualTo(message: any LivingMapSDK.Message) -> Swift.Bool
}
extension LivingMapSDK.Message {
  public var isInitialized: Swift.Bool {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public var debugDescription: Swift.String {
    get
  }
  public static func with(_ populator: (inout Self) throws -> ()) rethrows -> Self
}
public protocol _MessageImplementationBase : LivingMapSDK.Message, Swift.Hashable {
  func _protobuf_generated_isEqualTo(other: Self) -> Swift.Bool
}
extension LivingMapSDK._MessageImplementationBase {
  public func isEqualTo(message: any LivingMapSDK.Message) -> Swift.Bool
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
  public func _protobuf_generated_isEqualTo(other: Self) -> Swift.Bool
}
public class RoutingRequest : Swift.Codable {
  final public let destination: LivingMapSDK.RouteLocation
  final public let origin: LivingMapSDK.RouteLocation
  final public let options: LivingMapSDK.RoutingRequestOptions
  public init(origin: LivingMapSDK.RouteLocation, destination: LivingMapSDK.RouteLocation, options: LivingMapSDK.RoutingRequestOptions)
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
public class RoutingRequestOptions : Swift.Codable {
  public init(via: [LivingMapSDK.RouteLocation]?, destinationAreaName: Swift.String?, destinationName: Swift.String?, originAreaName: Swift.String?, originName: Swift.String?)
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
public func race<U>(_ thenables: U...) -> LivingMapSDK.Promise<U.T> where U : LivingMapSDK.Thenable
public func race<U>(_ thenables: [U]) -> LivingMapSDK.Promise<U.T> where U : LivingMapSDK.Thenable
public func race<T>(_ guarantees: LivingMapSDK.Guarantee<T>...) -> LivingMapSDK.Guarantee<T>
public func race<U>(fulfilled thenables: [U]) -> LivingMapSDK.Promise<U.T> where U : LivingMapSDK.Thenable
extension LivingMapSDK.Google_Protobuf_Struct : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.String
  public typealias Value = LivingMapSDK.Google_Protobuf_Value
  public init(dictionaryLiteral: (Swift.String, LivingMapSDK.Google_Protobuf_Value)...)
}
extension LivingMapSDK.Google_Protobuf_Struct {
  public init(fields: [Swift.String : LivingMapSDK.Google_Protobuf_Value])
  public subscript(key: Swift.String) -> LivingMapSDK.Google_Protobuf_Value? {
    get
    set(newValue)
  }
}
extension LivingMapSDK.Request.State : Swift.Equatable {}
extension LivingMapSDK.Request.State : Swift.Hashable {}
extension LivingMapSDK.LMLocation.CoordinateReferenceSystem : Swift.Equatable {}
extension LivingMapSDK.LMLocation.CoordinateReferenceSystem : Swift.Hashable {}
extension LivingMapSDK.LMLocation.CoordinateReferenceSystem : Swift.RawRepresentable {}
extension LivingMapSDK.LMLocation.LocationSource : Swift.Equatable {}
extension LivingMapSDK.LMLocation.LocationSource : Swift.Hashable {}
extension LivingMapSDK.LMLocation.LocationSource : Swift.RawRepresentable {}
extension LivingMapSDK.LMLocation.LocationError : Swift.Equatable {}
extension LivingMapSDK.LMLocation.LocationError : Swift.Hashable {}
extension LivingMapSDK.CatchPolicy : Swift.Equatable {}
extension LivingMapSDK.CatchPolicy : Swift.Hashable {}
extension LivingMapSDK.MapNotification.NotificationType : Swift.Equatable {}
extension LivingMapSDK.MapNotification.NotificationType : Swift.Hashable {}
extension LivingMapSDK.MapNotification.NotificationType : Swift.RawRepresentable {}
extension LivingMapSDK.MapNotification.Icon : Swift.Equatable {}
extension LivingMapSDK.MapNotification.Icon : Swift.Hashable {}
extension LivingMapSDK.MapNotification.Icon : Swift.RawRepresentable {}
extension LivingMapSDK.PositioningSystem : Swift.Equatable {}
extension LivingMapSDK.PositioningSystem : Swift.Hashable {}
extension LivingMapSDK.PositioningSystem : Swift.RawRepresentable {}
extension LivingMapSDK.HeadingSystem : Swift.Equatable {}
extension LivingMapSDK.HeadingSystem : Swift.Hashable {}
extension LivingMapSDK.HeadingSystem : Swift.RawRepresentable {}
extension LivingMapSDK.MagnetometerCalibrationMethod : Swift.Equatable {}
extension LivingMapSDK.MagnetometerCalibrationMethod : Swift.Hashable {}
extension LivingMapSDK.MagnetometerCalibrationMethod : Swift.RawRepresentable {}
extension LivingMapSDK.HeadingCalculationTrigger : Swift.Equatable {}
extension LivingMapSDK.HeadingCalculationTrigger : Swift.Hashable {}
extension LivingMapSDK.HeadingCalculationTrigger : Swift.RawRepresentable {}
extension LivingMapSDK.BinaryEncodingError : Swift.Equatable {}
extension LivingMapSDK.BinaryEncodingError : Swift.Hashable {}
extension LivingMapSDK.AnyUnpackError : Swift.Equatable {}
extension LivingMapSDK.AnyUnpackError : Swift.Hashable {}
extension LivingMapSDK.Model : Swift.Equatable {}
extension LivingMapSDK.Model : Swift.Hashable {}
extension LivingMapSDK.Model : Swift.RawRepresentable {}
extension LivingMapSDK.HeadingEstimateType : Swift.Equatable {}
extension LivingMapSDK.HeadingEstimateType : Swift.Hashable {}
extension LivingMapSDK.HeadingEstimateType : Swift.RawRepresentable {}
extension LivingMapSDK.HeadingType : Swift.Equatable {}
extension LivingMapSDK.HeadingType : Swift.Hashable {}
extension LivingMapSDK.HeadingType : Swift.RawRepresentable {}
extension LivingMapSDK.LMLogLevel : Swift.Equatable {}
extension LivingMapSDK.LMLogLevel : Swift.Hashable {}
extension LivingMapSDK.LMLogLevel : Swift.RawRepresentable {}
extension LivingMapSDK.PMKNamespacer : Swift.Equatable {}
extension LivingMapSDK.PMKNamespacer : Swift.Hashable {}
extension LivingMapSDK.MapView : Swift.Equatable {}
extension LivingMapSDK.MapView : Swift.Hashable {}
extension LivingMapSDK.MapView : Swift.RawRepresentable {}
extension LivingMapSDK.CacheProgress : Swift.Equatable {}
extension LivingMapSDK.CacheProgress : Swift.Hashable {}
extension LivingMapSDK.CacheProgress : Swift.RawRepresentable {}
extension LivingMapSDK.LivingMapConstants.ConnectivityStatus : Swift.Equatable {}
extension LivingMapSDK.LivingMapConstants.ConnectivityStatus : Swift.Hashable {}
extension LivingMapSDK.LivingMapConstants.ConnectivityStatus : Swift.RawRepresentable {}
extension LivingMapSDK.URLEncodedFormParameterEncoder.Destination : Swift.Equatable {}
extension LivingMapSDK.URLEncodedFormParameterEncoder.Destination : Swift.Hashable {}
extension LivingMapSDK.URLEncoding.Destination : Swift.Equatable {}
extension LivingMapSDK.URLEncoding.Destination : Swift.Hashable {}
extension LivingMapSDK.URLEncoding.ArrayEncoding : Swift.Equatable {}
extension LivingMapSDK.URLEncoding.ArrayEncoding : Swift.Hashable {}
extension LivingMapSDK.URLEncoding.BoolEncoding : Swift.Equatable {}
extension LivingMapSDK.URLEncoding.BoolEncoding : Swift.Hashable {}
extension LivingMapSDK.BinaryDecodingError : Swift.Equatable {}
extension LivingMapSDK.BinaryDecodingError : Swift.Hashable {}
extension LivingMapSDK.URLEncodedFormEncoder.ArrayEncoding : Swift.Equatable {}
extension LivingMapSDK.URLEncodedFormEncoder.ArrayEncoding : Swift.Hashable {}
extension LivingMapSDK.URLEncodedFormEncoder.BoolEncoding : Swift.Equatable {}
extension LivingMapSDK.URLEncodedFormEncoder.BoolEncoding : Swift.Hashable {}
extension LivingMapSDK.URLEncodedFormEncoder.SpaceEncoding : Swift.Equatable {}
extension LivingMapSDK.URLEncodedFormEncoder.SpaceEncoding : Swift.Hashable {}
extension LivingMapSDK.BinaryDelimited.Error : Swift.Equatable {}
extension LivingMapSDK.BinaryDelimited.Error : Swift.Hashable {}
extension LivingMapSDK.AuthenticationError : Swift.Equatable {}
extension LivingMapSDK.AuthenticationError : Swift.Hashable {}
extension LivingMapSDK.LMSensorUpdateFrequencies.LocationAccuracy : Swift.Equatable {}
extension LivingMapSDK.LMSensorUpdateFrequencies.LocationAccuracy : Swift.Hashable {}
extension LivingMapSDK.LMSensorUpdateFrequencies.LocationAccuracy : Swift.RawRepresentable {}
extension LivingMapSDK.LivingMapErrorSeverity : Swift.Equatable {}
extension LivingMapSDK.LivingMapErrorSeverity : Swift.Hashable {}
extension LivingMapSDK.LivingMapErrorSeverity : Swift.RawRepresentable {}
extension LivingMapSDK.LivingMapErrorCode : Swift.Equatable {}
extension LivingMapSDK.LivingMapErrorCode : Swift.Hashable {}
extension LivingMapSDK.LivingMapErrorCode : Swift.RawRepresentable {}
extension LivingMapSDK.TextFormatDecodingError : Swift.Equatable {}
extension LivingMapSDK.TextFormatDecodingError : Swift.Hashable {}
extension LivingMapSDK.JSONEncodingError : Swift.Equatable {}
extension LivingMapSDK.JSONEncodingError : Swift.Hashable {}
extension LivingMapSDK.ApplicationState : Swift.Equatable {}
extension LivingMapSDK.ApplicationState : Swift.Hashable {}
extension LivingMapSDK.ApplicationState : Swift.RawRepresentable {}
extension LivingMapSDK.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Equatable {}
extension LivingMapSDK.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Hashable {}
